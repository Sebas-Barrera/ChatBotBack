Directory structure:
└── ChatBotChingon/
    ├── package.json
    ├── server.js
    ├── test-db.js
    ├── database/
    │   ├── connection.js
    │   ├── dump.db
    │   ├── migrations/
    │   │   ├── 001_initial_schema.sql
    │   │   └── 002_users_and_roles.sql
    │   └── queries/
    │       ├── conversations.js
    │       ├── customers.js
    │       ├── menu.js
    │       ├── orders.js
    │       └── restaurants.js
    ├── docs/
    │   ├── API.md
    │   └── SETUP.md
    ├── logs/
    ├── src/
    │   ├── config/
    │   │   ├── claude.js
    │   │   ├── database.js
    │   │   └── whatsapp.js
    │   ├── controllers/
    │   │   ├── authController.js
    │   │   ├── conversationController.js
    │   │   ├── menuController.js
    │   │   ├── orderController.js
    │   │   ├── restaurantController.js
    │   │   └── webhookController.js
    │   ├── middleware/
    │   │   ├── auth.js
    │   │   ├── errorHandler.js
    │   │   ├── rateLimiter.js
    │   │   └── tenantResolver.js
    │   ├── models/
    │   │   ├── Conversation.js
    │   │   ├── Customer.js
    │   │   ├── Menu.js
    │   │   ├── Order.js
    │   │   ├── Restaurant.js
    │   │   └── User.js
    │   ├── routes/
    │   │   ├── auth.js
    │   │   ├── dashboard.js
    │   │   ├── menu.js
    │   │   ├── orders.js
    │   │   ├── restaurants.js
    │   │   └── webhook.js
    │   ├── services/
    │   │   ├── claudeService.js
    │   │   ├── conversationService.js
    │   │   ├── orderService.js
    │   │   ├── validationService.js
    │   │   └── whatsappService.js
    │   └── utils/
    │       ├── constants.js
    │       ├── helpers.js
    │       ├── logger.js
    │       └── validators.js
    └── tests/
        ├── integration/
        └── unit/

================================================
File: package.json
================================================
{
  "name": "chatbot-chingon",
  "version": "1.0.0",
  "description": "Sistema de chatbot inteligente para restaurantes con WhatsApp y Claude AI - Optimizado para Neon Database",
  "main": "server.js",
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "test:watch": "jest --watch",
    
    "setup": "node scripts/setup-neon.js setup",
    "setup:neon": "node scripts/setup-neon.js setup",
    "setup:clean": "node scripts/setup-neon.js clean",
    "setup:verify": "node scripts/setup-neon.js verify",
    
    "migrate": "node scripts/setup-neon.js setup",
    "migrate:verify": "node scripts/setup-neon.js verify",
    
    "db:setup": "node scripts/setup-neon.js setup",
    "db:clean": "node scripts/setup-neon.js clean",
    "db:verify": "node scripts/setup-neon.js verify",
    
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    
    "logs": "tail -f logs/app.log",
    "logs:error": "grep ERROR logs/app.log",
    
    "production": "NODE_ENV=production node server.js",
    "pm2:start": "pm2 start ecosystem.config.js",
    "pm2:stop": "pm2 stop chatbot-chingon",
    "pm2:restart": "pm2 restart chatbot-chingon",
    "pm2:logs": "pm2 logs chatbot-chingon"
  },
  "keywords": [
    "chatbot",
    "whatsapp",
    "restaurant",
    "claude-ai",
    "food-delivery",
    "nodejs",
    "neon-database",
    "postgresql"
  ],
  "author": "NexDev",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "compression": "^1.7.4",
    "dotenv": "^16.3.1",
    "pg": "^8.11.3",
    "uuid": "^9.0.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "joi": "^17.9.2",
    "axios": "^1.5.0",
    "winston": "^3.10.0",
    "express-rate-limit": "^6.10.0",
    "express-validator": "^7.0.1",
    "multer": "^1.4.5-lts.1",
    "twilio": "^4.15.0",
    "@anthropic-ai/sdk": "^0.24.3",
    "moment": "^2.29.4",
    "node-cron": "^3.0.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.4",
    "supertest": "^6.3.3",
    "eslint": "^8.47.0",
    "prettier": "^3.0.2"
  },
  "nodemonConfig": {
    "watch": [
      "src/**/*",
      "database/**/*",
      "scripts/**/*",
      "server.js"
    ],
    "ext": "js,json",
    "ignore": [
      "logs/**/*",
      "uploads/**/*",
      "node_modules/**/*"
    ],
    "env": {
      "NODE_ENV": "development"
    }
  },
  "jest": {
    "testEnvironment": "node",
    "setupFilesAfterEnv": ["<rootDir>/tests/setup.js"],
    "testMatch": [
      "**/tests/**/*.test.js"
    ],
    "collectCoverageFrom": [
      "src/**/*.js",
      "!src/config/*.js"
    ]
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/tu-usuario/chatbot-chingon.git"
  },
  "bugs": {
    "url": "https://github.com/tu-usuario/chatbot-chingon/issues"
  },
  "homepage": "https://github.com/tu-usuario/chatbot-chingon#readme"
}


================================================
File: server.js
================================================
const express = require("express");
const cors = require("cors");
const helmet = require("helmet");
const compression = require("compression");
const cron = require("node-cron");
require("dotenv").config();

// Importar configuración y servicios
const logger = require("./src/utils/logger");
const { errorHandler } = require('./src/middleware/errorHandler');
const rateLimiter = require("./src/middleware/rateLimiter");
const { testDatabaseConnection } = require("./src/config/database");
const {
  cleanupInactiveConversations,
} = require("./src/services/conversationService");

// Importar rutas
const webhookRoutes = require("./src/routes/webhook");
const restaurantRoutes = require("./src/routes/restaurants");
const menuRoutes = require("./src/routes/menu");
const orderRoutes = require("./src/routes/orders");
const dashboardRoutes = require("./src/routes/dashboard");

const app = express();
const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || "localhost";
let server;

// ============================================
// MIDDLEWARE GLOBAL
// ============================================

// Seguridad
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
  })
);

// CORS configurado
app.use(
  cors({
    origin: process.env.FRONTEND_URL ? [process.env.FRONTEND_URL] : true,
    credentials: true,
    optionsSuccessStatus: 200,
  })
);

// Compresión
app.use(compression());

// Rate limiting
app.use("/api/", rateLimiter.apiLimiter);

// Parsing
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

// Logging de requests
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.originalUrl}`, {
    ip: req.ip,
    userAgent: req.get("User-Agent"),
    timestamp: new Date().toISOString(),
  });
  next();
});

// ============================================
// RUTAS
// ============================================

// Health check
app.get("/health", (req, res) => {
  res.status(200).json({
    status: "ok",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    version: require("./package.json").version,
  });
});

// Webhook de WhatsApp (sin rate limit para no bloquear mensajes)
app.use("/webhook", webhookRoutes);

// API Routes (con rate limit)
app.use("/api/restaurants", restaurantRoutes);
app.use("/api/menu", menuRoutes);
app.use("/api/orders", orderRoutes);
app.use("/api/dashboard", dashboardRoutes);
app.use('/api/auth', require('./src/routes/auth'));

// Ruta de prueba
app.get("/", (req, res) => {
  res.json({
    message: "ChatBot Chingón API v1.0",
    status: "running",
    docs: "/api/docs",
    health: "/health",
  });
});

// ============================================
// MANEJO DE ERRORES
// ============================================

// 404 Handler
app.use("*", (req, res) => {
  logger.warn(`404 - Route not found: ${req.method} ${req.originalUrl}`);
  res.status(404).json({
    success: false,
    message: "Ruta no encontrada",
    path: req.originalUrl,
  });
});

// Global error handler
app.use(errorHandler);

// ============================================
// TAREAS PROGRAMADAS
// ============================================

// Limpiar conversaciones inactivas cada hora
cron.schedule("0 * * * *", async () => {
  try {
    logger.info("Ejecutando limpieza de conversaciones inactivas...");
    const cleanedCount = await cleanupInactiveConversations();
    logger.info(
      `Limpieza completada: ${cleanedCount} conversaciones marcadas como abandonadas`
    );
  } catch (error) {
    logger.error("Error en limpieza de conversaciones:", error);
  }
});

// ============================================
// MANEJO DE SEÑALES DEL SISTEMA
// ============================================

// Graceful shutdown
const gracefulShutdown = (signal) => {
  logger.info(`Recibida señal ${signal}. Cerrando servidor...`);

  if (server) {
    server.close(() => {
      logger.info("Servidor HTTP cerrado.");

      // Cerrar conexiones de base de datos
      const { pool } = require("./src/config/database");
      pool.end(() => {
        logger.info("Pool de base de datos cerrado.");
        process.exit(0);
      });
    });
  } else {
    logger.info("Servidor no iniciado, cerrando proceso...");
    process.exit(0);
  }

  server.close(() => {
    logger.info("Servidor HTTP cerrado.");

    // Cerrar conexiones de base de datos
    const { pool } = require("./src/config/database");
    pool.end(() => {
      logger.info("Pool de base de datos cerrado.");
      process.exit(0);
    });
  });

  // Forzar cierre después de 10 segundos
  setTimeout(() => {
    logger.error("Forzando cierre del servidor...");
    process.exit(1);
  }, 10000);
};

process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));

// Manejo de errores no capturados
process.on("uncaughtException", (error) => {
  logger.error("Excepción no capturada:", error);
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  logger.error("Promise rechazada no manejada:", { reason, promise });
  process.exit(1);
});

// ============================================
// INICIALIZACIÓN DEL SERVIDOR
// ============================================

const startServer = async () => {
  try {
    // Verificar conexión a base de datos
    logger.info("Verificando conexión a base de datos...");
    await testDatabaseConnection();
    logger.info("✅ Conexión a base de datos exitosa");

    // Iniciar servidor y asignar a la variable global
    server = app.listen(PORT, HOST, () => {
      logger.info(`🚀 Servidor ChatBot Chingón iniciado`);
      logger.info(`📍 URL: http://${HOST}:${PORT}`);
      logger.info(`🌍 Entorno: ${process.env.NODE_ENV}`);
      logger.info(`📋 Health Check: http://${HOST}:${PORT}/health`);

      if (process.env.NODE_ENV === "development") {
        logger.info(
          `🔗 Frontend: ${process.env.FRONTEND_URL || "No configurado"}`
        );
        logger.info(`📞 WhatsApp Webhook: http://${HOST}:${PORT}/webhook`);
      }
    });

    // Configurar timeout del servidor
    server.timeout = 30000; // 30 segundos

    return server;
  } catch (error) {
    logger.error("❌ Error al iniciar el servidor:", error);
    process.exit(1);
  }
};

// Exportar para tests
if (require.main === module) {
  // Solo ejecutar si es llamado directamente
  startServer();
} else {
  // Para tests
  module.exports = app;
}



================================================
File: test-db.js
================================================
require('dotenv').config();
const { testConnection, query } = require('./database/connection');

const testNeonConnection = async () => {
  try {
    console.log('🔄 Probando conexión a Neon...');
    await testConnection();
    
    console.log('🔄 Verificando tablas...');
    const result = await query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
      ORDER BY table_name
    `);
    
    console.log('📋 Tablas encontradas:');
    result.rows.forEach(row => console.log(`  - ${row.table_name}`));
    
    console.log('✅ ¡Todo funciona correctamente!');
    process.exit(0);
    
  } catch (error) {
    console.error('❌ Error:', error.message);
    process.exit(1);
  }
};

testNeonConnection();


================================================
File: database/connection.js
================================================
const { Pool } = require('pg');
const logger = require('../src/utils/logger');

// ============================================
// CONFIGURACIÓN DE CONEXIÓN A POSTGRESQL
// ============================================

// Configuración del pool de conexiones
// En database/connection.js, actualiza la configuración del pool:

const poolConfig = {
  user: process.env.DB_USER || 'neondb_owner',
  host: process.env.DB_HOST || 'ep-dawn-waterfall-aeee70v1-pooler.c-2.us-east-2.aws.neon.tech',
  database: process.env.DB_NAME || 'neondb',
  password: process.env.DB_PASSWORD || 'npg_YkBK7W2MvSaQ',
  port: parseInt(process.env.DB_PORT) || 5432,
  
  // Configuración específica para Neon
  ssl: {
    require: true,
    rejectUnauthorized: false
  },
  
  // Pool optimizado para Neon
  max: parseInt(process.env.DB_POOL_MAX) || 5,
  min: parseInt(process.env.DB_POOL_MIN) || 1,
  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,
  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 5000,
  query_timeout: parseInt(process.env.DB_QUERY_TIMEOUT) || 60000,
  
  // Configuraciones específicas para Neon
  application_name: 'ChatBot_Chingon',
  statement_timeout: 60000,
  idle_in_transaction_session_timeout: 60000
};
// Crear el pool de conexiones
const pool = new Pool(poolConfig);

// ============================================
// EVENTOS DEL POOL
// ============================================

pool.on('connect', (client) => {
  logger.debug('Nueva conexión a PostgreSQL establecida', {
    processId: client.processID,
    database: poolConfig.database
  });
});

pool.on('acquire', (client) => {
  logger.debug('Conexión adquirida del pool', {
    processId: client.processID,
    poolSize: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount
  });
});

pool.on('remove', (client) => {
  logger.debug('Conexión removida del pool', {
    processId: client.processID,
    poolSize: pool.totalCount
  });
});

pool.on('error', (err, client) => {
  logger.error('Error inesperado en cliente del pool:', {
    error: err.message,
    processId: client?.processID,
    poolSize: pool.totalCount
  });
});

// ============================================
// FUNCIÓN PRINCIPAL DE CONSULTA
// ============================================

/**
 * Ejecuta una consulta SQL con logging y manejo de errores
 * @param {string} text - Query SQL
 * @param {Array} params - Parámetros de la consulta
 * @param {string} operationName - Nombre de la operación para logging
 * @returns {Promise<Object>} Resultado de la consulta
 */
const query = async (text, params = [], operationName = 'unknown') => {
  const start = Date.now();
  const client = await pool.connect();
  
  try {
    // Log de debug para desarrollo
    if (process.env.NODE_ENV === 'development' && process.env.LOG_SQL === 'true') {
      logger.debug('Ejecutando consulta SQL', {
        operation: operationName,
        query: text.replace(/\s+/g, ' ').trim(),
        params: params.length > 0 ? params : 'sin parámetros'
      });
    }

    const result = await client.query(text, params);
    const duration = Date.now() - start;

    // Log de métricas de rendimiento
    logger.logDatabase('info', operationName, duration, result.rowCount, {
      affectedRows: result.rowCount,
      command: result.command
    });

    // Alertar sobre consultas lentas
    if (duration > 5000) { // 5 segundos
      logger.warn('Consulta lenta detectada', {
        operation: operationName,
        duration: `${duration}ms`,
        rowCount: result.rowCount
      });
    }

    return result;

  } catch (error) {
    const duration = Date.now() - start;
    
    // Log detallado del error
    logger.logDatabase('error', operationName, duration, 0, {
      error: error.message,
      code: error.code,
      detail: error.detail,
      hint: error.hint,
      position: error.position,
      query: text.replace(/\s+/g, ' ').trim().substring(0, 200),
      params: params.length > 0 ? JSON.stringify(params).substring(0, 200) : null
    });

    // Re-lanzar el error para que sea manejado por los controladores
    throw error;

  } finally {
    client.release();
  }
};

// ============================================
// FUNCIÓN DE TRANSACCIÓN
// ============================================

/**
 * Ejecuta múltiples consultas en una transacción
 * @param {Function} callback - Función que contiene las operaciones de la transacción
 * @returns {Promise<any>} Resultado de la transacción
 */
const transaction = async (callback) => {
  const client = await pool.connect();
  const start = Date.now();
  
  try {
    await client.query('BEGIN');
    logger.debug('Transacción iniciada');

    const result = await callback(client);
    
    await client.query('COMMIT');
    const duration = Date.now() - start;
    
    logger.info('Transacción completada exitosamente', {
      duration: `${duration}ms`
    });

    return result;

  } catch (error) {
    await client.query('ROLLBACK');
    const duration = Date.now() - start;
    
    logger.error('Transacción revertida debido a error', {
      error: error.message,
      duration: `${duration}ms`,
      code: error.code
    });

    throw error;

  } finally {
    client.release();
  }
};

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Verifica la conexión a la base de datos
 * @returns {Promise<boolean>} True si la conexión es exitosa
 */
const testConnection = async () => {
  try {
    const result = await query(
      'SELECT NOW() as current_time, version() as version', 
      [], 
      'test_connection'
    );
    
    logger.info('Conexión a base de datos verificada', {
      timestamp: result.rows[0].current_time,
      version: result.rows[0].version.split(' ')[0] + ' ' + result.rows[0].version.split(' ')[1]
    });
    
    return true;
    
  } catch (error) {
    logger.error('Error al probar conexión a base de datos:', error);
    throw error;
  }
};

/**
 * Verifica si existe una tabla
 * @param {string} tableName - Nombre de la tabla
 * @returns {Promise<boolean>} True si la tabla existe
 */
const tableExists = async (tableName) => {
  try {
    const result = await query(
      `SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )`,
      [tableName],
      `check_table_exists_${tableName}`
    );
    
    return result.rows[0].exists;
    
  } catch (error) {
    logger.error(`Error al verificar existencia de tabla ${tableName}:`, error);
    return false;
  }
};

/**
 * Ejecuta migraciones desde archivo SQL
 * @param {string} migrationPath - Ruta del archivo de migración
 * @returns {Promise<void>}
 */
const runMigration = async (migrationPath) => {
  const fs = require('fs');
  const path = require('path');
  
  try {
    if (!fs.existsSync(migrationPath)) {
      throw new Error(`Archivo de migración no encontrado: ${migrationPath}`);
    }
    
    const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
    
    await transaction(async (client) => {
      logger.info('Ejecutando migración:', migrationPath);
      
      // Dividir el SQL en statements individuales (simplificado)
      const statements = migrationSQL.split(';').filter(stmt => stmt.trim());
      
      for (const statement of statements) {
        if (statement.trim()) {
          await client.query(statement.trim());
        }
      }
      
      logger.info('✅ Migración ejecutada exitosamente');
    });
    
  } catch (error) {
    logger.error('❌ Error al ejecutar migración:', error);
    throw error;
  }
};

/**
 * Limpia conexiones inactivas y resetea el pool si es necesario
 * @returns {Promise<void>}
 */
const cleanupConnections = async () => {
  try {
    logger.info('Limpiando conexiones inactivas', {
      totalConnections: pool.totalCount,
      idleConnections: pool.idleCount,
      waitingClients: pool.waitingCount
    });

    // PostgreSQL automáticamente maneja las conexiones idle
    // Solo loggeamos el estado actual
    
    if (pool.waitingCount > 0) {
      logger.warn('Clientes esperando conexiones disponibles', {
        waitingCount: pool.waitingCount
      });
    }

  } catch (error) {
    logger.error('Error durante limpieza de conexiones:', error);
  }
};

/**
 * Obtiene estadísticas del pool de conexiones
 * @returns {Object} Estadísticas del pool
 */
const getPoolStats = () => {
  return {
    totalCount: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount,
    maxConnections: poolConfig.max,
    minConnections: poolConfig.min,
    database: poolConfig.database,
    host: poolConfig.host,
    port: poolConfig.port
  };
};

/**
 * Ejecuta una consulta preparada con cache
 * @param {string} name - Nombre único para la consulta preparada
 * @param {string} text - Query SQL
 * @param {Array} params - Parámetros
 * @returns {Promise<Object>} Resultado de la consulta
 */
const preparedQuery = async (name, text, params = []) => {
  const start = Date.now();
  const client = await pool.connect();
  
  try {
    // Preparar la consulta si no existe
    const result = await client.query({
      name: name,
      text: text,
      values: params
    });

    const duration = Date.now() - start;
    
    logger.logDatabase('info', `prepared_${name}`, duration, result.rowCount, {
      cached: true,
      affectedRows: result.rowCount
    });

    return result;

  } catch (error) {
    const duration = Date.now() - start;
    
    logger.logDatabase('error', `prepared_${name}`, duration, 0, {
      error: error.message,
      code: error.code
    });

    throw error;

  } finally {
    client.release();
  }
};

/**
 * Cierra todas las conexiones del pool de manera elegante
 * @returns {Promise<void>}
 */
const closePool = async () => {
  try {
    logger.info('Cerrando pool de conexiones...');
    await pool.end();
    logger.info('Pool de conexiones cerrado exitosamente');
  } catch (error) {
    logger.error('Error al cerrar pool de conexiones:', error);
    throw error;
  }
};

// ============================================
// MANEJO DE EVENTOS DE CIERRE
// ============================================

process.on('SIGINT', async () => {
  logger.info('Señal SIGINT recibida, cerrando pool de conexiones...');
  await closePool();
});

process.on('SIGTERM', async () => {
  logger.info('Señal SIGTERM recibida, cerrando pool de conexiones...');
  await closePool();
});

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Funciones principales
  query,
  transaction,
  
  // Utilidades
  testConnection,
  tableExists,
  runMigration,
  cleanupConnections,
  getPoolStats,
  preparedQuery,
  closePool,
  
  // Pool para acceso directo si es necesario
  pool
};


================================================
File: database/dump.db
================================================
-- ============================================
-- BASE DE DATOS: CHATBOT RESTAURANTES
-- Arquitectura Multi-tenant Optimizada
-- ============================================

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- Para búsquedas de texto

-- ============================================
-- TABLA: RESTAURANTES (TENANTS)
-- ============================================
CREATE TABLE restaurants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL, -- hot-wings, minguela
    phone VARCHAR(20) UNIQUE NOT NULL, -- +525512345678
    email VARCHAR(255),
    address TEXT,
    logo_url VARCHAR(500),
    
    -- Configuración de operación
    is_active BOOLEAN DEFAULT true,
    opens_at TIME DEFAULT '09:00:00',
    closes_at TIME DEFAULT '23:00:00',
    delivery_time_min INTEGER DEFAULT 25, -- minutos mínimos
    delivery_time_max INTEGER DEFAULT 35, -- minutos máximos
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    minimum_order DECIMAL(8,2) DEFAULT 0.00,
    
    -- WhatsApp API Config
    whatsapp_phone_id VARCHAR(100), -- Para Meta WhatsApp API
    whatsapp_token VARCHAR(500),
    twilio_phone_number VARCHAR(20), -- Para Twilio
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Índices
    CONSTRAINT restaurants_slug_format CHECK (slug ~ '^[a-z0-9-]+$')
);

-- ============================================
-- TABLA: ZONAS DE ENTREGA
-- ============================================
CREATE TABLE delivery_zones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    zone_name VARCHAR(100) NOT NULL, -- "Centro", "Zona Norte"
    postal_codes TEXT[], -- Array de códigos postales
    neighborhoods TEXT[], -- Array de colonias
    extra_fee DECIMAL(8,2) DEFAULT 0.00, -- Costo extra por zona
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CATEGORÍAS DE MENÚ
-- ============================================
CREATE TABLE menu_categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- "Alitas", "Bebidas", "Hotdogs"
    description TEXT,
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    emoji VARCHAR(10), -- 🍗, 🍺, 🌭
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(restaurant_id, name)
);

-- ============================================
-- TABLA: PRODUCTOS DEL MENÚ
-- ============================================
CREATE TABLE menu_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES menu_categories(id) ON DELETE CASCADE,
    
    -- Información básica
    name VARCHAR(255) NOT NULL, -- "Media orden de alitas"
    description TEXT, -- "6 piezas de alitas jugosas"
    price DECIMAL(8,2) NOT NULL,
    
    -- Configuración de producto
    is_available BOOLEAN DEFAULT true,
    preparation_time INTEGER DEFAULT 15, -- minutos
    display_order INTEGER DEFAULT 0,
    
    -- Información nutricional (opcional)
    calories INTEGER,
    ingredients TEXT[],
    allergens TEXT[], -- "lacteos", "gluten"
    
    -- Imagen
    image_url VARCHAR(500),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: REGLAS DE NEGOCIO
-- ============================================
CREATE TABLE business_rules (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    menu_item_id UUID REFERENCES menu_items(id) ON DELETE CASCADE, -- NULL = regla global
    
    -- Tipo de regla
    rule_type VARCHAR(50) NOT NULL, -- "sauce_limit", "extra_cost", "combo_rule", "size_option"
    rule_name VARCHAR(100) NOT NULL, -- "Aderezos incluidos"
    
    -- Configuración de la regla (JSON flexible)
    rule_config JSONB NOT NULL,
    /* Ejemplos:
    sauce_limit: {"max_included": 1, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri"]}
    size_option: {"sizes": [{"name": "Chica", "price": 60}, {"name": "Grande", "price": 90}]}
    combo_rule: {"required_items": 2, "discount_percent": 15}
    extra_cost: {"extras": [{"name": "Queso extra", "cost": 15}, {"name": "Tocino", "cost": 20}]}
    */
    
    -- Mensaje para la IA
    ai_message_template TEXT, -- "Este producto incluye {max_included} aderezo(s). Extra ${extra_cost} c/u"
    
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CLIENTES
-- ============================================
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    phone VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(255),
    
    -- Datos para entrega
    default_address TEXT,
    default_references TEXT,
    
    -- Stats
    total_orders INTEGER DEFAULT 0,
    total_spent DECIMAL(10,2) DEFAULT 0.00,
    
    -- Timestamps
    first_order_at TIMESTAMP,
    last_order_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONVERSACIONES ACTIVAS
-- ============================================
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_phone VARCHAR(20) NOT NULL,
    
    -- Estado de la conversación
    status VARCHAR(20) DEFAULT 'active', -- active, completing_order, completed, abandoned
    current_step VARCHAR(50) DEFAULT 'greeting', -- greeting, ordering, address, confirming
    
    -- Datos del pedido en construcción
    order_data JSONB DEFAULT '{}',
    /* Estructura:
    {
        "items": [
            {
                "menu_item_id": "uuid",
                "name": "Media orden alitas BBQ",
                "quantity": 1,
                "base_price": 90,
                "customizations": [
                    {"type": "sauce", "name": "BBQ", "extra_cost": 0},
                    {"type": "sauce", "name": "Chimichurri", "extra_cost": 10}
                ],
                "item_total": 100,
                "notes": "Sin cebolla"
            }
        ],
        "subtotal": 100,
        "delivery_fee": 0,
        "total": 100,
        "delivery_address": {
            "street": "Calle Reforma",
            "number": "123",
            "neighborhood": "Centro",
            "references": "Entre 5 de Mayo y Hidalgo",
            "postal_code": "12345"
        }
    }
    */
    
    -- Contexto para Claude
    ai_context JSONB DEFAULT '[]', -- Historial de mensajes
    conversation_summary TEXT, -- Resumen generado por IA
    
    -- Timestamps
    last_interaction_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraint para evitar conversaciones duplicadas activas
    UNIQUE(restaurant_id, customer_phone, status) 
    DEFERRABLE INITIALLY DEFERRED -- Para permitir updates de status
);

-- ============================================
-- TABLA: PEDIDOS COMPLETADOS
-- ============================================
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_id UUID REFERENCES customers(id),
    conversation_id UUID REFERENCES conversations(id),
    
    -- Información del cliente
    customer_phone VARCHAR(20) NOT NULL,
    customer_name VARCHAR(255),
    
    -- Dirección de entrega
    delivery_street VARCHAR(255) NOT NULL,
    delivery_number VARCHAR(50) NOT NULL,
    delivery_neighborhood VARCHAR(255) NOT NULL,
    delivery_references TEXT,
    delivery_postal_code VARCHAR(10),
    
    -- Estado del pedido
    status VARCHAR(20) DEFAULT 'confirmed', -- confirmed, preparing, ready, delivered, cancelled
    
    -- Montos
    subtotal DECIMAL(8,2) NOT NULL,
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    total DECIMAL(8,2) NOT NULL,
    
    -- Tiempos
    estimated_delivery_time INTEGER, -- minutos
    confirmed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    delivered_at TIMESTAMP,
    
    -- Notas
    special_instructions TEXT,
    internal_notes TEXT, -- Para el restaurante
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: ITEMS DE PEDIDOS
-- ============================================
CREATE TABLE order_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    menu_item_id UUID NOT NULL REFERENCES menu_items(id),
    
    -- Información del producto al momento del pedido
    item_name VARCHAR(255) NOT NULL, -- Snapshot del nombre
    base_price DECIMAL(8,2) NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    
    -- Personalizaciones
    customizations JSONB DEFAULT '[]',
    /* Ejemplo:
    [
        {"type": "sauce", "name": "BBQ", "extra_cost": 0},
        {"type": "sauce", "name": "Chimichurri", "extra_cost": 10},
        {"type": "extra", "name": "Queso extra", "extra_cost": 15}
    ]
    */
    
    customizations_cost DECIMAL(8,2) DEFAULT 0.00,
    item_total DECIMAL(8,2) NOT NULL, -- (base_price + customizations_cost) * quantity
    
    special_notes TEXT, -- "Sin cebolla", "Bien cocidas"
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONFIGURACIONES DEL RESTAURANTE
-- ============================================
CREATE TABLE restaurant_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID UNIQUE NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    
    -- Configuración de Claude
    claude_api_key VARCHAR(500),
    claude_model VARCHAR(50) DEFAULT 'claude-3-5-sonnet-20241022',
    ai_personality TEXT DEFAULT 'Amigable y servicial',
    
    -- Mensajes predefinidos
    welcome_message TEXT DEFAULT '¡Hola! Bienvenido a nuestro restaurante 🍴',
    goodbye_message TEXT DEFAULT '¡Gracias por tu pedido! Te esperamos pronto 😊',
    error_message TEXT DEFAULT 'Lo siento, tuve un problema. ¿Puedes repetir tu mensaje?',
    
    -- Configuración de negocio
    auto_confirm_orders BOOLEAN DEFAULT false,
    require_phone_validation BOOLEAN DEFAULT false,
    max_conversation_time INTEGER DEFAULT 1800, -- 30 minutos
    
    -- Notificaciones
    notification_email VARCHAR(255),
    notification_phone VARCHAR(20),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- ÍNDICES PARA OPTIMIZACIÓN
-- ============================================

-- Índices principales para queries frecuentes
CREATE INDEX idx_restaurants_slug ON restaurants(slug);
CREATE INDEX idx_restaurants_phone ON restaurants(phone);
CREATE INDEX idx_restaurants_active ON restaurants(is_active) WHERE is_active = true;

CREATE INDEX idx_menu_items_restaurant ON menu_items(restaurant_id, is_available) WHERE is_available = true;
CREATE INDEX idx_menu_items_category ON menu_items(category_id, display_order);

CREATE INDEX idx_business_rules_item ON business_rules(menu_item_id, rule_type) WHERE is_active = true;
CREATE INDEX idx_business_rules_restaurant ON business_rules(restaurant_id, rule_type) WHERE is_active = true;

CREATE INDEX idx_conversations_active ON conversations(restaurant_id, customer_phone, status) WHERE status = 'active';
CREATE INDEX idx_conversations_last_interaction ON conversations(last_interaction_at) WHERE status = 'active';

CREATE INDEX idx_orders_restaurant_status ON orders(restaurant_id, status, created_at);
CREATE INDEX idx_orders_customer ON orders(customer_phone, created_at);
CREATE INDEX idx_orders_date ON orders(created_at);

CREATE INDEX idx_order_items_order ON order_items(order_id);

-- Índices para búsquedas de texto
CREATE INDEX idx_menu_items_name_trgm ON menu_items USING gin(name gin_trgm_ops);
CREATE INDEX idx_customers_phone ON customers(phone);

-- ============================================
-- TRIGGERS PARA UPDATED_AT
-- ============================================

-- Función para actualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers
CREATE TRIGGER update_restaurants_updated_at BEFORE UPDATE ON restaurants FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_menu_items_updated_at BEFORE UPDATE ON menu_items FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_restaurant_settings_updated_at BEFORE UPDATE ON restaurant_settings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- FUNCIÓN: LIMPIAR CONVERSACIONES INACTIVAS
-- ============================================
CREATE OR REPLACE FUNCTION clean_inactive_conversations()
RETURNS INTEGER AS $$
DECLARE
    cleaned_count INTEGER;
BEGIN
    -- Marcar como abandonadas las conversaciones inactivas por más de 2 horas
    UPDATE conversations 
    SET status = 'abandoned'
    WHERE status = 'active' 
    AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '2 hours';
    
    GET DIAGNOSTICS cleaned_count = ROW_COUNT;
    RETURN cleaned_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- COMENTARIOS DE DOCUMENTACIÓN
-- ============================================

COMMENT ON TABLE restaurants IS 'Información de cada restaurante/tenant del sistema';
COMMENT ON TABLE menu_items IS 'Productos del menú por restaurante';
COMMENT ON TABLE business_rules IS 'Reglas de negocio específicas (aderezos, extras, combos)';
COMMENT ON TABLE conversations IS 'Sesiones de chat activas con estado del pedido';
COMMENT ON TABLE orders IS 'Pedidos completados';
COMMENT ON TABLE order_items IS 'Items específicos de cada pedido con customizaciones';

COMMENT ON COLUMN business_rules.rule_config IS 'Configuración JSON flexible para diferentes tipos de reglas';
COMMENT ON COLUMN conversations.order_data IS 'Estado actual del pedido en construcción (JSON)';
COMMENT ON COLUMN conversations.ai_context IS 'Historial de conversación para Claude';
COMMENT ON COLUMN order_items.customizations IS 'Array JSON de personalizaciones del item';


================================================
File: database/migrations/001_initial_schema.sql
================================================
-- ============================================
-- CHATBOT CHINGÓN - MIGRACIÓN INICIAL
-- Versión: 1.0.0
-- Fecha: 2024-12-19
-- ============================================

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- Para búsquedas de texto

-- ============================================
-- TABLA: RESTAURANTES (TENANTS)
-- ============================================
CREATE TABLE restaurants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL, -- hot-wings, minguela
    phone VARCHAR(20) UNIQUE NOT NULL, -- +525512345678
    email VARCHAR(255),
    address TEXT,
    logo_url VARCHAR(500),
    
    -- Configuración de operación
    is_active BOOLEAN DEFAULT true,
    opens_at TIME DEFAULT '09:00:00',
    closes_at TIME DEFAULT '23:00:00',
    delivery_time_min INTEGER DEFAULT 25, -- minutos mínimos
    delivery_time_max INTEGER DEFAULT 35, -- minutos máximos
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    minimum_order DECIMAL(8,2) DEFAULT 0.00,
    
    -- WhatsApp API Config
    whatsapp_phone_id VARCHAR(100), -- Para Meta WhatsApp API
    whatsapp_token VARCHAR(500),
    twilio_phone_number VARCHAR(20), -- Para Twilio
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CONSTRAINT restaurants_slug_format CHECK (slug ~ '^[a-z0-9-]+$')
);

-- ============================================
-- TABLA: ZONAS DE ENTREGA
-- ============================================
CREATE TABLE delivery_zones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    zone_name VARCHAR(100) NOT NULL, -- "Centro", "Zona Norte"
    postal_codes TEXT[], -- Array de códigos postales
    neighborhoods TEXT[], -- Array de colonias
    extra_fee DECIMAL(8,2) DEFAULT 0.00, -- Costo extra por zona
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CATEGORÍAS DE MENÚ
-- ============================================
CREATE TABLE menu_categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- "Alitas", "Bebidas", "Hotdogs"
    description TEXT,
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    emoji VARCHAR(10), -- 🍗, 🍺, 🌭
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(restaurant_id, name)
);

-- ============================================
-- TABLA: PRODUCTOS DEL MENÚ
-- ============================================
CREATE TABLE menu_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES menu_categories(id) ON DELETE CASCADE,
    
    -- Información básica
    name VARCHAR(255) NOT NULL, -- "Media orden de alitas"
    description TEXT, -- "6 piezas de alitas jugosas"
    price DECIMAL(8,2) NOT NULL,
    
    -- Configuración de producto
    is_available BOOLEAN DEFAULT true,
    preparation_time INTEGER DEFAULT 15, -- minutos
    display_order INTEGER DEFAULT 0,
    
    -- Información nutricional (opcional)
    calories INTEGER,
    ingredients TEXT[],
    allergens TEXT[], -- "lacteos", "gluten"
    
    -- Imagen
    image_url VARCHAR(500),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: REGLAS DE NEGOCIO
-- ============================================
CREATE TABLE business_rules (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    menu_item_id UUID REFERENCES menu_items(id) ON DELETE CASCADE, -- NULL = regla global
    
    -- Tipo de regla
    rule_type VARCHAR(50) NOT NULL, -- "sauce_limit", "extra_cost", "combo_rule", "size_option"
    rule_name VARCHAR(100) NOT NULL, -- "Aderezos incluidos"
    
    -- Configuración de la regla (JSON flexible)
    rule_config JSONB NOT NULL,
    /* Ejemplos:
    sauce_limit: {"max_included": 1, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri"]}
    size_option: {"sizes": [{"name": "Chica", "price": 60}, {"name": "Grande", "price": 90}]}
    combo_rule: {"required_items": 2, "discount_percent": 15}
    extra_cost: {"extras": [{"name": "Queso extra", "cost": 15}, {"name": "Tocino", "cost": 20}]}
    */
    
    -- Mensaje para la IA
    ai_message_template TEXT, -- "Este producto incluye {max_included} aderezo(s). Extra ${extra_cost} c/u"
    
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CLIENTES
-- ============================================
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    phone VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(255),
    
    -- Datos para entrega
    default_address TEXT,
    default_references TEXT,
    
    -- Stats
    total_orders INTEGER DEFAULT 0,
    total_spent DECIMAL(10,2) DEFAULT 0.00,
    
    -- Timestamps
    first_order_at TIMESTAMP,
    last_order_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONVERSACIONES ACTIVAS
-- ============================================
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_phone VARCHAR(20) NOT NULL,
    
    -- Estado de la conversación
    status VARCHAR(20) DEFAULT 'active', -- active, completing_order, completed, abandoned
    current_step VARCHAR(50) DEFAULT 'greeting', -- greeting, ordering, address, confirming
    
    -- Datos del pedido en construcción
    order_data JSONB DEFAULT '{}',
    /* Estructura:
    {
        "items": [
            {
                "menu_item_id": "uuid",
                "name": "Media orden alitas BBQ",
                "quantity": 1,
                "base_price": 90,
                "customizations": [
                    {"type": "sauce", "name": "BBQ", "extra_cost": 0},
                    {"type": "sauce", "name": "Chimichurri", "extra_cost": 10}
                ],
                "item_total": 100,
                "notes": "Sin cebolla"
            }
        ],
        "subtotal": 100,
        "delivery_fee": 0,
        "total": 100,
        "delivery_address": {
            "street": "Calle Reforma",
            "number": "123",
            "neighborhood": "Centro",
            "references": "Entre 5 de Mayo y Hidalgo",
            "postal_code": "12345"
        }
    }
    */
    
    -- Contexto para Claude
    ai_context JSONB DEFAULT '[]', -- Historial de mensajes
    conversation_summary TEXT, -- Resumen generado por IA
    
    -- Timestamps
    last_interaction_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: PEDIDOS COMPLETADOS
-- ============================================
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_id UUID REFERENCES customers(id),
    conversation_id UUID REFERENCES conversations(id),
    
    -- Información del cliente
    customer_phone VARCHAR(20) NOT NULL,
    customer_name VARCHAR(255),
    
    -- Dirección de entrega
    delivery_street VARCHAR(255) NOT NULL,
    delivery_number VARCHAR(50) NOT NULL,
    delivery_neighborhood VARCHAR(255) NOT NULL,
    delivery_references TEXT,
    delivery_postal_code VARCHAR(10),
    
    -- Estado del pedido
    status VARCHAR(20) DEFAULT 'confirmed', -- confirmed, preparing, ready, delivered, cancelled
    
    -- Montos
    subtotal DECIMAL(8,2) NOT NULL,
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    total DECIMAL(8,2) NOT NULL,
    
    -- Tiempos
    estimated_delivery_time INTEGER, -- minutos
    confirmed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    delivered_at TIMESTAMP,
    
    -- Notas
    special_instructions TEXT,
    internal_notes TEXT, -- Para el restaurante
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: ITEMS DE PEDIDOS
-- ============================================
CREATE TABLE order_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    menu_item_id UUID NOT NULL REFERENCES menu_items(id),
    
    -- Información del producto al momento del pedido
    item_name VARCHAR(255) NOT NULL, -- Snapshot del nombre
    base_price DECIMAL(8,2) NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    
    -- Personalizaciones
    customizations JSONB DEFAULT '[]',
    /* Ejemplo:
    [
        {"type": "sauce", "name": "BBQ", "extra_cost": 0},
        {"type": "sauce", "name": "Chimichurri", "extra_cost": 10},
        {"type": "extra", "name": "Queso extra", "extra_cost": 15}
    ]
    */
    
    customizations_cost DECIMAL(8,2) DEFAULT 0.00,
    item_total DECIMAL(8,2) NOT NULL, -- (base_price + customizations_cost) * quantity
    
    special_notes TEXT, -- "Sin cebolla", "Bien cocidas"
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONFIGURACIONES DEL RESTAURANTE
-- ============================================
CREATE TABLE restaurant_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID UNIQUE NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    
    -- Configuración de Claude
    claude_api_key VARCHAR(500),
    claude_model VARCHAR(50) DEFAULT 'claude-3-5-sonnet-20241022',
    ai_personality TEXT DEFAULT 'Amigable y servicial',
    
    -- Mensajes predefinidos
    welcome_message TEXT DEFAULT '¡Hola! Bienvenido a nuestro restaurante 🍴',
    goodbye_message TEXT DEFAULT '¡Gracias por tu pedido! Te esperamos pronto 😊',
    error_message TEXT DEFAULT 'Lo siento, tuve un problema. ¿Puedes repetir tu mensaje?',
    
    -- Configuración de negocio
    auto_confirm_orders BOOLEAN DEFAULT false,
    require_phone_validation BOOLEAN DEFAULT false,
    max_conversation_time INTEGER DEFAULT 1800, -- 30 minutos
    
    -- Notificaciones
    notification_email VARCHAR(255),
    notification_phone VARCHAR(20),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- ÍNDICES PARA OPTIMIZACIÓN
-- ============================================

-- Índices principales para queries frecuentes
CREATE INDEX idx_restaurants_slug ON restaurants(slug);
CREATE INDEX idx_restaurants_phone ON restaurants(phone);
CREATE INDEX idx_restaurants_active ON restaurants(is_active) WHERE is_active = true;

CREATE INDEX idx_menu_items_restaurant ON menu_items(restaurant_id, is_available) WHERE is_available = true;
CREATE INDEX idx_menu_items_category ON menu_items(category_id, display_order);

CREATE INDEX idx_business_rules_item ON business_rules(menu_item_id, rule_type) WHERE is_active = true;
CREATE INDEX idx_business_rules_restaurant ON business_rules(restaurant_id, rule_type) WHERE is_active = true;

CREATE INDEX idx_conversations_active ON conversations(restaurant_id, customer_phone, status) WHERE status = 'active';
CREATE INDEX idx_conversations_last_interaction ON conversations(last_interaction_at) WHERE status = 'active';

CREATE INDEX idx_orders_restaurant_status ON orders(restaurant_id, status, created_at);
CREATE INDEX idx_orders_customer ON orders(customer_phone, created_at);
CREATE INDEX idx_orders_date ON orders(created_at);

CREATE INDEX idx_order_items_order ON order_items(order_id);

-- Índices para búsquedas de texto
CREATE INDEX idx_menu_items_name_trgm ON menu_items USING gin(name gin_trgm_ops);
CREATE INDEX idx_customers_phone ON customers(phone);

-- ============================================
-- TRIGGERS PARA UPDATED_AT
-- ============================================

-- Función para actualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers
CREATE TRIGGER update_restaurants_updated_at BEFORE UPDATE ON restaurants FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_menu_items_updated_at BEFORE UPDATE ON menu_items FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_restaurant_settings_updated_at BEFORE UPDATE ON restaurant_settings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- FUNCIÓN: LIMPIAR CONVERSACIONES INACTIVAS
-- ============================================
CREATE OR REPLACE FUNCTION clean_inactive_conversations()
RETURNS INTEGER AS $$
DECLARE
    cleaned_count INTEGER;
BEGIN
    -- Marcar como abandonadas las conversaciones inactivas por más de 2 horas
    UPDATE conversations 
    SET status = 'abandoned'
    WHERE status = 'active' 
    AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '2 hours';
    
    GET DIAGNOSTICS cleaned_count = ROW_COUNT;
    RETURN cleaned_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- COMENTARIOS DE DOCUMENTACIÓN
-- ============================================

COMMENT ON TABLE restaurants IS 'Información de cada restaurante/tenant del sistema';
COMMENT ON TABLE menu_items IS 'Productos del menú por restaurante';
COMMENT ON TABLE business_rules IS 'Reglas de negocio específicas (aderezos, extras, combos)';
COMMENT ON TABLE conversations IS 'Sesiones de chat activas con estado del pedido';
COMMENT ON TABLE orders IS 'Pedidos completados';
COMMENT ON TABLE order_items IS 'Items específicos de cada pedido con customizaciones';

COMMENT ON COLUMN business_rules.rule_config IS 'Configuración JSON flexible para diferentes tipos de reglas';
COMMENT ON COLUMN conversations.order_data IS 'Estado actual del pedido en construcción (JSON)';
COMMENT ON COLUMN conversations.ai_context IS 'Historial de conversación para Claude';
COMMENT ON COLUMN order_items.customizations IS 'Array JSON de personalizaciones del item';

-- ============================================
-- DATOS DE EJEMPLO PARA DESARROLLO
-- ============================================

-- Insertar restaurante de ejemplo
INSERT INTO restaurants (
    id, name, slug, phone, email, address,
    opens_at, closes_at, delivery_time_min, delivery_time_max
) VALUES (
    '550e8400-e29b-41d4-a716-446655440000',
    'Hot Wings Express',
    'hot-wings-express',
    '+525512345678',
    'info@hotwings.com',
    'Av. Insurgentes Sur 123, Col. Roma Norte, CDMX',
    '10:00:00',
    '23:00:00',
    25,
    35
);

-- Insertar configuración del restaurante de ejemplo
INSERT INTO restaurant_settings (
    id, restaurant_id, ai_personality, welcome_message, goodbye_message
) VALUES (
    '660e8400-e29b-41d4-a716-446655440000',
    '550e8400-e29b-41d4-a716-446655440000',
    'Amigable, rápido y conocedor de alitas',
    '¡Hola! 👋 Bienvenido a Hot Wings Express. ¿Listo para unas alitas deliciosas?',
    '¡Gracias por tu pedido! 🍗 Tu comida llegará pronto. ¡Disfrútala!'
);

-- Insertar categorías de ejemplo
INSERT INTO menu_categories (
    id, restaurant_id, name, description, display_order, emoji
) VALUES 
    ('770e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440000', 'Alitas', 'Nuestras deliciosas alitas en diferentes sabores', 1, '🍗'),
    ('770e8400-e29b-41d4-a716-446655440001', '550e8400-e29b-41d4-a716-446655440000', 'Bebidas', 'Refrescantes bebidas para acompañar', 2, '🥤'),
    ('770e8400-e29b-41d4-a716-446655440002', '550e8400-e29b-41d4-a716-446655440000', 'Hotdogs', 'Hotdogs gourmet', 3, '🌭');

-- Insertar items de menú de ejemplo
INSERT INTO menu_items (
    id, restaurant_id, category_id, name, description, price, preparation_time
) VALUES 
    ('880e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440000', 'Media Orden de Alitas', '6 piezas de alitas jugosas', 85.00, 15),
    ('880e8400-e29b-41d4-a716-446655440001', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440000', 'Orden Completa de Alitas', '12 piezas de alitas jugosas', 130.00, 18),
    ('880e8400-e29b-41d4-a716-446655440002', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440001', 'Refresco Grande', 'Coca Cola, Sprite o Fanta', 25.00, 2),
    ('880e8400-e29b-41d4-a716-446655440003', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440002', 'Hotdog Clásico', 'Con mostaza, catsup y mayonesa', 45.00, 8);

-- Insertar reglas de negocio de ejemplo
INSERT INTO business_rules (
    id, restaurant_id, menu_item_id, rule_type, rule_name, rule_config, ai_message_template
) VALUES 
    ('990e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440000', '880e8400-e29b-41d4-a716-446655440000', 'sauce_limit', 'Aderezos Media Orden', '{"max_included": 1, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri", "Mango Habanero"]}', 'La media orden incluye 1 aderezo gratis. Aderezos extra $10 c/u'),
    ('990e8400-e29b-41d4-a716-446655440001', '550e8400-e29b-41d4-a716-446655440000', '880e8400-e29b-41d4-a716-446655440001', 'sauce_limit', 'Aderezos Orden Completa', '{"max_included": 2, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri", "Mango Habanero"]}', 'La orden completa incluye 2 aderezos gratis. Aderezos extra $10 c/u');

-- ============================================
-- VERIFICACIÓN DE INSTALACIÓN
-- ============================================

-- Función para verificar que todo se instaló correctamente
CREATE OR REPLACE FUNCTION verify_installation()
RETURNS TEXT AS $$
DECLARE
    table_count INTEGER;
    index_count INTEGER;
    function_count INTEGER;
BEGIN
    -- Contar tablas creadas
    SELECT COUNT(*) INTO table_count
    FROM information_schema.tables 
    WHERE table_schema = 'public' 
    AND table_name IN ('restaurants', 'delivery_zones', 'menu_categories', 'menu_items', 'business_rules', 'customers', 'conversations', 'orders', 'order_items', 'restaurant_settings');
    
    -- Contar índices creados
    SELECT COUNT(*) INTO index_count
    FROM pg_indexes 
    WHERE schemaname = 'public'
    AND indexname LIKE 'idx_%';
    
    -- Contar funciones creadas
    SELECT COUNT(*) INTO function_count
    FROM information_schema.routines
    WHERE routine_schema = 'public'
    AND routine_name IN ('update_updated_at_column', 'clean_inactive_conversations', 'verify_installation');
    
    RETURN FORMAT('✅ Instalación completada: %s tablas, %s índices, %s funciones creadas', table_count, index_count, function_count);
END;
$$ LANGUAGE plpgsql;

-- Ejecutar verificación
SELECT verify_installation();


================================================
File: database/migrations/002_users_and_roles.sql
================================================
-- ============================================
-- MIGRACIÓN: SISTEMA DE USUARIOS Y ROLES
-- Archivo: database/migrations/002_users_and_roles.sql
-- ============================================

-- Extensión para UUID si no existe
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- TABLA: ROLES
-- ============================================
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) UNIQUE NOT NULL, -- 'super_admin', 'admin', 'manager', 'staff'
    display_name VARCHAR(100) NOT NULL, -- 'Super Administrador', 'Administrador', etc.
    description TEXT,
    permissions JSONB DEFAULT '[]', -- Array de permisos específicos
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: USUARIOS
-- ============================================
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    
    -- Relaciones
    role_id UUID NOT NULL REFERENCES roles(id),
    restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE, -- NULL para super_admin
    
    -- Estado del usuario
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    last_login_at TIMESTAMP,
    
    -- Tokens y seguridad
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,
    email_verification_token VARCHAR(255),
    
    -- Metadatos
    created_by UUID REFERENCES users(id), -- Quien creó este usuario
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: PERFILES DE USUARIO
-- ============================================
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Información personal
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(20),
    avatar_url VARCHAR(500),
    
    -- Configuraciones
    language VARCHAR(5) DEFAULT 'es',
    timezone VARCHAR(50) DEFAULT 'America/Mexico_City',
    notifications_enabled BOOLEAN DEFAULT true,
    
    -- Metadatos
    last_profile_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: SESIONES DE USUARIO (Opcional - para tracking)
-- ============================================
CREATE TABLE user_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Información de sesión
    token_id VARCHAR(255) NOT NULL, -- ID del JWT token
    ip_address INET,
    user_agent TEXT,
    
    -- Estado
    is_active BOOLEAN DEFAULT true,
    expires_at TIMESTAMP NOT NULL,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- ÍNDICES PARA OPTIMIZACIÓN
-- ============================================

-- Usuarios
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role_id);
CREATE INDEX idx_users_restaurant ON users(restaurant_id) WHERE restaurant_id IS NOT NULL;
CREATE INDEX idx_users_active ON users(is_active) WHERE is_active = true;

-- Perfiles
CREATE INDEX idx_profiles_user ON user_profiles(user_id);
CREATE INDEX idx_profiles_names ON user_profiles(first_name, last_name);

-- Sesiones
CREATE INDEX idx_sessions_user ON user_sessions(user_id);
CREATE INDEX idx_sessions_token ON user_sessions(token_id);
CREATE INDEX idx_sessions_active ON user_sessions(is_active, expires_at) WHERE is_active = true;

-- ============================================
-- TRIGGERS PARA UPDATED_AT
-- ============================================

CREATE TRIGGER update_roles_updated_at
    BEFORE UPDATE ON roles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_profiles_updated_at
    BEFORE UPDATE ON user_profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- INSERTAR ROLES PREDETERMINADOS
-- ============================================

INSERT INTO roles (id, name, display_name, description, permissions) VALUES
(
    '11111111-1111-1111-1111-111111111111',
    'super_admin',
    'Super Administrador',
    'Acceso completo al sistema. Puede gestionar todos los restaurantes y usuarios.',
    '["all"]'
),
(
    '22222222-2222-2222-2222-222222222222',
    'admin',
    'Administrador de Restaurante',
    'Administrador completo de un restaurante específico. Puede gestionar menús, pedidos, usuarios del restaurante.',
    '["restaurant.manage", "menu.manage", "orders.manage", "users.manage_restaurant", "reports.view"]'
),
(
    '33333333-3333-3333-3333-333333333333',
    'manager',
    'Gerente',
    'Gerente de restaurante. Puede gestionar operaciones diarias, menús y empleados.',
    '["menu.manage", "orders.manage", "users.manage_staff", "reports.view"]'
),
(
    '44444444-4444-4444-4444-444444444444',
    'staff',
    'Empleado',
    'Personal del restaurante. Puede ver y actualizar pedidos, cambiar disponibilidad de productos.',
    '["orders.view", "orders.update_status", "menu.update_availability"]'
);

-- ============================================
-- CREAR SUPER USUARIO INICIAL
-- ============================================

-- Insertar super usuario (cambiar email y contraseña)
INSERT INTO users (
    id, 
    email, 
    password_hash, 
    role_id, 
    restaurant_id, 
    is_active, 
    email_verified
) VALUES (
    '00000000-0000-0000-0000-000000000000',
    'admin@chatbot-chingon.com', -- CAMBIAR POR TU EMAIL
    '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', -- password123 - CAMBIAR
    '11111111-1111-1111-1111-111111111111', -- super_admin role
    NULL, -- Sin restaurante específico
    true,
    true
);

-- Insertar perfil del super usuario
INSERT INTO user_profiles (
    user_id,
    first_name,
    last_name,
    phone
) VALUES (
    '00000000-0000-0000-0000-000000000000',
    'Super',
    'Administrador',
    '+52XXXXXXXXXX' -- CAMBIAR POR TU TELÉFONO
);

-- ============================================
-- FUNCIONES DE UTILIDAD
-- ============================================

-- Función para limpiar sesiones expiradas
CREATE OR REPLACE FUNCTION clean_expired_sessions()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM user_sessions 
    WHERE expires_at < CURRENT_TIMESTAMP 
    OR is_active = false;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Función para verificar permisos de usuario
CREATE OR REPLACE FUNCTION user_has_permission(user_uuid UUID, required_permission TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    user_permissions JSONB;
    has_permission BOOLEAN := false;
BEGIN
    -- Obtener permisos del usuario
    SELECT r.permissions INTO user_permissions
    FROM users u
    JOIN roles r ON u.role_id = r.id
    WHERE u.id = user_uuid AND u.is_active = true;
    
    -- Si no se encuentra el usuario
    IF user_permissions IS NULL THEN
        RETURN false;
    END IF;
    
    -- Si tiene permiso "all" (super admin)
    IF user_permissions ? 'all' THEN
        RETURN true;
    END IF;
    
    -- Verificar permiso específico
    IF user_permissions ? required_permission THEN
        RETURN true;
    END IF;
    
    RETURN false;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- VERIFICACIÓN DE INSTALACIÓN
-- ============================================

-- Función para verificar la instalación de usuarios
CREATE OR REPLACE FUNCTION verify_users_installation()
RETURNS TEXT AS $$
DECLARE
    roles_count INTEGER;
    users_count INTEGER;
    profiles_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO roles_count FROM roles;
    SELECT COUNT(*) INTO users_count FROM users;
    SELECT COUNT(*) INTO profiles_count FROM user_profiles;
    
    RETURN FORMAT('✅ Sistema de usuarios instalado: %s roles, %s usuarios, %s perfiles', 
                  roles_count, users_count, profiles_count);
END;
$$ LANGUAGE plpgsql;

-- Ejecutar verificación
SELECT verify_users_installation();


================================================
File: database/queries/conversations.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { CONVERSATION_STATUS, CONVERSATION_STEPS } = require('../../src/utils/constants');

// ============================================
// CONSULTAS OPTIMIZADAS PARA CONVERSACIONES
// ============================================

/**
 * Obtiene conversación activa por restaurante y teléfono
 * @param {string} restaurantId - ID del restaurante
 * @param {string} customerPhone - Teléfono del cliente
 * @returns {Promise<Object|null>} Conversación activa
 */
const getActiveConversation = async (restaurantId, customerPhone) => {
  try {
    const result = await query(
      `SELECT 
        c.*,
        EXTRACT(EPOCH FROM (NOW() - c.last_interaction_at)) as seconds_since_last_interaction
      FROM conversations c 
      WHERE c.restaurant_id = $1 
        AND c.customer_phone = $2 
        AND c.status = $3
        AND c.last_interaction_at > NOW() - INTERVAL '30 minutes'
      ORDER BY c.last_interaction_at DESC
      LIMIT 1`,
      [restaurantId, customerPhone, CONVERSATION_STATUS.ACTIVE],
      'get_active_conversation'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error obteniendo conversación activa:', error);
    throw error;
  }
};

/**
 * Crea nueva conversación
 * @param {Object} conversationData - Datos de la conversación
 * @returns {Promise<Object>} Conversación creada
 */
const createConversation = async (conversationData) => {
  const {
    restaurantId,
    customerPhone,
    status = CONVERSATION_STATUS.ACTIVE,
    currentStep = CONVERSATION_STEPS.GREETING,
    orderData = {},
    aiContext = []
  } = conversationData;

  try {
    const result = await query(
      `INSERT INTO conversations (
        restaurant_id, customer_phone, status, current_step, 
        order_data, ai_context, created_at, last_interaction_at
      ) VALUES ($1, $2, $3, $4, $5::jsonb, $6::jsonb, NOW(), NOW())
      RETURNING *`,
      [
        restaurantId,
        customerPhone,
        status,
        currentStep,
        JSON.stringify(orderData),
        JSON.stringify(aiContext)
      ],
      'create_conversation'
    );

    logger.info('Nueva conversación creada', {
      conversationId: result.rows[0].id,
      restaurantId,
      customerPhone: customerPhone.substring(0, 8) + '****'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando conversación:', error);
    throw error;
  }
};

/**
 * Actualiza conversación existente
 * @param {string} conversationId - ID de la conversación
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Conversación actualizada
 */
const updateConversation = async (conversationId, updateData) => {
  const allowedFields = [
    'status', 'current_step', 'order_data', 'ai_context', 
    'conversation_summary', 'last_interaction_at'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      let value = updateData[key];
      
      // Serializar objetos/arrays a JSON
      if (['order_data', 'ai_context'].includes(key)) {
        value = JSON.stringify(value);
        fields.push(`${key} = $${paramCount}::jsonb`);
      } else if (key === 'last_interaction_at') {
        fields.push(`${key} = NOW()`);
        return; // No agregar a values ya que usamos NOW()
      } else {
        fields.push(`${key} = $${paramCount}`);
      }
      
      values.push(value);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos válidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE conversations 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, conversationId],
      'update_conversation'
    );

    if (result.rows.length === 0) {
      throw new Error('Conversación no encontrada');
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando conversación:', error);
    throw error;
  }
};

/**
 * Agrega mensaje al contexto de IA
 * @param {string} conversationId - ID de la conversación
 * @param {string} role - Rol del mensaje (user, assistant, system)
 * @param {string} content - Contenido del mensaje
 * @returns {Promise<Object>} Conversación actualizada
 */
const addToAiContext = async (conversationId, role, content) => {
  try {
    const result = await query(
      `UPDATE conversations 
       SET ai_context = COALESCE(ai_context, '[]'::jsonb) || $1::jsonb,
           last_interaction_at = NOW(),
           updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [
        JSON.stringify([{ role, content, timestamp: new Date().toISOString() }]),
        conversationId
      ],
      'add_to_ai_context'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error agregando al contexto de IA:', error);
    throw error;
  }
};

/**
 * Obtiene conversaciones con paginación y filtros
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Object>} Lista paginada de conversaciones
 */
const getConversationsPaginated = async (restaurantId, options = {}) => {
  const {
    page = 1,
    limit = 20,
    status = null,
    step = null,
    customerPhone = null,
    sortBy = 'last_interaction_at',
    sortOrder = 'DESC',
    dateFrom = null,
    dateTo = null
  } = options;

  const offset = (page - 1) * limit;
  const conditions = ['c.restaurant_id = $1'];
  const values = [restaurantId];
  let paramCount = 2;

  // Agregar filtros
  if (status) {
    conditions.push(`c.status = $${paramCount}`);
    values.push(status);
    paramCount++;
  }

  if (step) {
    conditions.push(`c.current_step = $${paramCount}`);
    values.push(step);
    paramCount++;
  }

  if (customerPhone) {
    conditions.push(`c.customer_phone = $${paramCount}`);
    values.push(customerPhone);
    paramCount++;
  }

  if (dateFrom) {
    conditions.push(`c.created_at >= $${paramCount}`);
    values.push(dateFrom);
    paramCount++;
  }

  if (dateTo) {
    conditions.push(`c.created_at <= $${paramCount}`);
    values.push(dateTo);
    paramCount++;
  }

  const whereClause = conditions.join(' AND ');
  const orderBy = `ORDER BY c.${sortBy} ${sortOrder}`;

  try {
    // Consulta principal
    const conversationsResult = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.order_data::text != '{}' THEN 
            (c.order_data->>'total')::numeric 
          ELSE 0 
        END as order_total,
        EXTRACT(EPOCH FROM (NOW() - c.last_interaction_at))/60 as minutes_since_last_interaction,
        jsonb_array_length(COALESCE(c.ai_context, '[]'::jsonb)) as message_count
      FROM conversations c 
      WHERE ${whereClause}
      ${orderBy}
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_conversations_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM conversations c WHERE ${whereClause}`,
      values.slice(0, -2), // Remover limit y offset
      'count_conversations'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      conversations: conversationsResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo conversaciones paginadas:', error);
    throw error;
  }
};

/**
 * Obtiene estadísticas de conversaciones para un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} Estadísticas
 */
const getConversationStats = async (restaurantId, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = ['restaurant_id = $1'];
  const values = [restaurantId];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $2 AND $3');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.join(' AND ');

  try {
    const result = await query(
      `SELECT 
        COUNT(*) as total_conversations,
        COUNT(CASE WHEN status = '${CONVERSATION_STATUS.ACTIVE}' THEN 1 END) as active_conversations,
        COUNT(CASE WHEN status = '${CONVERSATION_STATUS.COMPLETED}' THEN 1 END) as completed_conversations,
        COUNT(CASE WHEN status = '${CONVERSATION_STATUS.ABANDONED}' THEN 1 END) as abandoned_conversations,
        
        -- Por pasos
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.GREETING}' THEN 1 END) as greeting_step,
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.ORDERING}' THEN 1 END) as ordering_step,
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.ADDRESS}' THEN 1 END) as address_step,
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.CONFIRMING}' THEN 1 END) as confirming_step,
        
        -- Métricas de tiempo
        AVG(EXTRACT(EPOCH FROM (
          COALESCE(updated_at, NOW()) - created_at
        ))/60) as avg_duration_minutes,
        
        -- Conversiones
        ROUND(
          (COUNT(CASE WHEN status = '${CONVERSATION_STATUS.COMPLETED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as conversion_rate,
        
        -- Abandono
        ROUND(
          (COUNT(CASE WHEN status = '${CONVERSATION_STATUS.ABANDONED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as abandonment_rate
        
      FROM conversations 
      WHERE ${whereClause}`,
      values,
      'get_conversation_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estadísticas de conversaciones:', error);
    throw error;
  }
};

/**
 * Limpia conversaciones inactivas
 * @param {number} hoursInactive - Horas de inactividad para considerar abandono
 * @returns {Promise<number>} Número de conversaciones limpiadas
 */
const cleanInactiveConversations = async (hoursInactive = 2) => {
  try {
    const result = await query(
      `UPDATE conversations 
       SET status = $1, 
           conversation_summary = 'Conversación abandonada por inactividad',
           updated_at = NOW()
       WHERE status = $2 
         AND last_interaction_at < NOW() - INTERVAL '${hoursInactive} hours'
       RETURNING id`,
      [CONVERSATION_STATUS.ABANDONED, CONVERSATION_STATUS.ACTIVE],
      'clean_inactive_conversations'
    );

    const cleanedCount = result.rows.length;
    
    if (cleanedCount > 0) {
      logger.info(`Conversaciones inactivas limpiadas: ${cleanedCount}`);
    }

    return cleanedCount;
  } catch (error) {
    logger.error('Error limpiando conversaciones inactivas:', error);
    throw error;
  }
};

/**
 * Busca conversaciones por texto
 * @param {string} restaurantId - ID del restaurante
 * @param {string} searchTerm - Término de búsqueda
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Conversaciones encontradas
 */
const searchConversations = async (restaurantId, searchTerm, options = {}) => {
  const { limit = 50 } = options;

  try {
    const result = await query(
      `SELECT 
        c.*,
        ts_rank(
          to_tsvector('spanish', 
            COALESCE(c.conversation_summary, '') || ' ' ||
            COALESCE(c.ai_context::text, '')
          ),
          plainto_tsquery('spanish', $2)
        ) as relevance
      FROM conversations c
      WHERE c.restaurant_id = $1
        AND (
          c.customer_phone ILIKE $3
          OR c.conversation_summary ILIKE $3
          OR c.ai_context::text ILIKE $3
        )
      ORDER BY relevance DESC, c.last_interaction_at DESC
      LIMIT $4`,
      [
        restaurantId,
        searchTerm,
        `%${searchTerm}%`,
        limit
      ],
      'search_conversations'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando conversaciones:', error);
    throw error;
  }
};

/**
 * Obtiene conversaciones por cliente
 * @param {string} customerPhone - Teléfono del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Historial del cliente
 */
const getCustomerConversationHistory = async (customerPhone, restaurantId = null, options = {}) => {
  const { limit = 10, includeActive = true } = options;
  
  const conditions = ['customer_phone = $1'];
  const values = [customerPhone];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  if (!includeActive) {
    conditions.push(`status != $${paramCount}`);
    values.push(CONVERSATION_STATUS.ACTIVE);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        c.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        CASE 
          WHEN c.order_data::text != '{}' THEN 
            (c.order_data->>'total')::numeric 
          ELSE 0 
        END as order_total
      FROM conversations c
      JOIN restaurants r ON c.restaurant_id = r.id
      WHERE ${conditions.join(' AND ')}
      ORDER BY c.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_conversation_history'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo historial de conversaciones del cliente:', error);
    throw error;
  }
};

module.exports = {
  getActiveConversation,
  createConversation,
  updateConversation,
  addToAiContext,
  getConversationsPaginated,
  getConversationStats,
  cleanInactiveConversations,
  searchConversations,
  getCustomerConversationHistory
};


================================================
File: database/queries/customers.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');

// ============================================
// CONSULTAS OPTIMIZADAS PARA CLIENTES
// ============================================

/**
 * Busca cliente por teléfono
 * @param {string} phone - Número de teléfono
 * @returns {Promise<Object|null>} Cliente encontrado
 */
const findByPhone = async (phone) => {
  try {
    const result = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN c.total_spent / c.total_orders 
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))
          ELSE NULL
        END as days_since_last_order
      FROM customers c 
      WHERE c.phone = $1`,
      [phone],
      'find_customer_by_phone'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando cliente por teléfono:', error);
    throw error;
  }
};

/**
 * Crea un nuevo cliente
 * @param {Object} customerData - Datos del cliente
 * @returns {Promise<Object>} Cliente creado
 */
const createCustomer = async (customerData) => {
  const {
    phone,
    name = null,
    defaultAddress = null,
    defaultReferences = null
  } = customerData;

  try {
    const result = await query(
      `INSERT INTO customers (
        id, phone, name, default_address, default_references, created_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())
      RETURNING *`,
      [
        uuidv4(),
        phone,
        name,
        defaultAddress,
        defaultReferences
      ],
      'create_customer'
    );

    logger.info('Nuevo cliente creado', {
      customerId: result.rows[0].id,
      phone: phone.substring(0, 8) + '****'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando cliente:', error);
    throw error;
  }
};

/**
 * Encuentra cliente existente o crea uno nuevo
 * @param {string} phone - Número de teléfono
 * @param {Object} additionalData - Datos adicionales si se crea
 * @returns {Promise<Object>} Cliente existente o nuevo
 */
const findOrCreate = async (phone, additionalData = {}) => {
  try {
    // Primero buscar cliente existente
    let customer = await findByPhone(phone);
    
    if (customer) {
      return customer;
    }

    // Si no existe, crear uno nuevo
    return await createCustomer({ phone, ...additionalData });
  } catch (error) {
    logger.error('Error en findOrCreate cliente:', error);
    throw error;
  }
};

/**
 * Actualiza datos del cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateCustomer = async (customerId, updateData) => {
  const allowedFields = [
    'name', 'default_address', 'default_references'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      fields.push(`${key} = $${paramCount}`);
      values.push(updateData[key]);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos válidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE customers 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, customerId],
      'update_customer'
    );

    if (result.rows.length === 0) {
      throw new Error('Cliente no encontrado');
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando cliente:', error);
    throw error;
  }
};

/**
 * Actualiza estadísticas del cliente tras un pedido
 * @param {string} customerId - ID del cliente
 * @param {number} orderTotal - Total del pedido
 * @param {boolean} isFirstOrder - Si es el primer pedido
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateOrderStats = async (customerId, orderTotal, isFirstOrder = false) => {
  try {
    const result = await query(
      `UPDATE customers 
       SET total_orders = total_orders + 1,
           total_spent = total_spent + $2,
           last_order_at = NOW(),
           first_order_at = CASE 
             WHEN $3 THEN NOW() 
             ELSE first_order_at 
           END
       WHERE id = $1
       RETURNING *`,
      [customerId, orderTotal, isFirstOrder],
      'update_customer_order_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estadísticas del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene lista de clientes con paginación
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Object>} Lista paginada de clientes
 */
const getCustomersPaginated = async (options = {}) => {
  const {
    page = 1,
    limit = 20,
    search = '',
    sortBy = 'last_order_at',
    sortOrder = 'DESC',
    minOrders = null,
    minSpent = null
  } = options;

  const offset = (page - 1) * limit;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  // Filtro de búsqueda
  if (search) {
    conditions.push(`(c.phone ILIKE $${paramCount} OR c.name ILIKE $${paramCount})`);
    values.push(`%${search}%`);
    paramCount++;
  }

  // Filtro por número mínimo de pedidos
  if (minOrders !== null) {
    conditions.push(`c.total_orders >= $${paramCount}`);
    values.push(minOrders);
    paramCount++;
  }

  // Filtro por gasto mínimo
  if (minSpent !== null) {
    conditions.push(`c.total_spent >= $${paramCount}`);
    values.push(minSpent);
    paramCount++;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    // Consulta principal con métricas calculadas
    const customersResult = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order,
        CASE
          WHEN c.first_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.first_order_at))::integer
          ELSE NULL
        END as customer_lifetime_days,
        -- Clasificación del cliente
        CASE
          WHEN c.total_orders = 0 THEN 'new'
          WHEN c.total_orders = 1 THEN 'first_time'
          WHEN c.total_orders BETWEEN 2 AND 5 THEN 'occasional'
          WHEN c.total_orders BETWEEN 6 AND 15 THEN 'regular'
          ELSE 'loyal'
        END as customer_segment
      FROM customers c 
      ${whereClause}
      ORDER BY c.${sortBy} ${sortOrder} NULLS LAST
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_customers_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM customers c ${whereClause}`,
      values,
      'count_customers'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      customers: customersResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo clientes paginados:', error);
    throw error;
  }
};

/**
 * Obtiene estadísticas generales de clientes
 * @param {Object} dateRange - Rango de fechas opcional
 * @returns {Promise<Object>} Estadísticas de clientes
 */
const getCustomerStats = async (dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $1 AND $2');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders = 0 THEN 1 END) as new_customers,
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as first_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 5 THEN 1 END) as occasional_customers,
        COUNT(CASE WHEN total_orders BETWEEN 6 AND 15 THEN 1 END) as regular_customers,
        COUNT(CASE WHEN total_orders > 15 THEN 1 END) as loyal_customers,
        
        -- Métricas de valor
        COALESCE(AVG(total_spent), 0) as avg_customer_value,
        COALESCE(AVG(CASE WHEN total_orders > 0 THEN total_spent / total_orders END), 0) as avg_order_value,
        COALESCE(AVG(total_orders), 0) as avg_orders_per_customer,
        
        -- Métricas de tiempo
        COALESCE(AVG(CASE 
          WHEN last_order_at IS NOT NULL THEN 
            EXTRACT(DAYS FROM (NOW() - last_order_at))
        END), 0) as avg_days_since_last_order,
        
        -- Distribución geográfica básica (por códigos de área)
        jsonb_object_agg(
          phone_area,
          area_count
        ) as phone_area_distribution
        
      FROM customers c
      LEFT JOIN (
        SELECT 
          SUBSTRING(phone FROM 1 FOR 5) as phone_area,
          COUNT(*) as area_count
        FROM customers
        ${whereClause}
        GROUP BY SUBSTRING(phone FROM 1 FOR 5)
      ) areas ON true
      ${whereClause}`,
      values,
      'get_customer_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estadísticas de clientes:', error);
    throw error;
  }
};

/**
 * Obtiene clientes top por valor gastado
 * @param {number} limit - Cantidad de clientes top a obtener
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @returns {Promise<Array>} Lista de clientes top
 */
const getTopCustomersByValue = async (limit = 10, restaurantId = null) => {
  try {
    let query_text = `
      SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order
      FROM customers c`;

    const values = [limit];

    if (restaurantId) {
      query_text += `
        WHERE c.id IN (
          SELECT DISTINCT o.customer_id 
          FROM orders o 
          WHERE o.restaurant_id = $2 AND o.customer_id IS NOT NULL
        )`;
      values.push(restaurantId);
    }

    query_text += `
      ORDER BY c.total_spent DESC, c.total_orders DESC
      LIMIT $1`;

    const result = await query(query_text, values, 'get_top_customers_by_value');

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo clientes top por valor:', error);
    throw error;
  }
};

/**
 * Obtiene historial de pedidos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Array>} Historial de pedidos
 */
const getCustomerOrderHistory = async (customerId, options = {}) => {
  const { limit = 20, restaurantId = null } = options;
  
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        COUNT(oi.id) as items_count
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${conditions.join(' AND ')}
      GROUP BY o.id, r.name, r.slug
      ORDER BY o.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_order_history'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo historial de pedidos del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene items favoritos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {number} limit - Límite de resultados
 * @returns {Promise<Array>} Items favoritos
 */
const getCustomerFavoriteItems = async (customerId, restaurantId = null, limit = 10) => {
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        mi.id, mi.name, mi.description, mi.price, mi.image_url,
        mc.name as category_name,
        COUNT(oi.id) as order_count,
        SUM(oi.quantity) as total_quantity,
        ROUND(AVG(oi.item_total), 2) as avg_item_total,
        MAX(o.created_at) as last_ordered_at
      FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      JOIN menu_items mi ON oi.menu_item_id = mi.id
      JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE ${conditions.join(' AND ')}
        AND o.status NOT IN ('cancelled')
      GROUP BY mi.id, mi.name, mi.description, mi.price, mi.image_url, mc.name
      ORDER BY order_count DESC, total_quantity DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_favorite_items'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo items favoritos del cliente:', error);
    throw error;
  }
};

/**
 * Busca clientes similares basado en patrones de pedidos
 * @param {string} customerId - ID del cliente base
 * @param {string} restaurantId - ID del restaurante
 * @param {number} limit - Límite de resultados
 * @returns {Promise<Array>} Clientes similares
 */
const findSimilarCustomers = async (customerId, restaurantId, limit = 5) => {
  try {
    const result = await query(
      `WITH customer_items AS (
        SELECT DISTINCT oi.menu_item_id
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        WHERE o.customer_id = $1 AND o.restaurant_id = $2
      ),
      similar_customers AS (
        SELECT 
          o2.customer_id,
          COUNT(DISTINCT oi2.menu_item_id) as common_items,
          AVG(o2.total) as avg_order_value
        FROM orders o2
        JOIN order_items oi2 ON o2.id = oi2.order_id
        WHERE o2.restaurant_id = $2
          AND o2.customer_id != $1
          AND o2.customer_id IS NOT NULL
          AND oi2.menu_item_id IN (SELECT menu_item_id FROM customer_items)
        GROUP BY o2.customer_id
        HAVING COUNT(DISTINCT oi2.menu_item_id) > 0
      )
      SELECT 
        c.*,
        sc.common_items,
        sc.avg_order_value as similar_avg_order_value
      FROM similar_customers sc
      JOIN customers c ON sc.customer_id = c.id
      ORDER BY sc.common_items DESC, ABS(sc.avg_order_value - (
        SELECT AVG(total) FROM orders WHERE customer_id = $1 AND restaurant_id = $2
      )) ASC
      LIMIT $3`,
      [customerId, restaurantId, limit],
      'find_similar_customers'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando clientes similares:', error);
    throw error;
  }
};

/**
 * Obtiene métricas de retención de clientes
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} Métricas de retención
 */
const getRetentionMetrics = async (restaurantId = null, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  if (startDate && endDate) {
    conditions.push(`o.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`);
    values.push(startDate, endDate);
    paramCount += 2;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `WITH customer_metrics AS (
        SELECT 
          o.customer_id,
          COUNT(*) as total_orders,
          MIN(o.created_at) as first_order,
          MAX(o.created_at) as last_order,
          EXTRACT(DAYS FROM (MAX(o.created_at) - MIN(o.created_at))) as customer_lifespan_days
        FROM orders o
        ${whereClause}
        AND o.customer_id IS NOT NULL
        AND o.status NOT IN ('cancelled')
        GROUP BY o.customer_id
      )
      SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders > 1 THEN 1 END) as returning_customers,
        ROUND(
          (COUNT(CASE WHEN total_orders > 1 THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as retention_rate,
        
        ROUND(AVG(total_orders), 2) as avg_orders_per_customer,
        ROUND(AVG(customer_lifespan_days), 1) as avg_customer_lifespan_days,
        
        -- Distribución por frecuencia
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as one_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 3 THEN 1 END) as low_frequency,
        COUNT(CASE WHEN total_orders BETWEEN 4 AND 8 THEN 1 END) as medium_frequency,
        COUNT(CASE WHEN total_orders > 8 THEN 1 END) as high_frequency
        
      FROM customer_metrics`,
      values,
      'get_retention_metrics'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo métricas de retención:', error);
    throw error;
  }
};

module.exports = {
  findByPhone,
  createCustomer,
  findOrCreate,
  updateCustomer,
  updateOrderStats,
  getCustomersPaginated,
  getCustomerStats,
  getTopCustomersByValue,
  getCustomerOrderHistory,
  getCustomerFavoriteItems,
  findSimilarCustomers,
  getRetentionMetrics
};


================================================
File: database/queries/menu.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');

// ============================================
// CONSULTAS OPTIMIZADAS PARA CLIENTES
// ============================================

/**
 * Busca cliente por teléfono
 * @param {string} phone - Número de teléfono
 * @returns {Promise<Object|null>} Cliente encontrado
 */
const findByPhone = async (phone) => {
  try {
    const result = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN c.total_spent / c.total_orders 
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))
          ELSE NULL
        END as days_since_last_order
      FROM customers c 
      WHERE c.phone = $1`,
      [phone],
      'find_customer_by_phone'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando cliente por teléfono:', error);
    throw error;
  }
};

/**
 * Crea un nuevo cliente
 * @param {Object} customerData - Datos del cliente
 * @returns {Promise<Object>} Cliente creado
 */
const createCustomer = async (customerData) => {
  const {
    phone,
    name = null,
    defaultAddress = null,
    defaultReferences = null
  } = customerData;

  try {
    const result = await query(
      `INSERT INTO customers (
        id, phone, name, default_address, default_references, created_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())
      RETURNING *`,
      [
        uuidv4(),
        phone,
        name,
        defaultAddress,
        defaultReferences
      ],
      'create_customer'
    );

    logger.info('Nuevo cliente creado', {
      customerId: result.rows[0].id,
      phone: phone.substring(0, 8) + '****'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando cliente:', error);
    throw error;
  }
};

/**
 * Encuentra cliente existente o crea uno nuevo
 * @param {string} phone - Número de teléfono
 * @param {Object} additionalData - Datos adicionales si se crea
 * @returns {Promise<Object>} Cliente existente o nuevo
 */
const findOrCreate = async (phone, additionalData = {}) => {
  try {
    // Primero buscar cliente existente
    let customer = await findByPhone(phone);
    
    if (customer) {
      return customer;
    }

    // Si no existe, crear uno nuevo
    return await createCustomer({ phone, ...additionalData });
  } catch (error) {
    logger.error('Error en findOrCreate cliente:', error);
    throw error;
  }
};

/**
 * Actualiza datos del cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateCustomer = async (customerId, updateData) => {
  const allowedFields = [
    'name', 'default_address', 'default_references'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      fields.push(`${key} = $${paramCount}`);
      values.push(updateData[key]);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos válidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE customers 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, customerId],
      'update_customer'
    );

    if (result.rows.length === 0) {
      throw new Error('Cliente no encontrado');
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando cliente:', error);
    throw error;
  }
};

/**
 * Actualiza estadísticas del cliente tras un pedido
 * @param {string} customerId - ID del cliente
 * @param {number} orderTotal - Total del pedido
 * @param {boolean} isFirstOrder - Si es el primer pedido
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateOrderStats = async (customerId, orderTotal, isFirstOrder = false) => {
  try {
    const result = await query(
      `UPDATE customers 
       SET total_orders = total_orders + 1,
           total_spent = total_spent + $2,
           last_order_at = NOW(),
           first_order_at = CASE 
             WHEN $3 THEN NOW() 
             ELSE first_order_at 
           END
       WHERE id = $1
       RETURNING *`,
      [customerId, orderTotal, isFirstOrder],
      'update_customer_order_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estadísticas del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene lista de clientes con paginación
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Object>} Lista paginada de clientes
 */
const getCustomersPaginated = async (options = {}) => {
  const {
    page = 1,
    limit = 20,
    search = '',
    sortBy = 'last_order_at',
    sortOrder = 'DESC',
    minOrders = null,
    minSpent = null
  } = options;

  const offset = (page - 1) * limit;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  // Filtro de búsqueda
  if (search) {
    conditions.push(`(c.phone ILIKE $${paramCount} OR c.name ILIKE $${paramCount})`);
    values.push(`%${search}%`);
    paramCount++;
  }

  // Filtro por número mínimo de pedidos
  if (minOrders !== null) {
    conditions.push(`c.total_orders >= $${paramCount}`);
    values.push(minOrders);
    paramCount++;
  }

  // Filtro por gasto mínimo
  if (minSpent !== null) {
    conditions.push(`c.total_spent >= $${paramCount}`);
    values.push(minSpent);
    paramCount++;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    // Consulta principal con métricas calculadas
    const customersResult = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order,
        CASE
          WHEN c.first_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.first_order_at))::integer
          ELSE NULL
        END as customer_lifetime_days,
        -- Clasificación del cliente
        CASE
          WHEN c.total_orders = 0 THEN 'new'
          WHEN c.total_orders = 1 THEN 'first_time'
          WHEN c.total_orders BETWEEN 2 AND 5 THEN 'occasional'
          WHEN c.total_orders BETWEEN 6 AND 15 THEN 'regular'
          ELSE 'loyal'
        END as customer_segment
      FROM customers c 
      ${whereClause}
      ORDER BY c.${sortBy} ${sortOrder} NULLS LAST
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_customers_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM customers c ${whereClause}`,
      values,
      'count_customers'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      customers: customersResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo clientes paginados:', error);
    throw error;
  }
};

/**
 * Obtiene estadísticas generales de clientes
 * @param {Object} dateRange - Rango de fechas opcional
 * @returns {Promise<Object>} Estadísticas de clientes
 */
const getCustomerStats = async (dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $1 AND $2');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders = 0 THEN 1 END) as new_customers,
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as first_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 5 THEN 1 END) as occasional_customers,
        COUNT(CASE WHEN total_orders BETWEEN 6 AND 15 THEN 1 END) as regular_customers,
        COUNT(CASE WHEN total_orders > 15 THEN 1 END) as loyal_customers,
        
        -- Métricas de valor
        COALESCE(AVG(total_spent), 0) as avg_customer_value,
        COALESCE(AVG(CASE WHEN total_orders > 0 THEN total_spent / total_orders END), 0) as avg_order_value,
        COALESCE(AVG(total_orders), 0) as avg_orders_per_customer,
        
        -- Métricas de tiempo
        COALESCE(AVG(CASE 
          WHEN last_order_at IS NOT NULL THEN 
            EXTRACT(DAYS FROM (NOW() - last_order_at))
        END), 0) as avg_days_since_last_order,
        
        -- Distribución geográfica básica (por códigos de área)
        jsonb_object_agg(
          phone_area,
          area_count
        ) as phone_area_distribution
        
      FROM customers c
      LEFT JOIN (
        SELECT 
          SUBSTRING(phone FROM 1 FOR 5) as phone_area,
          COUNT(*) as area_count
        FROM customers
        ${whereClause}
        GROUP BY SUBSTRING(phone FROM 1 FOR 5)
      ) areas ON true
      ${whereClause}`,
      values,
      'get_customer_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estadísticas de clientes:', error);
    throw error;
  }
};

/**
 * Obtiene clientes top por valor gastado
 * @param {number} limit - Cantidad de clientes top a obtener
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @returns {Promise<Array>} Lista de clientes top
 */
const getTopCustomersByValue = async (limit = 10, restaurantId = null) => {
  try {
    let query_text = `
      SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order
      FROM customers c`;

    const values = [limit];

    if (restaurantId) {
      query_text += `
        WHERE c.id IN (
          SELECT DISTINCT o.customer_id 
          FROM orders o 
          WHERE o.restaurant_id = $2 AND o.customer_id IS NOT NULL
        )`;
      values.push(restaurantId);
    }

    query_text += `
      ORDER BY c.total_spent DESC, c.total_orders DESC
      LIMIT $1`;

    const result = await query(query_text, values, 'get_top_customers_by_value');

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo clientes top por valor:', error);
    throw error;
  }
};

/**
 * Obtiene historial de pedidos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Array>} Historial de pedidos
 */
const getCustomerOrderHistory = async (customerId, options = {}) => {
  const { limit = 20, restaurantId = null } = options;
  
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        COUNT(oi.id) as items_count
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${conditions.join(' AND ')}
      GROUP BY o.id, r.name, r.slug
      ORDER BY o.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_order_history'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo historial de pedidos del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene items favoritos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {number} limit - Límite de resultados
 * @returns {Promise<Array>} Items favoritos
 */
const getCustomerFavoriteItems = async (customerId, restaurantId = null, limit = 10) => {
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        mi.id, mi.name, mi.description, mi.price, mi.image_url,
        mc.name as category_name,
        COUNT(oi.id) as order_count,
        SUM(oi.quantity) as total_quantity,
        ROUND(AVG(oi.item_total), 2) as avg_item_total,
        MAX(o.created_at) as last_ordered_at
      FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      JOIN menu_items mi ON oi.menu_item_id = mi.id
      JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE ${conditions.join(' AND ')}
        AND o.status NOT IN ('cancelled')
      GROUP BY mi.id, mi.name, mi.description, mi.price, mi.image_url, mc.name
      ORDER BY order_count DESC, total_quantity DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_favorite_items'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo items favoritos del cliente:', error);
    throw error;
  }
};

/**
 * Busca clientes similares basado en patrones de pedidos
 * @param {string} customerId - ID del cliente base
 * @param {string} restaurantId - ID del restaurante
 * @param {number} limit - Límite de resultados
 * @returns {Promise<Array>} Clientes similares
 */
const findSimilarCustomers = async (customerId, restaurantId, limit = 5) => {
  try {
    const result = await query(
      `WITH customer_items AS (
        SELECT DISTINCT oi.menu_item_id
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        WHERE o.customer_id = $1 AND o.restaurant_id = $2
      ),
      similar_customers AS (
        SELECT 
          o2.customer_id,
          COUNT(DISTINCT oi2.menu_item_id) as common_items,
          AVG(o2.total) as avg_order_value
        FROM orders o2
        JOIN order_items oi2 ON o2.id = oi2.order_id
        WHERE o2.restaurant_id = $2
          AND o2.customer_id != $1
          AND o2.customer_id IS NOT NULL
          AND oi2.menu_item_id IN (SELECT menu_item_id FROM customer_items)
        GROUP BY o2.customer_id
        HAVING COUNT(DISTINCT oi2.menu_item_id) > 0
      )
      SELECT 
        c.*,
        sc.common_items,
        sc.avg_order_value as similar_avg_order_value
      FROM similar_customers sc
      JOIN customers c ON sc.customer_id = c.id
      ORDER BY sc.common_items DESC, ABS(sc.avg_order_value - (
        SELECT AVG(total) FROM orders WHERE customer_id = $1 AND restaurant_id = $2
      )) ASC
      LIMIT $3`,
      [customerId, restaurantId, limit],
      'find_similar_customers'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando clientes similares:', error);
    throw error;
  }
};

/**
 * Obtiene métricas de retención de clientes
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} Métricas de retención
 */
const getRetentionMetrics = async (restaurantId = null, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  if (startDate && endDate) {
    conditions.push(`o.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`);
    values.push(startDate, endDate);
    paramCount += 2;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `WITH customer_metrics AS (
        SELECT 
          o.customer_id,
          COUNT(*) as total_orders,
          MIN(o.created_at) as first_order,
          MAX(o.created_at) as last_order,
          EXTRACT(DAYS FROM (MAX(o.created_at) - MIN(o.created_at))) as customer_lifespan_days
        FROM orders o
        ${whereClause}
        AND o.customer_id IS NOT NULL
        AND o.status NOT IN ('cancelled')
        GROUP BY o.customer_id
      )
      SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders > 1 THEN 1 END) as returning_customers,
        ROUND(
          (COUNT(CASE WHEN total_orders > 1 THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as retention_rate,
        
        ROUND(AVG(total_orders), 2) as avg_orders_per_customer,
        ROUND(AVG(customer_lifespan_days), 1) as avg_customer_lifespan_days,
        
        -- Distribución por frecuencia
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as one_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 3 THEN 1 END) as low_frequency,
        COUNT(CASE WHEN total_orders BETWEEN 4 AND 8 THEN 1 END) as medium_frequency,
        COUNT(CASE WHEN total_orders > 8 THEN 1 END) as high_frequency
        
      FROM customer_metrics`,
      values,
      'get_retention_metrics'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo métricas de retención:', error);
    throw error;
  }
};

module.exports = {
  findByPhone,
  createCustomer,
  findOrCreate,
  updateCustomer,
  updateOrderStats,
  getCustomersPaginated,
  getCustomerStats,
  getTopCustomersByValue,
  getCustomerOrderHistory,
  getCustomerFavoriteItems,
  findSimilarCustomers,
  getRetentionMetrics
};


================================================
File: database/queries/orders.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ORDER_STATUS } = require('../../src/utils/constants');

// ============================================
// CONSULTAS OPTIMIZADAS PARA PEDIDOS
// ============================================

/**
 * Crea un nuevo pedido desde una conversación
 * @param {Object} orderData - Datos del pedido
 * @returns {Promise<Object>} Pedido creado con items
 */
const createOrder = async (orderData) => {
  const {
    restaurantId,
    customerPhone,
    customerId = null,
    items,
    deliveryAddress,
    orderNotes = null,
    paymentMethod = 'cash',
    deliveryFee = 0,
    subtotal,
    total
  } = orderData;

  try {
    return await transaction(async (client) => {
      // Crear el pedido principal
      const orderResult = await client.query(
        `INSERT INTO orders (
          id, restaurant_id, customer_phone, customer_id,
          delivery_address, order_notes, payment_method,
          delivery_fee, subtotal, total, status, created_at
        ) VALUES ($1, $2, $3, $4, $5::jsonb, $6, $7, $8, $9, $10, $11, NOW())
        RETURNING *`,
        [
          uuidv4(),
          restaurantId,
          customerPhone,
          customerId,
          JSON.stringify(deliveryAddress),
          orderNotes,
          paymentMethod,
          deliveryFee,
          subtotal,
          total,
          ORDER_STATUS.CONFIRMED
        ]
      );

      const order = orderResult.rows[0];

      // Crear los items del pedido
      const orderItemsPromises = items.map(item => 
        client.query(
          `INSERT INTO order_items (
            id, order_id, menu_item_id, menu_item_name,
            quantity, base_price, customizations, customizations_cost,
            item_total, notes
          ) VALUES ($1, $2, $3, $4, $5, $6, $7::jsonb, $8, $9, $10)
          RETURNING *`,
          [
            uuidv4(),
            order.id,
            item.menu_item_id,
            item.name,
            item.quantity,
            item.base_price,
            JSON.stringify(item.customizations || []),
            item.customizations_cost || 0,
            item.item_total,
            item.notes || null
          ]
        )
      );

      const orderItemsResults = await Promise.all(orderItemsPromises);
      order.items = orderItemsResults.map(result => result.rows[0]);

      logger.info('Pedido creado exitosamente', {
        orderId: order.id,
        restaurantId,
        customerPhone: customerPhone.substring(0, 8) + '****',
        total,
        itemsCount: items.length
      });

      return order;
    });
  } catch (error) {
    logger.error('Error creando pedido:', error);
    throw error;
  }
};

/**
 * Obtiene un pedido por ID con todos sus detalles
 * @param {string} orderId - ID del pedido
 * @param {string} restaurantId - ID del restaurante (opcional para validación)
 * @returns {Promise<Object|null>} Pedido completo
 */
const findById = async (orderId, restaurantId = null) => {
  try {
    let whereClause = 'WHERE o.id = $1';
    const values = [orderId];

    if (restaurantId) {
      whereClause += ' AND o.restaurant_id = $2';
      values.push(restaurantId);
    }

    // Obtener datos del pedido
    const orderResult = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.phone as restaurant_phone,
        r.slug as restaurant_slug,
        c.name as customer_name,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN customers c ON o.customer_id = c.id
      ${whereClause}`,
      values,
      'find_order_by_id'
    );

    if (orderResult.rows.length === 0) {
      return null;
    }

    const order = orderResult.rows[0];

    // Obtener items del pedido
    const itemsResult = await query(
      `SELECT 
        oi.*,
        mi.image_url as menu_item_image
      FROM order_items oi
      LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
      WHERE oi.order_id = $1
      ORDER BY oi.created_at`,
      [orderId],
      'get_order_items'
    );

    order.items = itemsResult.rows;

    return order;
  } catch (error) {
    logger.error('Error obteniendo pedido por ID:', error);
    throw error;
  }
};

/**
 * Obtiene pedidos con filtros y paginación
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} filters - Filtros de búsqueda
 * @returns {Promise<Object>} Lista paginada de pedidos
 */
const getOrdersPaginated = async (restaurantId, filters = {}) => {
  const {
    page = 1,
    limit = 20,
    status = null,
    customerPhone = null,
    paymentMethod = null,
    dateFrom = null,
    dateTo = null,
    minTotal = null,
    maxTotal = null,
    sortBy = 'created_at',
    sortOrder = 'DESC'
  } = filters;

  const offset = (page - 1) * limit;
  const conditions = ['o.restaurant_id = $1'];
  const values = [restaurantId];
  let paramCount = 2;

  // Agregar filtros
  if (status) {
    if (Array.isArray(status)) {
      conditions.push(`o.status = ANY($${paramCount}::text[])`);
      values.push(status);
    } else {
      conditions.push(`o.status = $${paramCount}`);
      values.push(status);
    }
    paramCount++;
  }

  if (customerPhone) {
    conditions.push(`o.customer_phone = $${paramCount}`);
    values.push(customerPhone);
    paramCount++;
  }

  if (paymentMethod) {
    conditions.push(`o.payment_method = $${paramCount}`);
    values.push(paymentMethod);
    paramCount++;
  }

  if (dateFrom) {
    conditions.push(`o.created_at >= $${paramCount}`);
    values.push(dateFrom);
    paramCount++;
  }

  if (dateTo) {
    conditions.push(`o.created_at <= $${paramCount}`);
    values.push(dateTo);
    paramCount++;
  }

  if (minTotal !== null) {
    conditions.push(`o.total >= $${paramCount}`);
    values.push(minTotal);
    paramCount++;
  }

  if (maxTotal !== null) {
    conditions.push(`o.total <= $${paramCount}`);
    values.push(maxTotal);
    paramCount++;
  }

  const whereClause = conditions.join(' AND ');

  try {
    // Consulta principal
    const ordersResult = await query(
      `SELECT 
        o.*,
        c.name as customer_name,
        COUNT(oi.id) as items_count,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created,
        CASE 
          WHEN o.status = '${ORDER_STATUS.CONFIRMED}' THEN 'Confirmado'
          WHEN o.status = '${ORDER_STATUS.PREPARING}' THEN 'Preparando'
          WHEN o.status = '${ORDER_STATUS.READY}' THEN 'Listo'
          WHEN o.status = '${ORDER_STATUS.OUT_FOR_DELIVERY}' THEN 'En camino'
          WHEN o.status = '${ORDER_STATUS.DELIVERED}' THEN 'Entregado'
          WHEN o.status = '${ORDER_STATUS.CANCELLED}' THEN 'Cancelado'
          ELSE o.status
        END as status_display
      FROM orders o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${whereClause}
      GROUP BY o.id, c.name
      ORDER BY o.${sortBy} ${sortOrder}
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_orders_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM orders o WHERE ${whereClause}`,
      values.slice(0, -2), // Remover limit y offset
      'count_orders'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      orders: ordersResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo pedidos paginados:', error);
    throw error;
  }
};

/**
 * Obtiene pedidos activos (no entregados ni cancelados)
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Lista de pedidos activos
 */
const getActiveOrders = async (restaurantId, options = {}) => {
  const { limit = 50 } = options;

  try {
    const result = await query(
      `SELECT 
        o.*,
        c.name as customer_name,
        COUNT(oi.id) as items_count,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created,
        CASE 
          WHEN o.status = '${ORDER_STATUS.CONFIRMED}' THEN 1
          WHEN o.status = '${ORDER_STATUS.PREPARING}' THEN 2  
          WHEN o.status = '${ORDER_STATUS.READY}' THEN 3
          WHEN o.status = '${ORDER_STATUS.OUT_FOR_DELIVERY}' THEN 4
          ELSE 5
        END as status_priority
      FROM orders o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.restaurant_id = $1
        AND o.status NOT IN ('${ORDER_STATUS.DELIVERED}', '${ORDER_STATUS.CANCELLED}')
      GROUP BY o.id, c.name
      ORDER BY status_priority, o.created_at ASC
      LIMIT $2`,
      [restaurantId, limit],
      'get_active_orders'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo pedidos activos:', error);
    throw error;
  }
};

/**
 * Actualiza el estado de un pedido
 * @param {string} orderId - ID del pedido
 * @param {string} newStatus - Nuevo estado
 * @param {Object} additionalData - Datos adicionales
 * @returns {Promise<Object>} Pedido actualizado
 */
const updateOrderStatus = async (orderId, newStatus, additionalData = {}) => {
  const { statusNotes = null, updatedBy = null } = additionalData;

  try {
    const timestampField = getTimestampFieldForStatus(newStatus);
    let updateQuery = `
      UPDATE orders 
      SET status = $1, 
          status_notes = COALESCE($2, status_notes),
          updated_at = NOW()`;

    const values = [newStatus, statusNotes];
    let paramCount = 3;

    // Agregar timestamp específico según el estado
    if (timestampField) {
      updateQuery += `, ${timestampField} = NOW()`;
    }

    updateQuery += ` WHERE id = $${paramCount} RETURNING *`;
    values.push(orderId);

    const result = await query(updateQuery, values, 'update_order_status');

    if (result.rows.length === 0) {
      throw new Error('Pedido no encontrado');
    }

    logger.info('Estado de pedido actualizado', {
      orderId,
      newStatus,
      updatedBy: updatedBy || 'system'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estado del pedido:', error);
    throw error;
  }
};

/**
 * Obtiene estadísticas de pedidos
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} Estadísticas de pedidos
 */
const getOrderStats = async (restaurantId, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = ['restaurant_id = $1'];
  const values = [restaurantId];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $2 AND $3');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.join(' AND ');

  try {
    const result = await query(
      `SELECT 
        -- Conteos generales
        COUNT(*) as total_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.CONFIRMED}' THEN 1 END) as confirmed_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.PREPARING}' THEN 1 END) as preparing_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.READY}' THEN 1 END) as ready_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.OUT_FOR_DELIVERY}' THEN 1 END) as out_for_delivery_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.CANCELLED}' THEN 1 END) as cancelled_orders,
        
        -- Métricas financieras
        COALESCE(SUM(total), 0) as total_revenue,
        COALESCE(SUM(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN total END), 0) as delivered_revenue,
        COALESCE(AVG(total), 0) as avg_order_value,
        COALESCE(SUM(delivery_fee), 0) as total_delivery_fees,
        
        -- Métricas de tiempo
        COALESCE(AVG(EXTRACT(EPOCH FROM (delivered_at - created_at))/60), 0) as avg_delivery_time_minutes,
        COALESCE(AVG(EXTRACT(EPOCH FROM (ready_at - created_at))/60), 0) as avg_preparation_time_minutes,
        
        -- Métricas por método de pago
        COUNT(CASE WHEN payment_method = 'cash' THEN 1 END) as cash_orders,
        COUNT(CASE WHEN payment_method = 'card' THEN 1 END) as card_orders,
        COUNT(CASE WHEN payment_method = 'transfer' THEN 1 END) as transfer_orders,
        
        -- Clientes únicos
        COUNT(DISTINCT customer_phone) as unique_customers,
        
        -- Tasas
        ROUND(
          (COUNT(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as delivery_rate,
        
        ROUND(
          (COUNT(CASE WHEN status = '${ORDER_STATUS.CANCELLED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as cancellation_rate
        
      FROM orders 
      WHERE ${whereClause}`,
      values,
      'get_order_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estadísticas de pedidos:', error);
    throw error;
  }
};

/**
 * Obtiene pedidos por cliente
 * @param {string} customerPhone - Teléfono del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Historial de pedidos del cliente
 */
const getCustomerOrders = async (customerPhone, restaurantId = null, options = {}) => {
  const { limit = 20, includeItems = false } = options;
  
  const conditions = ['customer_phone = $1'];
  const values = [customerPhone];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const ordersResult = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        COUNT(oi.id) as items_count
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${conditions.join(' AND ')}
      GROUP BY o.id, r.name, r.slug
      ORDER BY o.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_orders'
    );

    const orders = ordersResult.rows;

    // Si se solicitan los items, obtenerlos por separado
    if (includeItems && orders.length > 0) {
      const orderIds = orders.map(order => order.id);
      
      const itemsResult = await query(
        `SELECT 
          oi.*,
          mi.image_url as menu_item_image
        FROM order_items oi
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE oi.order_id = ANY($1::uuid[])
        ORDER BY oi.order_id, oi.created_at`,
        [orderIds],
        'get_multiple_order_items'
      );

      // Agrupar items por pedido
      const itemsByOrder = {};
      itemsResult.rows.forEach(item => {
        if (!itemsByOrder[item.order_id]) {
          itemsByOrder[item.order_id] = [];
        }
        itemsByOrder[item.order_id].push(item);
      });

      // Agregar items a cada pedido
      orders.forEach(order => {
        order.items = itemsByOrder[order.id] || [];
      });
    }

    return orders;
  } catch (error) {
    logger.error('Error obteniendo pedidos del cliente:', error);
    throw error;
  }
};

/**
 * Busca pedidos por texto
 * @param {string} restaurantId - ID del restaurante
 * @param {string} searchTerm - Término de búsqueda
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Pedidos encontrados
 */
const searchOrders = async (restaurantId, searchTerm, options = {}) => {
  const { limit = 50 } = options;

  try {
    const result = await query(
      `SELECT DISTINCT
        o.*,
        c.name as customer_name,
        COUNT(oi.id) as items_count,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created
      FROM orders o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.restaurant_id = $1
        AND (
          o.customer_phone ILIKE $2
          OR c.name ILIKE $2
          OR o.order_notes ILIKE $2
          OR o.status_notes ILIKE $2
          OR oi.menu_item_name ILIKE $2
          OR oi.notes ILIKE $2
          OR o.id::text ILIKE $2
        )
      GROUP BY o.id, c.name
      ORDER BY o.created_at DESC
      LIMIT $3`,
      [restaurantId, `%${searchTerm}%`, limit],
      'search_orders'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando pedidos:', error);
    throw error;
  }
};

/**
 * Genera reporte de ventas
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} params - Parámetros del reporte
 * @returns {Promise<Object>} Reporte de ventas
 */
const generateSalesReport = async (restaurantId, params = {}) => {
  const {
    startDate,
    endDate,
    groupBy = 'day' // day, week, month
  } = params;

  try {
    let dateFormat;
    switch (groupBy) {
      case 'week':
        dateFormat = 'YYYY-"W"WW';
        break;
      case 'month':
        dateFormat = 'YYYY-MM';
        break;
      default:
        dateFormat = 'YYYY-MM-DD';
    }

    const result = await query(
      `SELECT 
        TO_CHAR(created_at, '${dateFormat}') as period,
        COUNT(*) as total_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.CANCELLED}' THEN 1 END) as cancelled_orders,
        COALESCE(SUM(total), 0) as total_revenue,
        COALESCE(SUM(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN total END), 0) as delivered_revenue,
        COALESCE(AVG(total), 0) as avg_order_value,
        COUNT(DISTINCT customer_phone) as unique_customers
      FROM orders
      WHERE restaurant_id = $1
        AND created_at BETWEEN $2 AND $3
        AND status != '${ORDER_STATUS.CANCELLED}'
      GROUP BY TO_CHAR(created_at, '${dateFormat}')
      ORDER BY period`,
      [restaurantId, startDate, endDate],
      'generate_sales_report'
    );

    return {
      period_type: groupBy,
      date_range: { startDate, endDate },
      data: result.rows,
      generated_at: new Date().toISOString()
    };
  } catch (error) {
    logger.error('Error generando reporte de ventas:', error);
    throw error;
  }
};

/**
 * Obtiene items más vendidos
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Array>} Items más vendidos
 */
const getTopSellingItems = async (restaurantId, options = {}) => {
  const { limit = 20, days = 30 } = options;

  try {
    const result = await query(
      `SELECT 
        oi.menu_item_id,
        oi.menu_item_name,
        mi.image_url,
        mc.name as category_name,
        SUM(oi.quantity) as total_quantity,
        COUNT(DISTINCT oi.order_id) as order_count,
        ROUND(AVG(oi.item_total / oi.quantity), 2) as avg_unit_price,
        SUM(oi.item_total) as total_revenue
      FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
      LEFT JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE o.restaurant_id = $1
        AND o.status NOT IN ('${ORDER_STATUS.CANCELLED}')
        AND o.created_at > NOW() - INTERVAL '$2 days'
      GROUP BY oi.menu_item_id, oi.menu_item_name, mi.image_url, mc.name
      ORDER BY total_quantity DESC, order_count DESC
      LIMIT $3`,
      [restaurantId, days, limit],
      'get_top_selling_items'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo items más vendidos:', error);
    throw error;
  }
};

/**
 * Cancela un pedido
 * @param {string} orderId - ID del pedido
 * @param {Object} cancellationData - Datos de la cancelación
 * @returns {Promise<Object>} Pedido cancelado
 */
const cancelOrder = async (orderId, cancellationData = {}) => {
  const { reason = 'Cancelado por el sistema', cancelledBy = null } = cancellationData;

  try {
    const result = await query(
      `UPDATE orders 
       SET status = $1,
           status_notes = $2,
           cancelled_at = NOW(),
           updated_at = NOW()
       WHERE id = $3 AND status NOT IN ('${ORDER_STATUS.DELIVERED}', '${ORDER_STATUS.CANCELLED}')
       RETURNING *`,
      [ORDER_STATUS.CANCELLED, reason, orderId],
      'cancel_order'
    );

    if (result.rows.length === 0) {
      throw new Error('Pedido no encontrado o no se puede cancelar');
    }

    logger.info('Pedido cancelado', {
      orderId,
      reason,
      cancelledBy: cancelledBy || 'system'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error cancelando pedido:', error);
    throw error;
  }
};

// ============================================
// FUNCIONES AUXILIARES
// ============================================

/**
 * Obtiene el campo de timestamp correspondiente al estado
 * @param {string} status - Estado del pedido
 * @returns {string|null} Nombre del campo timestamp
 */
const getTimestampFieldForStatus = (status) => {
  const statusTimestamps = {
    [ORDER_STATUS.CONFIRMED]: 'confirmed_at',
    [ORDER_STATUS.PREPARING]: 'preparing_at',
    [ORDER_STATUS.READY]: 'ready_at',
    [ORDER_STATUS.OUT_FOR_DELIVERY]: 'out_for_delivery_at',
    [ORDER_STATUS.DELIVERED]: 'delivered_at',
    [ORDER_STATUS.CANCELLED]: 'cancelled_at'
  };

  return statusTimestamps[status] || null;
};

module.exports = {
  createOrder,
  findById,
  getOrdersPaginated,
  getActiveOrders,
  updateOrderStatus,
  getOrderStats,
  getCustomerOrders,
  searchOrders,
  generateSalesReport,
  getTopSellingItems,
  cancelOrder
};


================================================
File: database/queries/restaurants.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');

// ============================================
// CONSULTAS OPTIMIZADAS PARA RESTAURANTES
// ============================================

/**
 * Busca restaurante por slug
 * @param {string} slug - Slug del restaurante
 * @returns {Promise<Object|null>} Restaurante encontrado
 */
const findBySlug = async (slug) => {
  try {
    const result = await query(
      `SELECT 
        r.*,
        -- Estadísticas básicas
        (SELECT COUNT(*) FROM orders WHERE restaurant_id = r.id) as total_orders,
        (SELECT COUNT(*) FROM menu_items WHERE restaurant_id = r.id AND is_available = true) as available_items,
        (SELECT COUNT(*) FROM conversations WHERE restaurant_id = r.id AND status = 'active') as active_conversations,
        -- Estado operacional
        CASE 
          WHEN r.is_active = false THEN 'closed'
          WHEN CURRENT_TIME BETWEEN r.opens_at AND r.closes_at THEN 'open'
          ELSE 'closed'
        END as current_status
      FROM restaurants r 
      WHERE r.slug = $1`,
      [slug],
      'find_restaurant_by_slug'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando restaurante por slug:', error);
    throw error;
  }
};

/**
 * Busca restaurante por ID
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Object|null>} Restaurante encontrado
 */
const findById = async (restaurantId) => {
  try {
    const result = await query(
      `SELECT 
        r.*,
        -- Estadísticas detalladas
        (SELECT COUNT(*) FROM orders WHERE restaurant_id = r.id) as total_orders,
        (SELECT COUNT(*) FROM orders WHERE restaurant_id = r.id AND status = 'delivered') as delivered_orders,
        (SELECT COALESCE(SUM(total), 0) FROM orders WHERE restaurant_id = r.id AND status = 'delivered') as total_revenue,
        (SELECT COUNT(*) FROM customers WHERE id IN (SELECT DISTINCT customer_id FROM orders WHERE restaurant_id = r.id)) as total_customers,
        (SELECT COUNT(*) FROM menu_categories WHERE restaurant_id = r.id AND is_active = true) as active_categories,
        (SELECT COUNT(*) FROM menu_items WHERE restaurant_id = r.id AND is_available = true) as available_items,
        (SELECT COUNT(*) FROM conversations WHERE restaurant_id = r.id AND status = 'active') as active_conversations,
        -- Estado operacional
        CASE 
          WHEN r.is_active = false THEN 'closed'
          WHEN CURRENT_TIME BETWEEN r.opens_at AND r.closes_at THEN 'open'
          ELSE 'closed'
        END as current_status
      FROM restaurants r 
      WHERE r.id = $1`,
      [restaurantId],
      'find_restaurant_by_id'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando restaurante por ID:', error);
    throw error;
  }
};

/**
 * Crea un nuevo restaurante
 * @param {Object} restaurantData - Datos del restaurante
 * @returns {Promise<Object>} Restaurante creado
 */
const createRestaurant = async (restaurantData) => {
  const {
    name,
    slug,
    phone,
    email = null,
    address = null,
    logoUrl = null,
    opensAt = '09:00:00',
    closesAt = '23:00:00',
    deliveryTimeMin = 25,
    deliveryTimeMax = 35,
    deliveryFee = 0.00,
    minimumOrder = 0.00,
    whatsappPhoneId = null,
    whatsappToken = null,
    twilioPhoneNumber = null
  } = restaurantData;

  try {
    const result = await query(
      `INSERT INTO restaurants (
        id, name, slug, phone, email, address, logo_url,
        opens_at, closes_at, delivery_time_min, delivery_time_max,
        delivery_fee, minimum_order, whatsapp_phone_id, 
        whatsapp_token, twilio_phone_number, is_active, created_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 
        $12, $13, $14, $15, $16, true, NOW()
      )
      RETURNING *`,
      [
        uuidv4(),
        name,
        slug,
        phone,
        email,
        address,
        logoUrl,
        opensAt,
        closesAt,
        deliveryTimeMin,
        deliveryTimeMax,
        deliveryFee,
        minimumOrder,
        whatsappPhoneId,
        whatsappToken,
        twilioPhoneNumber
      ],
      'create_restaurant'
    );

    logger.info('Nuevo restaurante creado', {
      restaurantId: result.rows[0].id,
      name,
      slug
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando restaurante:', error);
    throw error;
  }
};

/**
 * Actualiza un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Restaurante actualizado
 */
const updateRestaurant = async (restaurantId, updateData) => {
  const allowedFields = [
    'name', 'slug', 'phone', 'email', 'address', 'logo_url',
    'opens_at', 'closes_at', 'delivery_time_min', 'delivery_time_max',
    'delivery_fee', 'minimum_order', 'is_active', 'whatsapp_phone_id',
    'whatsapp_token', 'twilio_phone_number'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      fields.push(`${key} = $${paramCount}`);
      values.push(updateData[key]);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos válidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE restaurants 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, restaurantId],
      'update_restaurant'
    );

    if (result.rows.length === 0) {
      throw new Error('Restaurante no encontrado');
    }

    logger.info('Restaurante actualizado', {
      restaurantId,
      fieldsUpdated: Object.keys(updateData)
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando restaurante:', error);
    throw error;
  }
};

/**
 * Obtiene lista de restaurantes con paginación
 * @param {Object} filters - Filtros de búsqueda
 * @returns {Promise<Object>} Lista paginada de restaurantes
 */
const getRestaurantsPaginated = async (filters = {}) => {
  const {
    page = 1,
    limit = 20,
    search = '',
    isActive = null,
    sortBy = 'created_at',
    sortOrder = 'DESC'
  } = filters;

  const offset = (page - 1) * limit;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  // Filtro de búsqueda
  if (search) {
    conditions.push(`(r.name ILIKE $${paramCount} OR r.slug ILIKE $${paramCount} OR r.phone ILIKE $${paramCount})`);
    values.push(`%${search}%`);
    paramCount++;
  }

  // Filtro por estado activo
  if (isActive !== null) {
    conditions.push(`r.is_active = $${paramCount}`);
    values.push(isActive);
    paramCount++;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    // Consulta principal con métricas
    const restaurantsResult = await query(
      `SELECT 
        r.*,
        -- Estadísticas operacionales
        COALESCE(stats.total_orders, 0) as total_orders,
        COALESCE(stats.delivered_orders, 0) as delivered_orders,
        COALESCE(stats.total_revenue, 0) as total_revenue,
        COALESCE(stats.total_customers, 0) as total_customers,
        COALESCE(stats.active_conversations, 0) as active_conversations,
        COALESCE(menu_stats.total_categories, 0) as total_categories,
        COALESCE(menu_stats.total_items, 0) as total_items,
        COALESCE(menu_stats.available_items, 0) as available_items,
        -- Estado actual
        CASE 
          WHEN r.is_active = false THEN 'inactive'
          WHEN CURRENT_TIME BETWEEN r.opens_at AND r.closes_at THEN 'open'
          ELSE 'closed'
        END as current_status,
        -- Última actividad
        COALESCE(activity.last_order_at, r.created_at) as last_activity
      FROM restaurants r
      LEFT JOIN (
        SELECT 
          restaurant_id,
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as delivered_orders,
          SUM(CASE WHEN status = 'delivered' THEN total ELSE 0 END) as total_revenue,
          COUNT(DISTINCT customer_id) as total_customers
        FROM orders
        GROUP BY restaurant_id
      ) stats ON r.id = stats.restaurant_id
      LEFT JOIN (
        SELECT 
          restaurant_id,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_conversations
        FROM conversations
        GROUP BY restaurant_id
      ) conv_stats ON r.id = conv_stats.restaurant_id
      LEFT JOIN (
        SELECT 
          mc.restaurant_id,
          COUNT(DISTINCT mc.id) as total_categories,
          COUNT(mi.id) as total_items,
          COUNT(CASE WHEN mi.is_available THEN 1 END) as available_items
        FROM menu_categories mc
        LEFT JOIN menu_items mi ON mc.id = mi.category_id
        GROUP BY mc.restaurant_id
      ) menu_stats ON r.id = menu_stats.restaurant_id
      LEFT JOIN (
        SELECT 
          restaurant_id,
          MAX(created_at) as last_order_at
        FROM orders
        GROUP BY restaurant_id
      ) activity ON r.id = activity.restaurant_id
      ${whereClause}
      ORDER BY r.${sortBy} ${sortOrder}
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_restaurants_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM restaurants r ${whereClause}`,
      values,
      'count_restaurants'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      restaurants: restaurantsResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo restaurantes paginados:', error);
    throw error;
  }
};

/**
 * Verifica si un slug está disponible
 * @param {string} slug - Slug a verificar
 * @param {string} excludeId - ID a excluir (para updates)
 * @returns {Promise<boolean>} True si está disponible
 */
const isSlugAvailable = async (slug, excludeId = null) => {
  try {
    let queryText = 'SELECT id FROM restaurants WHERE slug = $1';
    const values = [slug];

    if (excludeId) {
      queryText += ' AND id != $2';
      values.push(excludeId);
    }

    const result = await query(queryText, values, 'check_slug_availability');
    return result.rows.length === 0;
  } catch (error) {
    logger.error('Error verificando disponibilidad de slug:', error);
    throw error;
  }
};

/**
 * Obtiene estadísticas detalladas de un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} dateRange - Rango de fechas opcional
 * @returns {Promise<Object>} Estadísticas completas
 */
const getRestaurantStats = async (restaurantId, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  
  let dateFilter = '';
  const baseValues = [restaurantId];
  let paramCount = 2;

  if (startDate && endDate) {
    dateFilter = `AND created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
    baseValues.push(startDate, endDate);
    paramCount += 2;
  }

  try {
    return await transaction(async (client) => {
      // Estadísticas de pedidos
      const orderStatsResult = await client.query(
        `SELECT 
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as delivered_orders,
          COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_orders,
          COALESCE(SUM(total), 0) as total_revenue,
          COALESCE(SUM(CASE WHEN status = 'delivered' THEN total END), 0) as delivered_revenue,
          COALESCE(AVG(total), 0) as avg_order_value,
          COUNT(DISTINCT customer_phone) as unique_customers,
          COALESCE(AVG(EXTRACT(EPOCH FROM (delivered_at - created_at))/60), 0) as avg_delivery_time,
          
          -- Por método de pago
          COUNT(CASE WHEN payment_method = 'cash' THEN 1 END) as cash_orders,
          COUNT(CASE WHEN payment_method = 'card' THEN 1 END) as card_orders,
          COUNT(CASE WHEN payment_method = 'transfer' THEN 1 END) as transfer_orders
          
        FROM orders 
        WHERE restaurant_id = $1 ${dateFilter}`,
        baseValues
      );

      // Estadísticas de conversaciones
      const conversationStatsResult = await client.query(
        `SELECT 
          COUNT(*) as total_conversations,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_conversations,
          COUNT(CASE WHEN status = 'abandoned' THEN 1 END) as abandoned_conversations,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_conversations,
          COALESCE(AVG(EXTRACT(EPOCH FROM (COALESCE(updated_at, NOW()) - created_at))/60), 0) as avg_conversation_duration
        FROM conversations 
        WHERE restaurant_id = $1 ${dateFilter}`,
        baseValues
      );

      // Estadísticas del menú
      const menuStatsResult = await client.query(
        `SELECT 
          COUNT(DISTINCT mc.id) as total_categories,
          COUNT(mi.id) as total_menu_items,
          COUNT(CASE WHEN mi.is_available THEN 1 END) as available_items,
          COUNT(CASE WHEN mi.image_url IS NOT NULL THEN 1 END) as items_with_images,
          COALESCE(AVG(mi.current_price), 0) as avg_item_price
        FROM menu_categories mc
        LEFT JOIN menu_items mi ON mc.id = mi.category_id
        WHERE mc.restaurant_id = $1`,
        [restaurantId]
      );

      // Items más vendidos (últimos 30 días)
      const topItemsResult = await client.query(
        `SELECT 
          oi.menu_item_name,
          SUM(oi.quantity) as total_sold,
          COUNT(DISTINCT oi.order_id) as order_count
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        WHERE o.restaurant_id = $1 
          AND o.status != 'cancelled'
          AND o.created_at > NOW() - INTERVAL '30 days'
        GROUP BY oi.menu_item_name
        ORDER BY total_sold DESC
        LIMIT 5`,
        [restaurantId]
      );

      // Horarios de mayor actividad
      const hourlyStatsResult = await client.query(
        `SELECT 
          EXTRACT(HOUR FROM created_at) as hour,
          COUNT(*) as order_count
        FROM orders
        WHERE restaurant_id = $1 
          AND status != 'cancelled'
          ${dateFilter}
        GROUP BY EXTRACT(HOUR FROM created_at)
        ORDER BY hour`,
        baseValues
      );

      const stats = {
        ...orderStatsResult.rows[0],
        ...conversationStatsResult.rows[0],
        ...menuStatsResult.rows[0],
        top_items: topItemsResult.rows,
        hourly_distribution: hourlyStatsResult.rows,
        generated_at: new Date().toISOString()
      };

      // Calcular tasas
      const totalOrders = parseInt(stats.total_orders);
      const totalConversations = parseInt(stats.total_conversations);

      stats.delivery_rate = totalOrders > 0 
        ? ((parseInt(stats.delivered_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.cancellation_rate = totalOrders > 0
        ? ((parseInt(stats.cancelled_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.conversion_rate = totalConversations > 0
        ? ((parseInt(stats.completed_conversations) / totalConversations) * 100).toFixed(2)
        : 0;

      return stats;
    });
  } catch (error) {
    logger.error('Error obteniendo estadísticas del restaurante:', error);
    throw error;
  }
};

/**
 * Obtiene zonas de entrega de un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Array>} Zonas de entrega
 */
const getDeliveryZones = async (restaurantId) => {
  try {
    const result = await query(
      `SELECT * FROM delivery_zones 
       WHERE restaurant_id = $1 AND is_active = true
       ORDER BY zone_name`,
      [restaurantId],
      'get_delivery_zones'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo zonas de entrega:', error);
    throw error;
  }
};

/**
 * Crea una zona de entrega
 * @param {Object} zoneData - Datos de la zona
 * @returns {Promise<Object>} Zona creada
 */
const createDeliveryZone = async (zoneData) => {
  const {
    restaurantId,
    zoneName,
    postalCodes = [],
    neighborhoods = [],
    extraFee = 0.00
  } = zoneData;

  try {
    const result = await query(
      `INSERT INTO delivery_zones (
        id, restaurant_id, zone_name, postal_codes, 
        neighborhoods, extra_fee, is_active, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, true, NOW())
      RETURNING *`,
      [
        uuidv4(),
        restaurantId,
        zoneName,
        postalCodes,
        neighborhoods,
        extraFee
      ],
      'create_delivery_zone'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando zona de entrega:', error);
    throw error;
  }
};

/**
 * Verifica si una dirección está en zona de entrega
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} address - Dirección a verificar
 * @returns {Promise<Object|null>} Zona encontrada o null
 */
const findDeliveryZoneForAddress = async (restaurantId, address) => {
  const { postalCode, neighborhood } = address;

  try {
    const result = await query(
      `SELECT * FROM delivery_zones
       WHERE restaurant_id = $1 
         AND is_active = true
         AND (
           $2 = ANY(postal_codes) 
           OR $3 ILIKE ANY(
             SELECT '%' || unnest(neighborhoods) || '%'
           )
         )
       ORDER BY extra_fee ASC
       LIMIT 1`,
      [restaurantId, postalCode, neighborhood],
      'find_delivery_zone'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando zona de entrega:', error);
    throw error;
  }
};

/**
 * Obtiene configuración de WhatsApp de un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Object|null>} Configuración de WhatsApp
 */
const getWhatsAppConfig = async (restaurantId) => {
  try {
    const result = await query(
      `SELECT 
        whatsapp_phone_id,
        whatsapp_token,
        twilio_phone_number,
        CASE 
          WHEN whatsapp_phone_id IS NOT NULL AND whatsapp_token IS NOT NULL THEN 'meta'
          WHEN twilio_phone_number IS NOT NULL THEN 'twilio'
          ELSE null
        END as provider
      FROM restaurants 
      WHERE id = $1`,
      [restaurantId],
      'get_whatsapp_config'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error obteniendo configuración de WhatsApp:', error);
    throw error;
  }
};

/**
 * Actualiza configuración de WhatsApp
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} config - Nueva configuración
 * @returns {Promise<Object>} Restaurante actualizado
 */
const updateWhatsAppConfig = async (restaurantId, config) => {
  const {
    whatsappPhoneId = null,
    whatsappToken = null,
    twilioPhoneNumber = null
  } = config;

  try {
    const result = await query(
      `UPDATE restaurants 
       SET whatsapp_phone_id = $1,
           whatsapp_token = $2,
           twilio_phone_number = $3,
           updated_at = NOW()
       WHERE id = $4
       RETURNING *`,
      [whatsappPhoneId, whatsappToken, twilioPhoneNumber, restaurantId],
      'update_whatsapp_config'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando configuración de WhatsApp:', error);
    throw error;
  }
};

/**
 * Obtiene restaurantes activos con sus configuraciones básicas
 * @returns {Promise<Array>} Lista de restaurantes activos
 */
const getActiveRestaurants = async () => {
  try {
    const result = await query(
      `SELECT 
        id, name, slug, phone, 
        opens_at, closes_at, is_active,
        whatsapp_phone_id, twilio_phone_number,
        CASE 
          WHEN is_active = false THEN 'inactive'
          WHEN CURRENT_TIME BETWEEN opens_at AND closes_at THEN 'open'
          ELSE 'closed'
        END as current_status
      FROM restaurants 
      WHERE is_active = true
      ORDER BY name`,
      [],
      'get_active_restaurants'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo restaurantes activos:', error);
    throw error;
  }
};

/**
 * Marca un restaurante como activo/inactivo
 * @param {string} restaurantId - ID del restaurante
 * @param {boolean} isActive - Nuevo estado
 * @returns {Promise<Object>} Restaurante actualizado
 */
const toggleRestaurantStatus = async (restaurantId, isActive) => {
  try {
    const result = await query(
      `UPDATE restaurants 
       SET is_active = $1, updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [isActive, restaurantId],
      'toggle_restaurant_status'
    );

    logger.info('Estado de restaurante actualizado', {
      restaurantId,
      newStatus: isActive ? 'active' : 'inactive'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estado del restaurante:', error);
    throw error;
  }
};

module.exports = {
  findBySlug,
  findById,
  createRestaurant,
  updateRestaurant,
  getRestaurantsPaginated,
  isSlugAvailable,
  getRestaurantStats,
  getDeliveryZones,
  createDeliveryZone,
  findDeliveryZoneForAddress,
  getWhatsAppConfig,
  updateWhatsAppConfig,
  getActiveRestaurants,
  toggleRestaurantStatus
};


================================================
File: docs/API.md
================================================



================================================
File: docs/SETUP.md
================================================




================================================
File: src/config/claude.js
================================================
const Anthropic = require('@anthropic-ai/sdk');
const logger = require('../utils/logger');

// ============================================
// CONFIGURACIÓN DE CLAUDE
// ============================================

const claudeConfig = {
  apiKey: process.env.CLAUDE_API_KEY,
  model: process.env.CLAUDE_MODEL || 'claude-3-5-sonnet-20241022',
  maxTokens: parseInt(process.env.CLAUDE_MAX_TOKENS) || 500,
  temperature: parseFloat(process.env.CLAUDE_TEMPERATURE) || 0.7,
};

// Validar configuración
if (!claudeConfig.apiKey) {
  logger.error('❌ CLAUDE_API_KEY no está configurada en las variables de entorno');
  process.exit(1);
}

// Inicializar cliente de Anthropic
const anthropic = new Anthropic({
  apiKey: claudeConfig.apiKey,
});

// ============================================
// PROMPTS BASE DEL SISTEMA
// ============================================

const SYSTEM_PROMPTS = {
  BASE: `Eres un asistente virtual profesional y amigable de un restaurante. Tu objetivo es ayudar a los clientes a realizar pedidos de comida de manera eficiente y natural.

CARACTERÍSTICAS DE TU PERSONALIDAD:
- Amigable, paciente y servicial
- Usas emojis moderadamente para hacer la conversación más cálida
- Eres claro y conciso en tus respuestas
- Siempre confirmas los detalles importantes
- Ofreces sugerencias útiles sin ser invasivo

REGLAS IMPORTANTES:
1. SIEMPRE valida las restricciones de productos (aderezos, extras, etc.)
2. Confirma cada modificación al pedido antes de aplicarla
3. Calcula correctamente los totales incluyendo extras
4. Al final, solicita dirección completa: calle, número, colonia, referencias
5. Mantén el contexto de toda la conversación
6. Si no entiendes algo, pide aclaración amablemente
7. Ofrece alternativas cuando algo no esté disponible`,

  GREETING: `Saluda al cliente de manera cálida y presenta el menú disponible de forma organizada por categorías.`,
  
  ORDERING: `Ayuda al cliente a construir su pedido paso a paso, validando restricciones y calculando totales correctamente.`,
  
  CONFIRMING: `Confirma todos los detalles del pedido y solicita la dirección de entrega completa.`,
  
  ERROR_HANDLING: `Si ocurre un error o no entiendes algo, pide amablemente al cliente que repita o aclare su solicitud.`
};

// ============================================
// FUNCIONES PRINCIPALES
// ============================================

/**
 * Construye el contexto completo para Claude
 * @param {Object} restaurant - Datos del restaurante
 * @param {Object} orderState - Estado actual del pedido
 * @param {Array} conversationHistory - Historial de la conversación
 * @param {string} currentStep - Paso actual de la conversación
 * @returns {string} Contexto formateado para Claude
 */
const buildContext = (restaurant, orderState = null, conversationHistory = [], currentStep = 'greeting') => {
  const context = `${SYSTEM_PROMPTS.BASE}

INFORMACIÓN DEL RESTAURANTE:
Nombre: ${restaurant.name}
Horarios: ${restaurant.opens_at} - ${restaurant.closes_at}
Tiempo de entrega: ${restaurant.delivery_time_min}-${restaurant.delivery_time_max} minutos
${restaurant.delivery_fee > 0 ? `Costo de envío: $${restaurant.delivery_fee}` : 'Envío gratuito'}
${restaurant.minimum_order > 0 ? `Pedido mínimo: $${restaurant.minimum_order}` : ''}

MENÚ DISPONIBLE:
${formatMenu(restaurant.menu || [])}

${restaurant.business_rules && restaurant.business_rules.length > 0 ? 
`REGLAS IMPORTANTES:
${formatBusinessRules(restaurant.business_rules)}` : ''}

ESTADO ACTUAL DEL PEDIDO:
${orderState ? formatOrderState(orderState) : 'Carrito vacío - El cliente aún no ha pedido nada'}

${conversationHistory.length > 0 ? 
`HISTORIAL DE CONVERSACIÓN RECIENTE:
${formatConversationHistory(conversationHistory)}` : ''}

PASO ACTUAL: ${currentStep.toUpperCase()}
${SYSTEM_PROMPTS[currentStep.toUpperCase()] || SYSTEM_PROMPTS.BASE}

INSTRUCCIONES FINALES:
- Responde en español mexicano
- Máximo 3 párrafos por respuesta
- Usa emojis con moderación (1-2 por mensaje)
- Siempre incluye el total actualizado cuando hay cambios en el pedido
- Si el pedido está completo, solicita: calle, número, colonia y referencias`;

  return context;
};

/**
 * Formatea el menú para el contexto de Claude
 * @param {Array} menuItems - Items del menú
 * @returns {string} Menú formateado
 */
const formatMenu = (menuItems) => {
  if (!menuItems || menuItems.length === 0) {
    return 'No hay productos disponibles en este momento.';
  }

  const categorizedMenu = {};
  
  menuItems.forEach(item => {
    const category = item.category_name || 'Otros';
    if (!categorizedMenu[category]) {
      categorizedMenu[category] = [];
    }
    categorizedMenu[category].push(item);
  });

  let formattedMenu = '';
  
  Object.keys(categorizedMenu).forEach(category => {
    formattedMenu += `\n${category.toUpperCase()}:\n`;
    categorizedMenu[category].forEach(item => {
      formattedMenu += `• ${item.name} - $${item.price}`;
      if (item.description) {
        formattedMenu += ` (${item.description})`;
      }
      formattedMenu += '\n';
    });
  });

  return formattedMenu;
};

/**
 * Formatea las reglas de negocio para el contexto
 * @param {Array} businessRules - Reglas de negocio
 * @returns {string} Reglas formateadas
 */
const formatBusinessRules = (businessRules) => {
  if (!businessRules || businessRules.length === 0) {
    return '';
  }

  return businessRules.map(rule => {
    return `• ${rule.rule_name}: ${rule.ai_message_template || JSON.stringify(rule.rule_config)}`;
  }).join('\n');
};

/**
 * Formatea el estado actual del pedido
 * @param {Object} orderState - Estado del pedido
 * @returns {string} Estado formateado
 */
const formatOrderState = (orderState) => {
  if (!orderState || !orderState.items || orderState.items.length === 0) {
    return 'Carrito vacío';
  }

  let formatted = 'Pedido actual:\n';
  
  orderState.items.forEach((item, index) => {
    formatted += `${index + 1}. ${item.name} (${item.quantity}x) - $${item.item_total}\n`;
    
    if (item.customizations && item.customizations.length > 0) {
      item.customizations.forEach(custom => {
        formatted += `   - ${custom.name}${custom.extra_cost > 0 ? ` (+$${custom.extra_cost})` : ''}\n`;
      });
    }
    
    if (item.notes) {
      formatted += `   Notas: ${item.notes}\n`;
    }
  });
  
  formatted += `\nSubtotal: $${orderState.subtotal || 0}`;
  if (orderState.delivery_fee > 0) {
    formatted += `\nEnvío: $${orderState.delivery_fee}`;
  }
  formatted += `\nTOTAL: $${orderState.total || 0}`;
  
  return formatted;
};

/**
 * Formatea el historial de conversación
 * @param {Array} history - Historial de mensajes
 * @returns {string} Historial formateado
 */
const formatConversationHistory = (history) => {
  return history.slice(-6).map(msg => {
    return `${msg.role === 'user' ? 'Cliente' : 'Asistente'}: ${msg.content}`;
  }).join('\n');
};

// ============================================
// FUNCIÓN PRINCIPAL PARA LLAMAR A CLAUDE
// ============================================

/**
 * Obtiene respuesta de Claude AI
 * @param {Object} contextData - Datos para construir el contexto
 * @param {string} userMessage - Mensaje del usuario
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<string>} Respuesta de Claude
 */
const getClaude3Response = async (contextData, userMessage, options = {}) => {
  const startTime = Date.now();
  
  try {
    const {
      restaurant,
      orderState,
      conversationHistory,
      currentStep = 'greeting'
    } = contextData;

    // Construir contexto
    const systemContext = buildContext(restaurant, orderState, conversationHistory, currentStep);
    
    // Preparar mensajes
    const messages = [
      {
        role: 'user',
        content: userMessage
      }
    ];

    // Configuración de la llamada
    const requestConfig = {
      model: options.model || claudeConfig.model,
      max_tokens: options.maxTokens || claudeConfig.maxTokens,
      temperature: options.temperature || claudeConfig.temperature,
      system: systemContext,
      messages: messages
    };

    logger.debug('Llamando a Claude API', {
      model: requestConfig.model,
      maxTokens: requestConfig.max_tokens,
      temperature: requestConfig.temperature,
      userMessageLength: userMessage.length,
      contextLength: systemContext.length
    });

    // Llamar a Claude
    const response = await anthropic.messages.create(requestConfig);
    
    const duration = Date.now() - startTime;
    const responseText = response.content[0].text;

    logger.info('Respuesta de Claude recibida', {
      duration: `${duration}ms`,
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens,
      totalTokens: response.usage.input_tokens + response.usage.output_tokens,
      responseLength: responseText.length
    });

    return {
      response: responseText,
      usage: response.usage,
      model: response.model,
      duration
    };

  } catch (error) {
    const duration = Date.now() - startTime;
    
    logger.error('Error al llamar a Claude API', {
      duration: `${duration}ms`,
      error: error.message,
      userMessage: userMessage.substring(0, 100),
      errorType: error.constructor.name
    });

    // Retornar respuesta de fallback
    return {
      response: getFallbackResponse(userMessage),
      usage: null,
      model: 'fallback',
      duration,
      error: error.message
    };
  }
};

/**
 * Respuesta de fallback cuando Claude no está disponible
 * @param {string} userMessage - Mensaje del usuario
 * @returns {string} Respuesta de fallback
 */
const getFallbackResponse = (userMessage) => {
  const fallbackResponses = [
    'Disculpa, estoy teniendo problemas técnicos en este momento. ¿Podrías repetir tu mensaje?',
    'Lo siento, no pude procesar tu solicitud. ¿Puedes intentar de nuevo?',
    'Estoy experimentando dificultades técnicas. Por favor, intenta nuevamente en unos momentos.',
    'Disculpa la inconveniencia. ¿Podrías volver a enviar tu mensaje?'
  ];
  
  return fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
};

/**
 * Verifica si Claude está disponible
 * @returns {Promise<boolean>} True si Claude responde
 */
const testClaudeConnection = async () => {
  try {
    const response = await anthropic.messages.create({
      model: claudeConfig.model,
      max_tokens: 50,
      temperature: 0,
      system: 'Responde solo con "OK" para confirmar que funciona.',
      messages: [{ role: 'user', content: 'Test' }]
    });

    const isWorking = response.content[0].text.trim().toUpperCase() === 'OK';
    
    logger.info('Test de Claude completado', { 
      isWorking,
      model: response.model,
      usage: response.usage
    });
    
    return isWorking;
    
  } catch (error) {
    logger.error('Error en test de Claude:', error);
    return false;
  }
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  anthropic,
  claudeConfig,
  getClaude3Response,
  buildContext,
  testClaudeConnection,
  SYSTEM_PROMPTS
};


================================================
File: src/config/database.js
================================================
const { Pool } = require('pg');
const logger = require('../utils/logger');

// ============================================
// CONFIGURACIÓN DEL POOL DE CONEXIONES
// ============================================

const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT) || 5432,
  database: process.env.DB_NAME || 'ChatBotProject',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD,
  
  // Configuración del pool
  min: parseInt(process.env.DB_POOL_MIN) || 2,
  max: parseInt(process.env.DB_POOL_MAX) || 10,
  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT) || 10000,
  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 2000,
  
  // SSL configuración
  ssl: process.env.DB_SSL === 'true' ? {
    rejectUnauthorized: false
  } : false,
  
  // Configuración adicional
  statement_timeout: 30000, // 30 segundos
  query_timeout: 30000,
  application_name: 'ChatBot_Chingon',
};

// Crear pool de conexiones
const pool = new Pool(dbConfig);

// ============================================
// EVENTOS DEL POOL
// ============================================

pool.on('connect', (client) => {
  logger.debug('Nueva conexión establecida con la base de datos');
});

pool.on('acquire', (client) => {
  logger.debug('Cliente adquirido del pool');
});

pool.on('remove', (client) => {
  logger.debug('Cliente removido del pool');
});

pool.on('error', (err, client) => {
  logger.error('Error inesperado en cliente del pool:', err);
});

// ============================================
// FUNCIÓN PARA EJECUTAR QUERIES
// ============================================

/**
 * Ejecuta una query SQL con parámetros
 * @param {string} text - Query SQL
 * @param {Array} params - Parámetros de la query
 * @param {string} description - Descripción para logging
 * @returns {Promise<Object>} Resultado de la query
 */
const query = async (text, params = [], description = '') => {
  const start = Date.now();
  
  try {
    logger.debug('Ejecutando query', { 
      description, 
      query: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
      paramsCount: params.length 
    });
    
    const result = await pool.query(text, params);
    const duration = Date.now() - start;
    
    logger.debug('Query ejecutada exitosamente', {
      description,
      duration: `${duration}ms`,
      rowCount: result.rowCount
    });
    
    return result;
    
  } catch (error) {
    const duration = Date.now() - start;
    
    logger.error('Error en query SQL', {
      description,
      duration: `${duration}ms`,
      error: error.message,
      query: text,
      params: params
    });
    
    throw error;
  }
};

// ============================================
// TRANSACCIONES
// ============================================

/**
 * Ejecuta múltiples queries en una transacción
 * @param {Function} callback - Función que recibe el cliente y ejecuta queries
 * @returns {Promise<any>} Resultado de la transacción
 */
const transaction = async (callback) => {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    logger.debug('Transacción iniciada');
    
    const result = await callback(client);
    
    await client.query('COMMIT');
    logger.debug('Transacción completada exitosamente');
    
    return result;
    
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error('Transacción revertida debido a error:', error);
    throw error;
    
  } finally {
    client.release();
  }
};

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Obtiene información del estado del pool
 * @returns {Object} Estadísticas del pool
 */
const getPoolInfo = () => {
  return {
    totalCount: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount,
    config: {
      max: pool.options.max,
      min: pool.options.min,
      idleTimeoutMillis: pool.options.idleTimeoutMillis
    }
  };
};

/**
 * Prueba la conexión a la base de datos
 * @returns {Promise<boolean>} True si la conexión es exitosa
 */
const testConnection = async () => {
  try {
    const result = await query('SELECT NOW() as current_time, version() as version', [], 'test_connection');
    
    logger.info('Conexión a base de datos verificada', {
      timestamp: result.rows[0].current_time,
      version: result.rows[0].version.split(' ')[0] + ' ' + result.rows[0].version.split(' ')[1]
    });
    
    return true;
    
  } catch (error) {
    logger.error('Error al probar conexión a base de datos:', error);
    throw error;
  }
};

/**
 * Verifica si existe una tabla
 * @param {string} tableName - Nombre de la tabla
 * @returns {Promise<boolean>} True si la tabla existe
 */
const tableExists = async (tableName) => {
  try {
    const result = await query(
      `SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )`,
      [tableName],
      `check_table_exists_${tableName}`
    );
    
    return result.rows[0].exists;
    
  } catch (error) {
    logger.error(`Error al verificar existencia de tabla ${tableName}:`, error);
    return false;
  }
};

/**
 * Ejecuta el script de migración inicial
 * @returns {Promise<void>}
 */
const runMigrations = async () => {
  const fs = require('fs');
  const path = require('path');
  
  try {
    const migrationFile = path.join(__dirname, '../../database/migrations/001_initial_schema.sql');
    
    if (!fs.existsSync(migrationFile)) {
      logger.warn('Archivo de migración no encontrado:', migrationFile);
      return;
    }
    
    const migrationSQL = fs.readFileSync(migrationFile, 'utf8');
    
    await transaction(async (client) => {
      logger.info('Ejecutando migraciones...');
      await client.query(migrationSQL);
      logger.info('✅ Migraciones ejecutadas exitosamente');
    });
    
  } catch (error) {
    logger.error('❌ Error al ejecutar migraciones:', error);
    throw error;
  }
};

/**
 * Función para limpiar conversaciones inactivas
 * @returns {Promise<number>} Número de conversaciones limpiadas
 */
const cleanInactiveConversations = async () => {
  try {
    const result = await query(
      `UPDATE conversations 
       SET status = 'abandoned',
           updated_at = CURRENT_TIMESTAMP
       WHERE status = 'active' 
       AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '2 hours'`,
      [],
      'clean_inactive_conversations'
    );
    
    return result.rowCount;
    
  } catch (error) {
    logger.error('Error al limpiar conversaciones inactivas:', error);
    throw error;
  }
};

/**
 * Cierra todas las conexiones del pool
 * @returns {Promise<void>}
 */
const closePool = async () => {
  try {
    await pool.end();
    logger.info('Pool de conexiones cerrado exitosamente');
  } catch (error) {
    logger.error('Error al cerrar pool de conexiones:', error);
    throw error;
  }
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  pool,
  query,
  transaction,
  getPoolInfo,
  testDatabaseConnection: testConnection,
  tableExists,
  runMigrations,
  cleanInactiveConversations,
  closePool
};


================================================
File: src/config/whatsapp.js
================================================
const twilio = require('twilio');
const axios = require('axios');
const logger = require('../utils/logger');

// ============================================
// CONFIGURACIÓN DE TWILIO WHATSAPP
// ============================================

const twilioConfig = {
  accountSid: process.env.TWILIO_ACCOUNT_SID,
  authToken: process.env.TWILIO_AUTH_TOKEN,
  phoneNumber: process.env.TWILIO_PHONE_NUMBER,
};

// Configuración de Meta WhatsApp Business API
const metaConfig = {
  accessToken: process.env.META_WHATSAPP_TOKEN,
  phoneNumberId: process.env.META_WHATSAPP_PHONE_NUMBER_ID,
  verifyToken: process.env.META_WEBHOOK_VERIFY_TOKEN,
  apiVersion: 'v18.0',
  baseUrl: 'https://graph.facebook.com'
};

// Inicializar cliente de Twilio si está configurado
let twilioClient = null;

if (twilioConfig.accountSid && twilioConfig.authToken) {
  twilioClient = twilio(twilioConfig.accountSid, twilioConfig.authToken);
  logger.info('✅ Cliente Twilio inicializado');
}

// ============================================
// UTILIDADES DE FORMATEO
// ============================================

/**
 * Formatea un número de teléfono a formato internacional
 * @param {string} phoneNumber - Número de teléfono
 * @returns {string} Número formateado
 */
const formatPhoneNumber = (phoneNumber) => {
  // Remover espacios, guiones y paréntesis
  let cleaned = phoneNumber.replace(/[\s\-\(\)]/g, '');
  
  // Si no empieza con +, agregar código de país de México
  if (!cleaned.startsWith('+')) {
    if (cleaned.startsWith('52')) {
      cleaned = '+' + cleaned;
    } else if (cleaned.length === 10) {
      cleaned = '+52' + cleaned;
    } else {
      cleaned = '+' + cleaned;
    }
  }
  
  return cleaned;
};

/**
 * Valida si un número de WhatsApp es válido
 * @param {string} phoneNumber - Número a validar
 * @returns {boolean} True si es válido
 */
const isValidWhatsAppNumber = (phoneNumber) => {
  const formatted = formatPhoneNumber(phoneNumber);
  const whatsappRegex = /^\+[1-9]\d{1,14}$/;
  return whatsappRegex.test(formatted);
};

// ============================================
// FUNCIONES DE TWILIO WHATSAPP
// ============================================

/**
 * Envía un mensaje via Twilio WhatsApp
 * @param {string} to - Número de teléfono destino
 * @param {string} message - Mensaje a enviar
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Object>} Resultado del envío
 */
const sendTwilioMessage = async (to, message, options = {}) => {
  if (!twilioClient) {
    throw new Error('Cliente Twilio no está configurado');
  }

  try {
    const toFormatted = formatPhoneNumber(to);
    const fromFormatted = `whatsapp:${twilioConfig.phoneNumber}`;
    const toWhatsApp = `whatsapp:${toFormatted}`;

    logger.debug('Enviando mensaje via Twilio', {
      to: toFormatted,
      messageLength: message.length,
      mediaUrl: options.mediaUrl ? 'included' : 'none'
    });

    const messageData = {
      body: message,
      from: fromFormatted,
      to: toWhatsApp,
    };

    // Agregar media si está presente
    if (options.mediaUrl) {
      messageData.mediaUrl = [options.mediaUrl];
    }

    const result = await twilioClient.messages.create(messageData);

    logger.info('Mensaje enviado exitosamente via Twilio', {
      sid: result.sid,
      to: toFormatted,
      status: result.status,
      direction: result.direction
    });

    return {
      success: true,
      messageId: result.sid,
      status: result.status,
      provider: 'twilio'
    };

  } catch (error) {
    logger.error('Error enviando mensaje via Twilio', {
      to,
      error: error.message,
      code: error.code,
      moreInfo: error.moreInfo
    });

    throw error;
  }
};

// ============================================
// FUNCIONES DE META WHATSAPP BUSINESS API
// ============================================

/**
 * Envía un mensaje via Meta WhatsApp Business API
 * @param {string} to - Número de teléfono destino
 * @param {string} message - Mensaje a enviar
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Object>} Resultado del envío
 */
const sendMetaMessage = async (to, message, options = {}) => {
  if (!metaConfig.accessToken || !metaConfig.phoneNumberId) {
    throw new Error('Meta WhatsApp API no está configurada');
  }

  try {
    const toFormatted = formatPhoneNumber(to).replace('+', '');
    const url = `${metaConfig.baseUrl}/${metaConfig.apiVersion}/${metaConfig.phoneNumberId}/messages`;

    const messageData = {
      messaging_product: 'whatsapp',
      to: toFormatted,
      type: 'text',
      text: {
        body: message
      }
    };

    // Para mensajes con media
    if (options.mediaUrl) {
      messageData.type = 'image';
      messageData.image = {
        link: options.mediaUrl
      };
      delete messageData.text;
    }

    logger.debug('Enviando mensaje via Meta WhatsApp', {
      to: toFormatted,
      messageLength: message.length,
      type: messageData.type
    });

    const response = await axios.post(url, messageData, {
      headers: {
        'Authorization': `Bearer ${metaConfig.accessToken}`,
        'Content-Type': 'application/json'
      }
    });

    logger.info('Mensaje enviado exitosamente via Meta WhatsApp', {
      messageId: response.data.messages[0].id,
      to: toFormatted,
      status: 'sent'
    });

    return {
      success: true,
      messageId: response.data.messages[0].id,
      status: 'sent',
      provider: 'meta'
    };

  } catch (error) {
    logger.error('Error enviando mensaje via Meta WhatsApp', {
      to,
      error: error.message,
      status: error.response?.status,
      data: error.response?.data
    });

    throw error;
  }
};

// ============================================
// FUNCIÓN PRINCIPAL DE ENVÍO
// ============================================

/**
 * Envía un mensaje de WhatsApp usando el proveedor disponible
 * @param {string} to - Número de teléfono destino
 * @param {string} message - Mensaje a enviar
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Object>} Resultado del envío
 */
const sendWhatsAppMessage = async (to, message, options = {}) => {
  if (!isValidWhatsAppNumber(to)) {
    throw new Error('Número de WhatsApp inválido');
  }

  // Truncar mensaje si es muy largo
  const maxLength = 4096;
  const truncatedMessage = message.length > maxLength 
    ? message.substring(0, maxLength - 3) + '...'
    : message;

  try {
    // Intentar con Meta WhatsApp primero, luego Twilio
    if (metaConfig.accessToken && metaConfig.phoneNumberId) {
      return await sendMetaMessage(to, truncatedMessage, options);
    } else if (twilioClient) {
      return await sendTwilioMessage(to, truncatedMessage, options);
    } else {
      throw new Error('Ningún proveedor de WhatsApp está configurado');
    }

  } catch (error) {
    logger.error('Error enviando mensaje de WhatsApp', {
      to,
      provider: metaConfig.accessToken ? 'meta' : 'twilio',
      error: error.message
    });

    throw error;
  }
};

// ============================================
// VALIDACIÓN DE WEBHOOKS
// ============================================

/**
 * Valida webhook de Twilio
 * @param {string} signature - Firma del webhook
 * @param {string} url - URL del webhook
 * @param {Object} params - Parámetros del webhook
 * @returns {boolean} True si es válido
 */
const validateTwilioWebhook = (signature, url, params) => {
  if (!twilioClient) {
    return false;
  }

  try {
    return twilio.validateRequest(
      twilioConfig.authToken,
      signature,
      url,
      params
    );
  } catch (error) {
    logger.error('Error validando webhook de Twilio:', error);
    return false;
  }
};

/**
 * Valida webhook de Meta WhatsApp
 * @param {string} mode - Modo de verificación
 * @param {string} token - Token de verificación
 * @param {string} challenge - Challenge de verificación
 * @returns {string|boolean} Challenge si es válido, false si no
 */
const validateMetaWebhook = (mode, token, challenge) => {
  if (mode === 'subscribe' && token === metaConfig.verifyToken) {
    logger.info('Webhook de Meta WhatsApp verificado exitosamente');
    return challenge;
  }
  
  logger.warn('Intento de verificación de webhook inválido', { mode, token });
  return false;
};

// ============================================
// PROCESAMIENTO DE MENSAJES ENTRANTES
// ============================================

/**
 * Procesa mensaje entrante de Twilio
 * @param {Object} webhookData - Datos del webhook
 * @returns {Object} Mensaje procesado
 */
const processTwilioIncomingMessage = (webhookData) => {
  return {
    messageId: webhookData.MessageSid,
    from: webhookData.From.replace('whatsapp:', ''),
    to: webhookData.To.replace('whatsapp:', ''),
    body: webhookData.Body || '',
    timestamp: new Date(),
    provider: 'twilio',
    mediaUrl: webhookData.MediaUrl0 || null,
    mediaType: webhookData.MediaContentType0 || null
  };
};

/**
 * Procesa mensaje entrante de Meta WhatsApp
 * @param {Object} webhookData - Datos del webhook
 * @returns {Object} Mensaje procesado
 */
const processMetaIncomingMessage = (webhookData) => {
  const entry = webhookData.entry[0];
  const changes = entry.changes[0];
  const value = changes.value;
  
  if (!value.messages || value.messages.length === 0) {
    return null;
  }

  const message = value.messages[0];
  
  return {
    messageId: message.id,
    from: '+' + message.from,
    to: '+' + value.metadata.phone_number_id,
    body: message.text?.body || '',
    timestamp: new Date(parseInt(message.timestamp) * 1000),
    provider: 'meta',
    mediaUrl: message.image?.id || null,
    mediaType: message.type
  };
};

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Verifica el estado de los servicios de WhatsApp
 * @returns {Promise<Object>} Estado de los servicios
 */
const checkWhatsAppStatus = async () => {
  const status = {
    twilio: false,
    meta: false,
    activeProvider: null
  };

  // Verificar Twilio
  if (twilioClient) {
    try {
      await twilioClient.api.accounts(twilioConfig.accountSid).fetch();
      status.twilio = true;
    } catch (error) {
      logger.error('Error verificando estado de Twilio:', error);
    }
  }

  // Verificar Meta
  if (metaConfig.accessToken) {
    try {
      const url = `${metaConfig.baseUrl}/${metaConfig.apiVersion}/${metaConfig.phoneNumberId}`;
      await axios.get(url, {
        headers: { 'Authorization': `Bearer ${metaConfig.accessToken}` }
      });
      status.meta = true;
    } catch (error) {
      logger.error('Error verificando estado de Meta WhatsApp:', error);
    }
  }

  // Determinar proveedor activo
  status.activeProvider = status.meta ? 'meta' : (status.twilio ? 'twilio' : null);

  return status;
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Configuración
  twilioConfig,
  metaConfig,
  twilioClient,
  
  // Funciones principales
  sendWhatsAppMessage,
  sendTwilioMessage,
  sendMetaMessage,
  
  // Validación
  validateTwilioWebhook,
  validateMetaWebhook,
  isValidWhatsAppNumber,
  
  // Procesamiento
  processTwilioIncomingMessage,
  processMetaIncomingMessage,
  
  // Utilidades
  formatPhoneNumber,
  checkWhatsAppStatus
};


================================================
File: src/controllers/authController.js
================================================
const User = require('../models/User');
const AuthMiddleware = require('../middleware/auth');
const logger = require('../utils/logger');
const { AuthenticationError, ValidationError } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE AUTENTICACIÓN
// ============================================

class AuthController {
  /**
   * Login de usuario
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static async login(req, res, next) {
    try {
      const { email, password } = req.body;

      // Validación básica
      if (!email || !password) {
        throw new ValidationError('Email y contraseña son requeridos');
      }

      // Validar formato de email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        throw new ValidationError('Formato de email inválido');
      }

      // Buscar usuario
      const user = await User.findByEmailWithProfile(email.toLowerCase().trim());
      
      if (!user) {
        logger.warn('Intento de login con email inexistente', { 
          email: email.substring(0, 5) + '****',
          ip: req.ip 
        });
        throw new AuthenticationError('Credenciales inválidas');
      }

      // Verificar si el usuario está activo
      if (!user.is_active) {
        logger.warn('Intento de login con usuario inactivo', { 
          userId: user.id,
          ip: req.ip 
        });
        throw new AuthenticationError('Cuenta desactivada');
      }

      // Verificar contraseña
      const isPasswordValid = await User.verifyPassword(password, user.password_hash);
      
      if (!isPasswordValid) {
        logger.warn('Intento de login con contraseña incorrecta', { 
          userId: user.id,
          ip: req.ip 
        });
        throw new AuthenticationError('Credenciales inválidas');
      }

      // Generar tokens
      const tokenPayload = {
        sub: user.id,
        email: user.email,
        role: user.profile.role.name,
        restaurantId: user.profile.restaurant_id,
        permissions: user.profile.role.permissions || []
      };

      const tokens = AuthMiddleware.generateTokenPair(tokenPayload);

      // Actualizar último login
      await User.updateLastLogin(user.id);

      // Respuesta exitosa
      const responseData = {
        user: {
          id: user.id,
          email: user.email,
          first_name: user.first_name,
          last_name: user.last_name,
          profile: {
            role: user.profile.role.name,
            role_display_name: user.profile.role.display_name,
            permissions: user.profile.role.permissions,
            restaurant: user.profile.restaurant,
            phone: user.profile.phone,
            avatar_url: user.profile.avatar_url
          }
        },
        tokens
      };

      logger.info('Login exitoso', { 
        userId: user.id,
        role: user.profile.role.name,
        restaurant: user.profile.restaurant?.name || 'Sistema',
        ip: req.ip 
      });

      res.json({
        success: true,
        message: 'Login exitoso',
        data: responseData
      });

    } catch (error) {
      next(error);
    }
  }

  /**
   * Refresh token
   * @param {Object} req - Request object  
   * @param {Object} res - Response object
   */
  static async refreshToken(req, res, next) {
    try {
      // El middleware ya procesó el refresh token y generó uno nuevo
      const newTokens = {
        access_token: req.newToken,
        refresh_token: req.body.refresh_token, // Mantener el mismo refresh token
        token_type: 'Bearer',
        expires_in: 3600
      };

      logger.info('Token refrescado exitosamente', { 
        userId: req.user.id 
      });

      res.json({
        success: true,
        message: 'Token refrescado exitosamente',
        data: { tokens: newTokens }
      });

    } catch (error) {
      next(error);
    }
  }

  /**
   * Obtiene información del usuario actual
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static async getCurrentUser(req, res, next) {
    try {
      const user = await User.findByEmailWithProfile(req.user.email);
      
      if (!user) {
        throw new AuthenticationError('Usuario no encontrado');
      }

      const userData = {
        id: user.id,
        email: user.email,
        first_name: user.first_name,
        last_name: user.last_name,
        profile: {
          role: user.profile.role.name,
          role_display_name: user.profile.role.display_name,
          permissions: user.profile.role.permissions,
          restaurant: user.profile.restaurant,
          phone: user.profile.phone,
          avatar_url: user.profile.avatar_url,
          settings: user.profile.settings
        }
      };

      res.json({
        success: true,
        data: { user: userData }
      });

    } catch (error) {
      next(error);
    }
  }
}

module.exports = AuthController;


================================================
File: src/controllers/conversationController.js
================================================
const Conversation = require('../models/Conversation');
const ConversationService = require('../services/conversationService');
const ValidationService = require('../services/validationService');
const WhatsAppService = require('../services/whatsappService');
const logger = require('../utils/logger');
const { CONVERSATION_STATUS, CONVERSATION_STEPS } = require('../utils/constants');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE CONVERSACIONES
// ============================================

class ConversationController {

  /**
   * Obtiene conversaciones de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversations = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inválido'
        });
      }

      // Validar parámetros de paginación
      const paginationValidation = ValidationService.validatePaginationParams(req.query);
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error
        });
      }

      const { page, limit } = paginationValidation.data;

      const options = {
        page,
        limit,
        status: req.query.status,
        customerPhone: req.query.customer_phone
      };

      // Obtener conversaciones
      const result = await Conversation.getRecent(restaurantId, options);

      logger.info('Conversaciones obtenidas', {
        restaurantId,
        page,
        limit,
        totalItems: result.pagination.total_items
      });

      res.json({
        success: true,
        data: result.conversations,
        pagination: result.pagination
      });

    } catch (error) {
      logger.error('Error obteniendo conversaciones:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo conversaciones'
      });
    }
  });

  /**
   * Obtiene una conversación específica por ID
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversationById = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversación inválido'
        });
      }

      const conversation = await Conversation.findById(conversationId);

      if (!conversation) {
        return res.status(404).json({
          success: false,
          error: 'Conversación no encontrada'
        });
      }

      // Verificar que la conversación pertenece al restaurante si está especificado
      if (req.restaurant && conversation.restaurant_id !== req.restaurant.id) {
        return res.status(404).json({
          success: false,
          error: 'Conversación no encontrada'
        });
      }

      // Parsear datos JSON para la respuesta
      let orderData = {};
      let aiContext = [];

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversación:', e);
      }

      const response = {
        ...conversation,
        order_data: orderData,
        ai_context: aiContext
      };

      logger.info('Conversación obtenida por ID', {
        conversationId,
        status: conversation.status,
        customerPhone: conversation.customer_phone?.substring(0, 8) + '****'
      });

      res.json({
        success: true,
        data: response
      });

    } catch (error) {
      logger.error('Error obteniendo conversación por ID:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo conversación'
      });
    }
  });

  /**
   * Obtiene conversación activa de un cliente
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getActiveConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id || req.params.restaurantId;

      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Teléfono del cliente requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de teléfono inválido'
        });
      }

      const conversation = await Conversation.getActive(restaurantId, customerPhone);

      if (!conversation) {
        return res.status(404).json({
          success: false,
          error: 'No hay conversación activa'
        });
      }

      // Parsear datos JSON
      let orderData = {};
      let aiContext = [];

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversación activa:', e);
      }

      const response = {
        ...conversation,
        order_data: orderData,
        ai_context: aiContext
      };

      res.json({
        success: true,
        data: response
      });

    } catch (error) {
      logger.error('Error obteniendo conversación activa:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo conversación activa'
      });
    }
  });

  /**
   * Obtiene el estado de una conversación
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversationStatus = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id || req.params.restaurantId;

      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de teléfono inválido'
        });
      }

      const status = await ConversationService.getConversationStatus(restaurantId, customerPhone);

      if (!status) {
        return res.status(404).json({
          success: false,
          error: 'No hay conversación activa'
        });
      }

      res.json({
        success: true,
        data: status
      });

    } catch (error) {
      logger.error('Error obteniendo estado de conversación:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estado'
      });
    }
  });

  /**
   * Inicia una nueva conversación
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static startConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.body;
      const restaurant = req.restaurant;

      if (!restaurant) {
        return res.status(400).json({
          success: false,
          error: 'Restaurante no identificado'
        });
      }

      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Teléfono del cliente requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de teléfono inválido'
        });
      }

      // Iniciar conversación usando el servicio
      const result = await ConversationService.startConversation(restaurant, customerPhone);

      logger.info('Conversación iniciada manualmente', {
        restaurantId: restaurant.id,
        customerPhone: customerPhone.substring(0, 8) + '****',
        conversationId: result.conversation.id
      });

      res.status(201).json({
        success: true,
        message: 'Conversación iniciada exitosamente',
        data: {
          conversation: result.conversation,
          customer: result.customer,
          send_result: result.sendResult
        }
      });

    } catch (error) {
      logger.error('Error iniciando conversación:', error);
      res.status(500).json({
        success: false,
        error: 'Error iniciando conversación'
      });
    }
  });

  /**
   * Reinicia una conversación
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static restartConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id || req.params.restaurantId;

      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de teléfono inválido'
        });
      }

      // Reiniciar conversación usando el servicio
      const result = await ConversationService.restartConversation(restaurantId, customerPhone);

      logger.info('Conversación reiniciada', {
        restaurantId,
        customerPhone: customerPhone.substring(0, 8) + '****',
        newConversationId: result.conversation.id
      });

      res.json({
        success: true,
        message: 'Conversación reiniciada exitosamente',
        data: result
      });

    } catch (error) {
      logger.error('Error reiniciando conversación:', error);
      res.status(500).json({
        success: false,
        error: 'Error reiniciando conversación'
      });
    }
  });

  /**
   * Actualiza una conversación
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateConversation = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversación inválido'
        });
      }

      const allowedFields = ['status', 'current_step', 'conversation_summary'];
      const updateData = {};

      Object.keys(req.body).forEach(key => {
        if (allowedFields.includes(key)) {
          updateData[key] = req.body[key];
        }
      });

      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No hay campos válidos para actualizar'
        });
      }

      // Validar valores específicos
      if (updateData.status && !Object.values(CONVERSATION_STATUS).includes(updateData.status)) {
        return res.status(400).json({
          success: false,
          error: 'Estado de conversación inválido'
        });
      }

      if (updateData.current_step && !Object.values(CONVERSATION_STEPS).includes(updateData.current_step)) {
        return res.status(400).json({
          success: false,
          error: 'Paso de conversación inválido'
        });
      }

      // Actualizar conversación
      const updatedConversation = await Conversation.update(conversationId, updateData);

      logger.info('Conversación actualizada', {
        conversationId,
        updatedFields: Object.keys(updateData)
      });

      res.json({
        success: true,
        message: 'Conversación actualizada exitosamente',
        data: updatedConversation
      });

    } catch (error) {
      logger.error('Error actualizando conversación:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Conversación no encontrada'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando conversación'
        });
      }
    }
  });

  /**
   * Marca una conversación como abandonada
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static abandonConversation = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversación inválido'
        });
      }

      // Abandonar conversación
      const abandonedConversation = await Conversation.abandon(conversationId);

      logger.info('Conversación marcada como abandonada', { conversationId });

      res.json({
        success: true,
        message: 'Conversación marcada como abandonada',
        data: abandonedConversation
      });

    } catch (error) {
      logger.error('Error marcando conversación como abandonada:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Conversación no encontrada'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error abandonando conversación'
        });
      }
    }
  });

  /**
   * Simula un mensaje en una conversación (para testing)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static simulateMessage = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;
      const { message, role = 'user' } = req.body;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversación inválido'
        });
      }

      if (!message || !message.trim()) {
        return res.status(400).json({
          success: false,
          error: 'Mensaje es requerido'
        });
      }

      if (!['user', 'assistant'].includes(role)) {
        return res.status(400).json({
          success: false,
          error: 'Role debe ser "user" o "assistant"'
        });
      }

      // Solo permitir en desarrollo
      if (process.env.NODE_ENV !== 'development') {
        return res.status(403).json({
          success: false,
          error: 'Función solo disponible en desarrollo'
        });
      }

      // Agregar mensaje al contexto
      const updatedConversation = await Conversation.addToContext(conversationId, role, message);

      logger.info('Mensaje simulado agregado', {
        conversationId,
        role,
        messageLength: message.length
      });

      res.json({
        success: true,
        message: 'Mensaje simulado agregado exitosamente',
        data: updatedConversation
      });

    } catch (error) {
      logger.error('Error simulando mensaje:', error);
      res.status(500).json({
        success: false,
        error: 'Error simulando mensaje'
      });
    }
  });

  /**
   * Obtiene estadísticas de conversaciones
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversationStatistics = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar parámetros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(req.query);
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error
        });
      }

      const { start_date, end_date } = dateValidation.data;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      // Obtener estadísticas usando el servicio
      const statistics = await ConversationService.getConversationStats(restaurantId, dateRange);

      logger.info('Estadísticas de conversaciones obtenidas', {
        restaurantId,
        dateRange,
        totalConversations: statistics.total_conversations
      });

      res.json({
        success: true,
        data: statistics
      });

    } catch (error) {
      logger.error('Error obteniendo estadísticas de conversaciones:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estadísticas'
      });
    }
  });

  /**
   * Limpia conversaciones inactivas
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static cleanupInactiveConversations = asyncHandler(async (req, res) => {
    try {
      const { max_inactive_hours = 2 } = req.query;
      const maxHours = parseInt(max_inactive_hours);

      if (maxHours < 1 || maxHours > 24) {
        return res.status(400).json({
          success: false,
          error: 'max_inactive_hours debe estar entre 1 y 24'
        });
      }

      // Limpiar conversaciones usando el servicio
      const cleanedCount = await ConversationService.cleanupInactiveConversations(maxHours);

      logger.info('Limpieza manual de conversaciones ejecutada', {
        maxInactiveHours: maxHours,
        cleanedCount
      });

      res.json({
        success: true,
        message: `Limpieza completada: ${cleanedCount} conversaciones marcadas como abandonadas`,
        data: {
          cleaned_count: cleanedCount,
          max_inactive_hours: maxHours
        }
      });

    } catch (error) {
      logger.error('Error limpiando conversaciones inactivas:', error);
      res.status(500).json({
        success: false,
        error: 'Error limpiando conversaciones'
      });
    }
  });

  /**
   * Envía mensaje manual en una conversación
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static sendManualMessage = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;
      const { message } = req.body;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversación inválido'
        });
      }

      if (!message || !message.trim()) {
        return res.status(400).json({
          success: false,
          error: 'Mensaje es requerido'
        });
      }

      // Validar mensaje
      const validation = ValidationService.validateIncomingMessage(message, null);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      // Obtener conversación para el teléfono del cliente
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) {
        return res.status(404).json({
          success: false,
          error: 'Conversación no encontrada'
        });
      }

      // Enviar mensaje
      const sendResult = await WhatsAppService.sendMessage(
        conversation.customer_phone,
        message,
        { addEmojis: true }
      );

      // Agregar mensaje al contexto
      await Conversation.addToContext(conversationId, 'assistant', message);

      logger.info('Mensaje manual enviado en conversación', {
        conversationId,
        customerPhone: conversation.customer_phone?.substring(0, 8) + '****',
        messageLength: message.length,
        success: sendResult.success
      });

      res.json({
        success: true,
        message: 'Mensaje enviado exitosamente',
        data: {
          conversation_id: conversationId,
          send_result: sendResult
        }
      });

    } catch (error) {
      logger.error('Error enviando mensaje manual:', error);
      res.status(500).json({
        success: false,
        error: 'Error enviando mensaje'
      });
    }
  });

  /**
   * Exporta conversaciones a CSV/JSON
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static exportConversations = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const { format = 'json', limit = 1000 } = req.query;

      if (!['json', 'csv'].includes(format)) {
        return res.status(400).json({
          success: false,
          error: 'Formato debe ser "json" o "csv"'
        });
      }

      const limitNumber = parseInt(limit);
      if (limitNumber < 1 || limitNumber > 10000) {
        return res.status(400).json({
          success: false,
          error: 'Límite debe estar entre 1 y 10000'
        });
      }

      // Obtener conversaciones
      const result = await Conversation.getRecent(restaurantId, {
        page: 1,
        limit: limitNumber
      });

      const conversations = result.conversations;

      if (format === 'json') {
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename="conversations-${restaurantId}-${Date.now()}.json"`);
        
        res.json({
          restaurant_id: restaurantId,
          exported_at: new Date().toISOString(),
          total_conversations: conversations.length,
          conversations: conversations
        });
      } else {
        // CSV format (implementación básica)
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="conversations-${restaurantId}-${Date.now()}.csv"`);
        
        let csv = 'id,customer_phone,status,current_step,created_at,last_interaction_at,order_total\n';
        
        conversations.forEach(conv => {
          csv += `${conv.id},${conv.customer_phone},${conv.status},${conv.current_step},${conv.created_at},${conv.last_interaction_at},${conv.order_total || 0}\n`;
        });
        
        res.send(csv);
      }

      logger.info('Conversaciones exportadas', {
        restaurantId,
        format,
        count: conversations.length
      });

    } catch (error) {
      logger.error('Error exportando conversaciones:', error);
      res.status(500).json({
        success: false,
        error: 'Error exportando conversaciones'
      });
    }
  });
}

module.exports = ConversationController;


================================================
File: src/controllers/menuController.js
================================================
const Menu = require('../models/Menu');
const ValidationService = require('../services/validationService');
const logger = require('../utils/logger');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE MENÚ
// ============================================

class MenuController {

  // ============================================
  // CATEGORÍAS
  // ============================================

  /**
   * Obtiene todas las categorías de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCategories = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inválido'
        });
      }

      const { active_only = 'true' } = req.query;
      const activeOnly = active_only === 'true';

      const categories = await Menu.getCategories(restaurantId, activeOnly);

      logger.info('Categorías de menú obtenidas', {
        restaurantId,
        categoriesCount: categories.length,
        activeOnly
      });

      res.json({
        success: true,
        data: categories
      });

    } catch (error) {
      logger.error('Error obteniendo categorías de menú:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo categorías'
      });
    }
  });

  /**
   * Crea una nueva categoría
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createCategory = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar datos de entrada
      const validation = ValidationService.validateMenuCategoryCreation(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const categoryData = validation.data;

      // Crear categoría
      const category = await Menu.createCategory(restaurantId, categoryData);

      logger.info('Categoría de menú creada', {
        restaurantId,
        categoryId: category.id,
        name: category.name
      });

      res.status(201).json({
        success: true,
        message: 'Categoría creada exitosamente',
        data: category
      });

    } catch (error) {
      logger.error('Error creando categoría de menú:', error);
      
      if (error.message.includes('ya existe')) {
        res.status(409).json({
          success: false,
          error: 'Ya existe una categoría con ese nombre'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error creando categoría'
        });
      }
    }
  });

  /**
   * Actualiza una categoría
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateCategory = asyncHandler(async (req, res) => {
    try {
      const { categoryId } = req.params;

      if (!ValidationService.isValidUUID(categoryId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de categoría inválido'
        });
      }

      // Validar que hay datos para actualizar
      if (!req.body || Object.keys(req.body).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No hay datos para actualizar'
        });
      }

      const updateData = req.body;

      // Validar campos específicos si están presentes
      const allowedFields = ['name', 'description', 'display_order', 'emoji', 'is_active'];
      const filteredData = {};

      Object.keys(updateData).forEach(key => {
        if (allowedFields.includes(key)) {
          filteredData[key] = updateData[key];
        }
      });

      if (Object.keys(filteredData).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No hay campos válidos para actualizar'
        });
      }

      // Actualizar categoría
      const updatedCategory = await Menu.updateCategory(categoryId, filteredData);

      logger.info('Categoría actualizada', {
        categoryId,
        updatedFields: Object.keys(filteredData)
      });

      res.json({
        success: true,
        message: 'Categoría actualizada exitosamente',
        data: updatedCategory
      });

    } catch (error) {
      logger.error('Error actualizando categoría:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Categoría no encontrada'
        });
      } else if (error.message.includes('ya existe')) {
        res.status(409).json({
          success: false,
          error: 'Ya existe una categoría con ese nombre'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando categoría'
        });
      }
    }
  });

  // ============================================
  // MENÚ COMPLETO
  // ============================================

  /**
   * Obtiene el menú completo de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getFullMenu = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inválido'
        });
      }

      const { available_only = 'true' } = req.query;
      const availableOnly = available_only === 'true';

      const menu = await Menu.getFullMenu(restaurantId, availableOnly);

      logger.info('Menú completo obtenido', {
        restaurantId,
        categoriesCount: menu.categories.length,
        totalItems: menu.total_items,
        availableOnly
      });

      res.json({
        success: true,
        data: menu
      });

    } catch (error) {
      logger.error('Error obteniendo menú completo:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo menú'
      });
    }
  });

  // ============================================
  // ITEMS DEL MENÚ
  // ============================================

  /**
   * Obtiene un item específico del menú
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getMenuItem = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;
      const restaurantId = req.restaurant?.id;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inválido'
        });
      }

      const item = await Menu.getItem(itemId, restaurantId);

      if (!item) {
        return res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      }

      logger.info('Item de menú obtenido', {
        itemId,
        itemName: item.name,
        restaurantId: restaurantId || 'any'
      });

      res.json({
        success: true,
        data: item
      });

    } catch (error) {
      logger.error('Error obteniendo item de menú:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo item'
      });
    }
  });

  /**
   * Crea un nuevo item del menú
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createMenuItem = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar datos de entrada
      const validation = ValidationService.validateMenuItemCreation(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const itemData = validation.data;

      // Crear item
      const item = await Menu.createItem(restaurantId, itemData);

      logger.info('Item de menú creado', {
        restaurantId,
        itemId: item.id,
        name: item.name,
        price: item.price
      });

      res.status(201).json({
        success: true,
        message: 'Item creado exitosamente',
        data: item
      });

    } catch (error) {
      logger.error('Error creando item de menú:', error);
      
      if (error.message.includes('no pertenece')) {
        res.status(400).json({
          success: false,
          error: 'La categoría no pertenece a este restaurante'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error creando item'
        });
      }
    }
  });

  /**
   * Actualiza un item del menú
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateMenuItem = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inválido'
        });
      }

      // Validar datos de actualización
      const validation = ValidationService.validateMenuItemUpdate(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const updateData = validation.data;

      // Actualizar item
      const updatedItem = await Menu.updateItem(itemId, updateData);

      logger.info('Item de menú actualizado', {
        itemId,
        updatedFields: Object.keys(updateData)
      });

      res.json({
        success: true,
        message: 'Item actualizado exitosamente',
        data: updatedItem
      });

    } catch (error) {
      logger.error('Error actualizando item de menú:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando item'
        });
      }
    }
  });

  /**
   * Cambia la disponibilidad de un item
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static toggleItemAvailability = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;
      const { is_available } = req.body;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inválido'
        });
      }

      if (typeof is_available !== 'boolean') {
        return res.status(400).json({
          success: false,
          error: 'is_available debe ser booleano'
        });
      }

      // Actualizar disponibilidad
      const success = await Menu.setItemAvailability(itemId, is_available);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      }

      logger.info('Disponibilidad de item actualizada', {
        itemId,
        isAvailable: is_available
      });

      res.json({
        success: true,
        message: `Item ${is_available ? 'activado' : 'desactivado'} exitosamente`,
        data: {
          item_id: itemId,
          is_available
        }
      });

    } catch (error) {
      logger.error('Error cambiando disponibilidad de item:', error);
      res.status(500).json({
        success: false,
        error: 'Error actualizando disponibilidad'
      });
    }
  });

  /**
   * Elimina un item del menú
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static deleteMenuItem = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inválido'
        });
      }

      // Eliminar item (soft delete si tiene pedidos asociados)
      const success = await Menu.deleteItem(itemId);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      }

      logger.info('Item de menú eliminado', { itemId });

      res.json({
        success: true,
        message: 'Item eliminado exitosamente'
      });

    } catch (error) {
      logger.error('Error eliminando item de menú:', error);
      res.status(500).json({
        success: false,
        error: 'Error eliminando item'
      });
    }
  });

  // ============================================
  // BÚSQUEDA Y FILTROS
  // ============================================

  /**
   * Busca items en el menú
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static searchMenuItems = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const {
        q: searchTerm = '',
        category_id = null,
        min_price = null,
        max_price = null,
        available_only = 'true'
      } = req.query;

      // Validar parámetros
      if (category_id && !ValidationService.isValidUUID(category_id)) {
        return res.status(400).json({
          success: false,
          error: 'ID de categoría inválido'
        });
      }

      const filters = {
        categoryId: category_id,
        minPrice: min_price ? parseFloat(min_price) : null,
        maxPrice: max_price ? parseFloat(max_price) : null,
        availableOnly: available_only === 'true'
      };

      // Realizar búsqueda
      const items = await Menu.searchItems(restaurantId, searchTerm, filters);

      logger.info('Búsqueda de items realizada', {
        restaurantId,
        searchTerm,
        filtersApplied: Object.keys(filters).filter(key => filters[key] !== null).length,
        resultsCount: items.length
      });

      res.json({
        success: true,
        data: {
          items,
          search_term: searchTerm,
          filters_applied: filters,
          results_count: items.length
        }
      });

    } catch (error) {
      logger.error('Error buscando items de menú:', error);
      res.status(500).json({
        success: false,
        error: 'Error realizando búsqueda'
      });
    }
  });

  /**
   * Obtiene items más populares
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getPopularItems = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const { limit = 10 } = req.query;
      const limitNumber = parseInt(limit);

      if (limitNumber < 1 || limitNumber > 50) {
        return res.status(400).json({
          success: false,
          error: 'Límite debe estar entre 1 y 50'
        });
      }

      const popularItems = await Menu.getPopularItems(restaurantId, limitNumber);

      logger.info('Items populares obtenidos', {
        restaurantId,
        limit: limitNumber,
        itemsFound: popularItems.length
      });

      res.json({
        success: true,
        data: {
          items: popularItems,
          limit: limitNumber,
          generated_at: new Date().toISOString()
        }
      });

    } catch (error) {
      logger.error('Error obteniendo items populares:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo items populares'
      });
    }
  });

  // ============================================
  // OPERACIONES EN LOTE
  // ============================================

  /**
   * Actualiza orden de display de items
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateDisplayOrder = asyncHandler(async (req, res) => {
    try {
      const { updates } = req.body;

      if (!Array.isArray(updates) || updates.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un array de actualizaciones'
        });
      }

      // Validar estructura de actualizaciones
      for (const update of updates) {
        if (!update.id || !ValidationService.isValidUUID(update.id)) {
          return res.status(400).json({
            success: false,
            error: 'ID inválido en actualizaciones'
          });
        }

        if (typeof update.display_order !== 'number' || update.display_order < 0) {
          return res.status(400).json({
            success: false,
            error: 'display_order debe ser un número no negativo'
          });
        }
      }

      // Actualizar orden
      const success = await Menu.updateDisplayOrder(updates);

      if (!success) {
        return res.status(500).json({
          success: false,
          error: 'Error actualizando orden'
        });
      }

      logger.info('Orden de display actualizado', {
        updatesCount: updates.length
      });

      res.json({
        success: true,
        message: 'Orden actualizado exitosamente',
        data: {
          updated_items: updates.length
        }
      });

    } catch (error) {
      logger.error('Error actualizando orden de display:', error);
      res.status(500).json({
        success: false,
        error: 'Error actualizando orden'
      });
    }
  });

  /**
   * Operación en lote para cambiar disponibilidad
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static batchUpdateAvailability = asyncHandler(async (req, res) => {
    try {
      const { item_ids, is_available } = req.body;

      if (!Array.isArray(item_ids) || item_ids.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un array de IDs de items'
        });
      }

      if (typeof is_available !== 'boolean') {
        return res.status(400).json({
          success: false,
          error: 'is_available debe ser booleano'
        });
      }

      // Validar IDs
      for (const itemId of item_ids) {
        if (!ValidationService.isValidUUID(itemId)) {
          return res.status(400).json({
            success: false,
            error: `ID inválido: ${itemId}`
          });
        }
      }

      // Actualizar disponibilidad de cada item
      const results = [];
      let successCount = 0;
      let errorCount = 0;

      for (const itemId of item_ids) {
        try {
          const success = await Menu.setItemAvailability(itemId, is_available);
          results.push({ item_id: itemId, success });
          if (success) successCount++;
          else errorCount++;
        } catch (error) {
          results.push({ item_id: itemId, success: false, error: error.message });
          errorCount++;
        }
      }

      logger.info('Actualización en lote de disponibilidad completada', {
        totalItems: item_ids.length,
        successCount,
        errorCount,
        isAvailable: is_available
      });

      res.json({
        success: true,
        message: `Disponibilidad actualizada: ${successCount} exitosos, ${errorCount} errores`,
        data: {
          results,
          summary: {
            total: item_ids.length,
            successful: successCount,
            failed: errorCount
          }
        }
      });

    } catch (error) {
      logger.error('Error en actualización en lote:', error);
      res.status(500).json({
        success: false,
        error: 'Error en actualización en lote'
      });
    }
  });

  // ============================================
  // UTILIDADES
  // ============================================

  /**
   * Obtiene resumen del menú
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getMenuSummary = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Obtener categorías y items populares
      const [categories, popularItems] = await Promise.all([
        Menu.getCategories(restaurantId, true),
        Menu.getPopularItems(restaurantId, 5)
      ]);

      const totalItems = categories.reduce((sum, cat) => sum + parseInt(cat.items_count), 0);
      const totalCategories = categories.length;

      const summary = {
        restaurant_id: restaurantId,
        total_categories: totalCategories,
        total_items: totalItems,
        categories: categories.map(cat => ({
          id: cat.id,
          name: cat.name,
          emoji: cat.emoji,
          items_count: cat.items_count
        })),
        popular_items: popularItems.slice(0, 5),
        generated_at: new Date().toISOString()
      };

      res.json({
        success: true,
        data: summary
      });

    } catch (error) {
      logger.error('Error obteniendo resumen del menú:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo resumen'
      });
    }
  });
}

module.exports = MenuController;


================================================
File: src/controllers/orderController.js
================================================
const Order = require('../models/Order');
const OrderService = require('../services/orderService');
const ValidationService = require('../services/validationService');
const logger = require('../utils/logger');
const { ORDER_STATUS } = require('../utils/constants');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE PEDIDOS
// ============================================

class OrderController {

  /**
   * Obtiene pedidos de un restaurante con filtros
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrders = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inválido'
        });
      }

      // Validar parámetros de paginación
      const paginationValidation = ValidationService.validatePaginationParams(req.query);
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error
        });
      }

      const { page, limit, sort_by, sort_order } = paginationValidation.data;

      // Preparar filtros
      const filters = {
        page,
        limit,
        sort_by,
        sort_order,
        status: req.query.status,
        customer_phone: req.query.customer_phone,
        start_date: req.query.start_date,
        end_date: req.query.end_date
      };

      // Validar fechas si están presentes
      if (filters.start_date || filters.end_date) {
        const dateValidation = ValidationService.validateDateRangeParams({
          start_date: filters.start_date,
          end_date: filters.end_date
        });
        
        if (!dateValidation.isValid) {
          return res.status(400).json({
            success: false,
            error: dateValidation.error
          });
        }
      }

      // Obtener pedidos
      const result = await Order.findByRestaurant(restaurantId, filters);

      logger.info('Pedidos obtenidos', {
        restaurantId,
        page,
        limit,
        totalItems: result.pagination.total_items,
        filtersApplied: Object.keys(filters).filter(key => filters[key]).length
      });

      res.json({
        success: true,
        data: result.orders,
        pagination: result.pagination,
        filters_applied: filters
      });

    } catch (error) {
      logger.error('Error obteniendo pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedidos'
      });
    }
  });

  /**
   * Obtiene un pedido específico por ID
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrderById = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;
      const restaurantId = req.restaurant?.id;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inválido'
        });
      }

      const order = await Order.findById(orderId, restaurantId);

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Pedido no encontrado'
        });
      }

      logger.info('Pedido obtenido por ID', {
        orderId,
        restaurantId: order.restaurant_id,
        status: order.status
      });

      res.json({
        success: true,
        data: order
      });

    } catch (error) {
      logger.error('Error obteniendo pedido por ID:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedido'
      });
    }
  });

  /**
   * Crea un nuevo pedido manualmente
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createOrder = asyncHandler(async (req, res) => {
    try {
      // Validar datos del pedido
      const validation = ValidationService.validateOrderCreation(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const orderData = validation.data;

      // Validar dirección de entrega
      const addressValidation = ValidationService.validateDeliveryAddress(orderData.delivery_address);
      if (!addressValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: `Dirección inválida: ${addressValidation.error}`
        });
      }

      // Expandir datos de dirección
      const expandedOrderData = {
        ...orderData,
        delivery_street: orderData.delivery_address.street,
        delivery_number: orderData.delivery_address.number,
        delivery_neighborhood: orderData.delivery_address.neighborhood,
        delivery_references: orderData.delivery_address.references,
        delivery_postal_code: orderData.delivery_address.postal_code
      };

      // Calcular tiempo estimado de entrega
      const estimatedTime = await Order.calculateDeliveryTime(
        orderData.restaurant_id,
        orderData.delivery_address.neighborhood
      );
      expandedOrderData.estimated_delivery_time = estimatedTime;

      // Crear pedido
      const order = await Order.create(expandedOrderData);

      logger.info('Pedido creado manualmente', {
        orderId: order.id,
        restaurantId: order.restaurant_id,
        customerPhone: order.customer_phone?.substring(0, 8) + '****',
        total: order.total
      });

      res.status(201).json({
        success: true,
        message: 'Pedido creado exitosamente',
        data: order
      });

    } catch (error) {
      logger.error('Error creando pedido:', error);
      res.status(500).json({
        success: false,
        error: 'Error creando pedido'
      });
    }
  });

  /**
   * Actualiza el estado de un pedido
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateOrderStatus = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inválido'
        });
      }

      // Validar datos de actualización
      const validation = ValidationService.validateOrderStatusUpdate(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const { status, internal_notes, estimated_delivery_time } = validation.data;

      // Actualizar estado usando el servicio
      const updatedOrder = await OrderService.updateOrderStatus(orderId, status, {
        internal_notes,
        estimated_delivery_time,
        notify_customer: req.body.notify_customer !== false, // Default true
        restaurant: req.restaurant
      });

      logger.info('Estado de pedido actualizado', {
        orderId,
        newStatus: status,
        notifyCustomer: req.body.notify_customer !== false
      });

      res.json({
        success: true,
        message: 'Estado actualizado exitosamente',
        data: updatedOrder
      });

    } catch (error) {
      logger.error('Error actualizando estado de pedido:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Pedido no encontrado'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando pedido'
        });
      }
    }
  });

  /**
   * Cancela un pedido
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static cancelOrder = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;
      const { reason, notify_customer = true } = req.body;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inválido'
        });
      }

      if (!reason || reason.trim().length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Razón de cancelación es requerida'
        });
      }

      // Cancelar pedido usando el servicio
      const cancelledOrder = await OrderService.cancelOrder(orderId, reason, {
        notify_customer,
        cancelled_by: 'restaurant'
      });

      logger.info('Pedido cancelado', {
        orderId,
        reason,
        notifyCustomer: notify_customer
      });

      res.json({
        success: true,
        message: 'Pedido cancelado exitosamente',
        data: cancelledOrder
      });

    } catch (error) {
      logger.error('Error cancelando pedido:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Pedido no encontrado'
        });
      } else if (error.message.includes('no se puede cancelar')) {
        res.status(400).json({
          success: false,
          error: error.message
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error cancelando pedido'
        });
      }
    }
  });

  /**
   * Obtiene pedidos activos (en preparación/camino)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getActiveOrders = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const activeOrders = await OrderService.getActiveOrders(restaurantId);

      logger.info('Pedidos activos obtenidos', {
        restaurantId,
        count: activeOrders.length,
        delayedCount: activeOrders.filter(o => o.is_delayed).length,
        urgentCount: activeOrders.filter(o => o.is_urgent).length
      });

      res.json({
        success: true,
        data: {
          orders: activeOrders,
          summary: {
            total: activeOrders.length,
            delayed: activeOrders.filter(o => o.is_delayed).length,
            urgent: activeOrders.filter(o => o.is_urgent).length,
            on_time: activeOrders.filter(o => !o.is_delayed && !o.is_urgent).length
          }
        }
      });

    } catch (error) {
      logger.error('Error obteniendo pedidos activos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedidos activos'
      });
    }
  });

  /**
   * Obtiene estadísticas de pedidos
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrderStatistics = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar parámetros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(req.query);
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error
        });
      }

      const { start_date, end_date } = dateValidation.data;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      // Obtener estadísticas usando el servicio
      const statistics = await OrderService.getOrderStatistics(restaurantId, dateRange);

      logger.info('Estadísticas de pedidos obtenidas', {
        restaurantId,
        dateRange,
        totalOrders: statistics.basic.total_orders
      });

      res.json({
        success: true,
        data: statistics
      });

    } catch (error) {
      logger.error('Error obteniendo estadísticas de pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estadísticas'
      });
    }
  });

  /**
   * Busca pedidos con filtros avanzados
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static searchOrders = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar parámetros de paginación
      const paginationValidation = ValidationService.validatePaginationParams(req.query);
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error
        });
      }

      const filters = {
        ...paginationValidation.data,
        customer_phone: req.query.customer_phone,
        status: req.query.status,
        start_date: req.query.start_date,
        end_date: req.query.end_date,
        min_total: req.query.min_total ? parseFloat(req.query.min_total) : null,
        max_total: req.query.max_total ? parseFloat(req.query.max_total) : null,
        neighborhood: req.query.neighborhood
      };

      // Realizar búsqueda
      const results = await OrderService.searchOrders(restaurantId, filters);

      logger.info('Búsqueda de pedidos realizada', {
        restaurantId,
        filtersCount: Object.keys(filters).filter(key => filters[key]).length,
        resultsCount: results.pagination.total_items
      });

      res.json({
        success: true,
        data: results.orders,
        pagination: results.pagination,
        filters_applied: filters
      });

    } catch (error) {
      logger.error('Error buscando pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error realizando búsqueda'
      });
    }
  });

  /**
   * Obtiene pedidos de un cliente específico
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCustomerOrders = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id;
      const { limit = 10 } = req.query;

      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Teléfono del cliente requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de teléfono inválido'
        });
      }

      const limitNumber = parseInt(limit);
      if (limitNumber < 1 || limitNumber > 50) {
        return res.status(400).json({
          success: false,
          error: 'Límite debe estar entre 1 y 50'
        });
      }

      // Obtener pedidos del cliente
      const orders = await Order.findByCustomer(customerPhone, restaurantId, limitNumber);

      logger.info('Pedidos de cliente obtenidos', {
        customerPhone: customerPhone.substring(0, 8) + '****',
        restaurantId: restaurantId || 'all',
        ordersFound: orders.length
      });

      res.json({
        success: true,
        data: {
          customer_phone: customerPhone,
          orders,
          total_found: orders.length
        }
      });

    } catch (error) {
      logger.error('Error obteniendo pedidos de cliente:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedidos del cliente'
      });
    }
  });

  /**
   * Genera reporte de ventas
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static generateSalesReport = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar parámetros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(req.query);
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error
        });
      }

      const {
        start_date,
        end_date,
        group_by = 'day',
        include_items = 'false'
      } = req.query;

      const options = {
        start_date,
        end_date,
        group_by,
        include_items: include_items === 'true'
      };

      // Generar reporte
      const report = await OrderService.generateSalesReport(restaurantId, options);

      logger.info('Reporte de ventas generado', {
        restaurantId,
        dateRange: { start_date, end_date },
        groupBy: group_by,
        includeItems: options.include_items
      });

      res.json({
        success: true,
        data: report
      });

    } catch (error) {
      logger.error('Error generando reporte de ventas:', error);
      res.status(500).json({
        success: false,
        error: 'Error generando reporte'
      });
    }
  });

  /**
   * Valida si un pedido puede ser modificado
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static validateOrderModification = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inválido'
        });
      }

      // Validar modificación usando el servicio
      const validation = await OrderService.validateOrderModification(orderId);

      res.json({
        success: true,
        data: {
          can_modify: validation.canModify,
          reason: validation.reason,
          order: validation.order || null
        }
      });

    } catch (error) {
      logger.error('Error validando modificación de pedido:', error);
      res.status(500).json({
        success: false,
        error: 'Error validando modificación'
      });
    }
  });

  /**
   * Obtiene resumen rápido de pedidos
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrdersSummary = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Obtener resúmenes de diferentes períodos
      const [todaySummary, weekSummary, monthSummary] = await Promise.all([
        Order.getSalesSummary(restaurantId, 'today'),
        Order.getSalesSummary(restaurantId, 'week'),
        Order.getSalesSummary(restaurantId, 'month')
      ]);

      // Obtener pedidos activos
      const activeOrders = await OrderService.getActiveOrders(restaurantId);

      const summary = {
        restaurant_id: restaurantId,
        active_orders: {
          total: activeOrders.length,
          delayed: activeOrders.filter(o => o.is_delayed).length,
          urgent: activeOrders.filter(o => o.is_urgent).length
        },
        sales_summary: {
          today: todaySummary,
          week: weekSummary,
          month: monthSummary
        },
        generated_at: new Date().toISOString()
      };

      res.json({
        success: true,
        data: summary
      });

    } catch (error) {
      logger.error('Error obteniendo resumen de pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo resumen'
      });
    }
  });

  /**
   * Actualiza múltiples pedidos en lote
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static batchUpdateOrders = asyncHandler(async (req, res) => {
    try {
      const { updates } = req.body;

      if (!Array.isArray(updates) || updates.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un array de actualizaciones'
        });
      }

      if (updates.length > 50) {
        return res.status(400).json({
          success: false,
          error: 'Máximo 50 actualizaciones por lote'
        });
      }

      // Validar estructura de actualizaciones  
      for (const update of updates) {
        if (!update.order_id || !ValidationService.isValidUUID(update.order_id)) {
          return res.status(400).json({
            success: false,
            error: 'ID de pedido inválido en actualizaciones'
          });
        }

        if (!update.status || !Object.values(ORDER_STATUS).includes(update.status)) {
          return res.status(400).json({
            success: false,
            error: 'Estado inválido en actualizaciones'
          });
        }
      }

      // Procesar actualizaciones
      const results = [];
      let successCount = 0;
      let errorCount = 0;

      for (const update of updates) {
        try {
          const updatedOrder = await OrderService.updateOrderStatus(
            update.order_id,
            update.status,
            {
              internal_notes: update.internal_notes,
              notify_customer: update.notify_customer !== false
            }
          );

          results.push({
            order_id: update.order_id,
            success: true,
            new_status: update.status
          });
          successCount++;

        } catch (error) {
          results.push({
            order_id: update.order_id,
            success: false,
            error: error.message
          });
          errorCount++;
        }
      }

      logger.info('Actualización en lote de pedidos completada', {
        totalUpdates: updates.length,
        successCount,
        errorCount
      });

      res.json({
        success: true,
        message: `Actualizaciones completadas: ${successCount} exitosas, ${errorCount} errores`,
        data: {
          results,
          summary: {
            total: updates.length,
            successful: successCount,
            failed: errorCount
          }
        }
      });

    } catch (error) {
      logger.error('Error en actualización en lote de pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error en actualización en lote'
      });
    }
  });
}

module.exports = OrderController;


================================================
File: src/controllers/restaurantController.js
================================================
const Restaurant = require("../models/Restaurant");
const ValidationService = require("../services/validationService");
const logger = require("../utils/logger");
const { asyncHandler } = require("../middleware/errorHandler");

// ============================================
// CONTROLADOR DE RESTAURANTES
// ============================================

class RestaurantController {
  /**
   * Obtiene lista de restaurantes con paginación
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getAllRestaurants = asyncHandler(async (req, res) => {
    try {
      // Validar parámetros de consulta
      const paginationValidation = ValidationService.validatePaginationParams(
        req.query
      );
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error,
        });
      }

      const { page, limit, sort_by, sort_order } = paginationValidation.data;

      const { search = "", is_active = null } = req.query;

      // Obtener restaurantes
      const result = await Restaurant.findAll({
        page,
        limit,
        search,
        isActive: is_active !== null ? is_active === "true" : null,
        sortBy: sort_by,
        sortOrder: sort_order,
      });

      logger.info("Lista de restaurantes obtenida", {
        page,
        limit,
        total: result.pagination.total_items,
        search: search || "none",
      });

      res.json({
        success: true,
        data: result.restaurants,
        pagination: result.pagination,
      });
    } catch (error) {
      logger.error("Error obteniendo lista de restaurantes:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurantes",
      });
    }
  });

  /**
   * Obtiene un restaurante por ID
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getRestaurantById = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inválido",
        });
      }

      const restaurant = await Restaurant.findById(id);

      if (!restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante obtenido por ID", {
        restaurantId: id,
        restaurantName: restaurant.name,
      });

      res.json({
        success: true,
        data: restaurant,
      });
    } catch (error) {
      logger.error("Error obteniendo restaurante por ID:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurante",
      });
    }
  });

  /**
   * Obtiene un restaurante por slug
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getRestaurantBySlug = asyncHandler(async (req, res) => {
    try {
      const { slug } = req.params;

      if (!slug || slug.length < 2) {
        return res.status(400).json({
          success: false,
          error: "Slug inválido",
        });
      }

      const restaurant = await Restaurant.findBySlug(slug);

      if (!restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante obtenido por slug", {
        slug,
        restaurantId: restaurant.id,
        restaurantName: restaurant.name,
      });

      res.json({
        success: true,
        data: restaurant,
      });
    } catch (error) {
      logger.error("Error obteniendo restaurante por slug:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurante",
      });
    }
  });

  /**
   * Crea un nuevo restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createRestaurant = asyncHandler(async (req, res) => {
  try {
    console.log('📥 1. Datos recibidos en backend:', JSON.stringify(req.body, null, 2));

    // ✅ USAR VALIDACIÓN DE JOI
    const validation = ValidationService.validateRestaurantCreation(req.body);
    if (!validation.isValid) {
      console.log('❌ Error de validación:', validation.error);
      return res.status(400).json({
        success: false,
        error: validation.error
      });
    }

    console.log('✅ Validación de Joi pasada');

    const restaurantData = validation.data;

    console.log('📊 2. Datos validados:', JSON.stringify(restaurantData, null, 2));

    // Verificar slug disponible
    console.log('🔍 3. Verificando disponibilidad de slug...');
    const isSlugAvailable = await Restaurant.isSlugAvailable(restaurantData.slug);
    console.log('📝 4. Slug disponible:', isSlugAvailable);
    
    if (!isSlugAvailable) {
      console.log('❌ Slug no disponible');
      return res.status(409).json({
        success: false,
        error: 'El slug ya está en uso'
      });
    }

    console.log('✅ 5. Slug disponible, creando restaurante...');

    // Crear restaurante
    const restaurant = await Restaurant.create(restaurantData);

    console.log('✅ 6. Restaurante creado exitosamente:', restaurant);

    res.status(201).json({
      success: true,
      message: 'Restaurante creado exitosamente',
      data: restaurant
    });

  } catch (error) {
    console.error('🔴 ERROR COMPLETO:', {
      message: error.message,
      stack: error.stack,
      code: error.code,
      detail: error.detail
    });
    
    res.status(500).json({
      success: false,
      error: 'Error creando restaurante: ' + error.message
    });
  }
});

  /**
   * Actualiza un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateRestaurant = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inválido",
        });
      }

      // Validar datos de actualización
      const validation = ValidationService.validateRestaurantUpdate(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error,
        });
      }

      const updateData = validation.data;

      // Si se está actualizando el slug, verificar disponibilidad
      if (updateData.slug) {
        const isSlugAvailable = await Restaurant.isSlugAvailable(
          updateData.slug,
          id
        );
        if (!isSlugAvailable) {
          return res.status(409).json({
            success: false,
            error: "El slug ya está en uso",
          });
        }
      }

      // Actualizar restaurante
      const updatedRestaurant = await Restaurant.update(id, updateData);

      logger.info("Restaurante actualizado", {
        restaurantId: id,
        updatedFields: Object.keys(updateData),
      });

      res.json({
        success: true,
        message: "Restaurante actualizado exitosamente",
        data: updatedRestaurant,
      });
    } catch (error) {
      logger.error("Error actualizando restaurante:", error);

      if (error.message.includes("no encontrado")) {
        res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      } else if (error.message.includes("ya está en uso")) {
        res.status(409).json({
          success: false,
          error: error.message,
        });
      } else {
        res.status(500).json({
          success: false,
          error: "Error actualizando restaurante",
        });
      }
    }
  });

  /**
   * Actualiza configuración de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateRestaurantSettings = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inválido",
        });
      }

      const {
        claude_api_key,
        claude_model,
        ai_personality,
        welcome_message,
        goodbye_message,
        error_message,
        auto_confirm_orders,
        require_phone_validation,
        max_conversation_time,
        notification_email,
        notification_phone,
      } = req.body;

      // Validar campos específicos si están presentes
      if (
        notification_email &&
        !ValidationService.isValidEmail(notification_email)
      ) {
        return res.status(400).json({
          success: false,
          error: "Email de notificación inválido",
        });
      }

      if (
        notification_phone &&
        !ValidationService.isValidMexicanPhone(notification_phone)
      ) {
        return res.status(400).json({
          success: false,
          error: "Teléfono de notificación inválido",
        });
      }

      const settingsData = {
        claude_api_key,
        claude_model,
        ai_personality,
        welcome_message,
        goodbye_message,
        error_message,
        auto_confirm_orders,
        require_phone_validation,
        max_conversation_time,
        notification_email,
        notification_phone,
      };

      // Remover campos undefined
      Object.keys(settingsData).forEach((key) => {
        if (settingsData[key] === undefined) {
          delete settingsData[key];
        }
      });

      if (Object.keys(settingsData).length === 0) {
        return res.status(400).json({
          success: false,
          error: "No hay configuraciones para actualizar",
        });
      }

      // Actualizar configuración
      const updatedSettings = await Restaurant.updateSettings(id, settingsData);

      logger.info("Configuración de restaurante actualizada", {
        restaurantId: id,
        updatedFields: Object.keys(settingsData),
      });

      res.json({
        success: true,
        message: "Configuración actualizada exitosamente",
        data: updatedSettings,
      });
    } catch (error) {
      logger.error("Error actualizando configuración de restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error actualizando configuración",
      });
    }
  });

  /**
   * Desactiva un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static deactivateRestaurant = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inválido",
        });
      }

      const success = await Restaurant.deactivate(id);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante desactivado", { restaurantId: id });

      res.json({
        success: true,
        message: "Restaurante desactivado exitosamente",
      });
    } catch (error) {
      logger.error("Error desactivando restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error desactivando restaurante",
      });
    }
  });

  /**
   * Activa un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static activateRestaurant = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inválido",
        });
      }

      const success = await Restaurant.activate(id);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante activado", { restaurantId: id });

      res.json({
        success: true,
        message: "Restaurante activado exitosamente",
      });
    } catch (error) {
      logger.error("Error activando restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error activando restaurante",
      });
    }
  });

  /**
   * Obtiene estadísticas de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getRestaurantStats = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inválido",
        });
      }

      // Validar parámetros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(
        req.query
      );
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error,
        });
      }

      const { start_date, end_date } = dateValidation.data;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      // Obtener estadísticas
      const stats = await Restaurant.getStats(id, dateRange);

      logger.info("Estadísticas de restaurante obtenidas", {
        restaurantId: id,
        dateRange: dateRange,
      });

      res.json({
        success: true,
        data: stats,
      });
    } catch (error) {
      logger.error("Error obteniendo estadísticas de restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo estadísticas",
      });
    }
  });

  /**
   * Verifica disponibilidad de slug
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static checkSlugAvailability = asyncHandler(async (req, res) => {
    try {
      const { slug } = req.params;
      const { exclude_id } = req.query;

      if (!slug || slug.length < 2) {
        return res.status(400).json({
          success: false,
          error: "Slug inválido",
        });
      }

      if (exclude_id && !ValidationService.isValidUUID(exclude_id)) {
        return res.status(400).json({
          success: false,
          error: "ID de exclusión inválido",
        });
      }

      const isAvailable = await Restaurant.isSlugAvailable(slug, exclude_id);

      res.json({
        success: true,
        data: {
          slug,
          available: isAvailable,
        },
      });
    } catch (error) {
      logger.error("Error verificando disponibilidad de slug:", error);
      res.status(500).json({
        success: false,
        error: "Error verificando disponibilidad",
      });
    }
  });

  /**
   * Obtiene el restaurante actual (basado en el middleware de tenant)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCurrentRestaurant = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      // Obtener datos completos del restaurante
      const restaurant = await Restaurant.findById(req.restaurant.id);

      if (!restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      res.json({
        success: true,
        data: restaurant,
      });
    } catch (error) {
      logger.error("Error obteniendo restaurante actual:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurante",
      });
    }
  });

  /**
   * Actualiza el restaurante actual
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateCurrentRestaurant = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      // Reutilizar lógica de actualización
      req.params.id = req.restaurant.id;
      return RestaurantController.updateRestaurant(req, res);
    } catch (error) {
      logger.error("Error actualizando restaurante actual:", error);
      res.status(500).json({
        success: false,
        error: "Error actualizando restaurante",
      });
    }
  });

  /**
   * Obtiene estadísticas del restaurante actual
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCurrentRestaurantStats = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      // Reutilizar lógica de estadísticas
      req.params.id = req.restaurant.id;
      return RestaurantController.getRestaurantStats(req, res);
    } catch (error) {
      logger.error(
        "Error obteniendo estadísticas del restaurante actual:",
        error
      );
      res.status(500).json({
        success: false,
        error: "Error obteniendo estadísticas",
      });
    }
  });

  /**
   * Obtiene resumen del dashboard del restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getDashboardSummary = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      const restaurantId = req.restaurant.id;

      // Obtener estadísticas de diferentes períodos
      const [todayStats, weekStats, monthStats] = await Promise.all([
        Restaurant.getStats(restaurantId, {
          startDate: new Date().toISOString().split("T")[0],
          endDate: new Date().toISOString().split("T")[0],
        }),
        Restaurant.getStats(restaurantId, {
          startDate: new Date(
            Date.now() - 7 * 24 * 60 * 60 * 1000
          ).toISOString(),
          endDate: new Date().toISOString(),
        }),
        Restaurant.getStats(restaurantId, {
          startDate: new Date(
            Date.now() - 30 * 24 * 60 * 60 * 1000
          ).toISOString(),
          endDate: new Date().toISOString(),
        }),
      ]);

      const summary = {
        restaurant: {
          id: req.restaurant.id,
          name: req.restaurant.name,
          slug: req.restaurant.slug,
          is_active: req.restaurant.is_active,
        },
        stats: {
          today: todayStats,
          week: weekStats,
          month: monthStats,
        },
        generated_at: new Date().toISOString(),
      };

      res.json({
        success: true,
        data: summary,
      });
    } catch (error) {
      logger.error("Error obteniendo resumen del dashboard:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo resumen",
      });
    }
  });
}

module.exports = RestaurantController;



================================================
File: src/controllers/webhookController.js
================================================
const WhatsAppService = require('../services/whatsappService');
const ConversationService = require('../services/conversationService');
const ValidationService = require('../services/validationService');
const logger = require('../utils/logger');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE WEBHOOKS
// ============================================

class WebhookController {

  /**
   * Maneja webhooks de WhatsApp (Twilio y Meta)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleWhatsAppWebhook = asyncHandler(async (req, res) => {
    try {
      const provider = req.query.provider || 'twilio';
      
      logger.debug('Webhook recibido', {
        provider,
        headers: req.headers,
        body: req.body,
        query: req.query
      });

      // Validar webhook según el proveedor
      const validationResult = WhatsAppService.validateWebhook(req, provider);
      
      if (!validationResult) {
        logger.warn('Webhook inválido recibido', {
          provider,
          ip: req.ip,
          userAgent: req.get('User-Agent')
        });
        
        return res.status(403).json({
          success: false,
          error: 'Webhook no autorizado'
        });
      }

      // Para Meta WhatsApp, manejar verificación de webhook
      if (provider === 'meta' && req.method === 'GET') {
        logger.info('Verificación de webhook de Meta WhatsApp exitosa');
        return res.status(200).send(validationResult);
      }

      // Validar datos del webhook
      const webhookValidation = ValidationService.validateWhatsAppWebhook(req.body, provider);
      if (!webhookValidation.isValid) {
        logger.warn('Datos de webhook inválidos', {
          provider,
          error: webhookValidation.error
        });
        
        return res.status(400).json({
          success: false,
          error: 'Datos de webhook inválidos'
        });
      }

      // Procesar mensaje entrante
      const messageData = WhatsAppService.processIncomingMessage(req.body, provider);
      
      if (!messageData) {
        logger.debug('Webhook sin mensaje procesable (posible notificación de estado)');
        return res.status(200).json({ success: true, message: 'Webhook procesado' });
      }

      // Verificar que hay un restaurante asociado
      if (!req.restaurant) {
        logger.warn('Mensaje recibido sin restaurante asociado', {
          provider,
          from: messageData.from?.substring(0, 8) + '****',
          to: messageData.to
        });
        
        return res.status(200).json({
          success: false,
          message: 'Restaurante no encontrado'
        });
      }

      // Procesar mensaje de forma asíncrona para responder rápido al webhook
      setImmediate(async () => {
        try {
          await WebhookController.processIncomingMessage(req.restaurant, messageData);
        } catch (error) {
          logger.error('Error procesando mensaje de forma asíncrona:', error);
        }
      });

      // Responder inmediatamente al webhook
      res.status(200).json({
        success: true,
        message: 'Mensaje recibido y procesándose'
      });

    } catch (error) {
      logger.error('Error manejando webhook de WhatsApp:', error);
      
      // Siempre responder 200 para evitar reintentos innecesarios
      res.status(200).json({
        success: false,
        error: 'Error interno procesando webhook'
      });
    }
  });

  /**
   * Verifica webhook de Meta WhatsApp (método GET)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static verifyMetaWebhook = asyncHandler(async (req, res) => {
    try {
      const mode = req.query['hub.mode'];
      const token = req.query['hub.verify_token'];
      const challenge = req.query['hub.challenge'];

      logger.info('Verificación de webhook Meta WhatsApp solicitada', {
        mode,
        token: token ? token.substring(0, 10) + '...' : 'none'
      });

      const validationResult = WhatsAppService.validateWebhook(req, 'meta');
      
      if (validationResult && validationResult === challenge) {
        logger.info('Verificación de webhook exitosa');
        return res.status(200).send(challenge);
      } else {
        logger.warn('Verificación de webhook fallida');
        return res.status(403).send('Error de verificación');
      }

    } catch (error) {
      logger.error('Error verificando webhook de Meta:', error);
      res.status(500).send('Error interno');
    }
  });

  /**
   * Webhook específico para Twilio
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleTwilioWebhook = asyncHandler(async (req, res) => {
    req.query.provider = 'twilio';
    return WebhookController.handleWhatsAppWebhook(req, res);
  });

  /**
   * Webhook específico para Meta WhatsApp
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleMetaWebhook = asyncHandler(async (req, res) => {
    // Manejar verificación GET
    if (req.method === 'GET') {
      return WebhookController.verifyMetaWebhook(req, res);
    }
    
    // Manejar mensajes POST
    req.query.provider = 'meta';
    return WebhookController.handleWhatsAppWebhook(req, res);
  });

  /**
   * Procesa mensaje entrante
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} messageData - Datos del mensaje
   */
  static async processIncomingMessage(restaurant, messageData) {
    try {
      const startTime = Date.now();

      logger.info('Procesando mensaje entrante', {
        restaurantId: restaurant.id,
        restaurantName: restaurant.name,
        customerPhone: messageData.from?.substring(0, 8) + '****',
        messageLength: messageData.body?.length || 0,
        hasMedia: !!messageData.mediaUrl
      });

      // Verificar que el restaurante esté activo
      if (!restaurant.is_active) {
        logger.warn('Mensaje recibido para restaurante inactivo', {
          restaurantId: restaurant.id
        });
        return;
      }

      // Verificar horarios de operación
      if (!this.isRestaurantOpen(restaurant)) {
        await this.sendClosedMessage(messageData.from, restaurant);
        return;
      }

      // Procesar mensaje con el servicio de conversaciones
      const result = await ConversationService.processIncomingMessage({
        restaurant,
        customerPhone: messageData.from,
        messageText: messageData.body || '',
        messageData
      });

      const processingTime = Date.now() - startTime;

      if (result.success) {
        logger.info('Mensaje procesado exitosamente', {
          restaurantId: restaurant.id,
          customerPhone: messageData.from?.substring(0, 8) + '****',
          processingTime: `${processingTime}ms`,
          conversationId: result.conversation?.id,
          actionsProcessed: result.actions_processed?.length || 0,
          claudeUsage: result.claudeResult?.usage
        });
      } else {
        logger.error('Error procesando mensaje', {
          restaurantId: restaurant.id,
          customerPhone: messageData.from?.substring(0, 8) + '****',
          processingTime: `${processingTime}ms`,
          error: result.error
        });
      }

    } catch (error) {
      logger.error('Error en procesamiento de mensaje:', error);
      
      // Intentar enviar mensaje de error al cliente
      try {
        await WhatsAppService.sendMessage(
          messageData.from,
          restaurant.error_message || 'Lo siento, tuve un problema técnico. ¿Podrías repetir tu mensaje?'
        );
      } catch (sendError) {
        logger.error('Error enviando mensaje de error:', sendError);
      }
    }
  }

  /**
   * Verifica si el restaurante está abierto
   * @param {Object} restaurant - Datos del restaurante
   * @returns {boolean} True si está abierto
   */
  static isRestaurantOpen(restaurant) {
    try {
      if (!restaurant.opens_at || !restaurant.closes_at) {
        return true; // Si no hay horarios definidos, asumir abierto
      }

      const now = new Date();
      const currentTime = now.toTimeString().slice(0, 8); // HH:mm:ss

      const opensAt = restaurant.opens_at;
      const closesAt = restaurant.closes_at;

      // Manejar caso donde cierra después de medianoche
      if (closesAt < opensAt) {
        return currentTime >= opensAt || currentTime <= closesAt;
      }

      return currentTime >= opensAt && currentTime <= closesAt;

    } catch (error) {
      logger.error('Error verificando horarios de restaurante:', error);
      return true; // En caso de error, asumir abierto
    }
  }

  /**
   * Envía mensaje de restaurante cerrado
   * @param {string} customerPhone - Teléfono del cliente
   * @param {Object} restaurant - Datos del restaurante
   */
  static async sendClosedMessage(customerPhone, restaurant) {
    try {
      const message = `🕐 Lo siento, ${restaurant.name} está cerrado en este momento.\n\n` +
                     `⏰ Nuestros horarios son: ${restaurant.opens_at} - ${restaurant.closes_at}\n\n` +
                     `¡Te esperamos durante nuestro horario de atención! 😊`;

      await WhatsAppService.sendMessage(customerPhone, message);

      logger.info('Mensaje de restaurante cerrado enviado', {
        restaurantId: restaurant.id,
        customerPhone: customerPhone?.substring(0, 8) + '****'
      });

    } catch (error) {
      logger.error('Error enviando mensaje de restaurante cerrado:', error);
    }
  }

  /**
   * Maneja webhooks de prueba/desarrollo
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleTestWebhook = asyncHandler(async (req, res) => {
    try {
      logger.info('Webhook de prueba recibido', {
        method: req.method,
        headers: req.headers,
        body: req.body,
        query: req.query
      });

      // En desarrollo, simular procesamiento
      if (process.env.NODE_ENV === 'development') {
        const testMessage = {
          messageId: 'test-' + Date.now(),
          from: req.body.from || '+525512345678',
          to: req.body.to || '+525587654321',
          body: req.body.message || 'Mensaje de prueba',
          timestamp: new Date(),
          provider: 'test'
        };

        if (req.restaurant) {
          setImmediate(async () => {
            try {
              await WebhookController.processIncomingMessage(req.restaurant, testMessage);
            } catch (error) {
              logger.error('Error procesando mensaje de prueba:', error);
            }
          });
        }

        return res.status(200).json({
          success: true,
          message: 'Webhook de prueba procesado',
          data: testMessage
        });
      }

      res.status(200).json({
        success: true,
        message: 'Webhook de prueba recibido'
      });

    } catch (error) {
      logger.error('Error manejando webhook de prueba:', error);
      res.status(500).json({
        success: false,
        error: 'Error procesando webhook de prueba'
      });
    }
  });

  /**
   * Obtiene estadísticas de webhooks
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getWebhookStats = asyncHandler(async (req, res) => {
    try {
      // Esta función requeriría una tabla de logs de webhooks
      // Por ahora retornamos estadísticas básicas
      const stats = {
        total_webhooks_received: 0,
        successful_processing: 0,
        failed_processing: 0,
        avg_processing_time: 0,
        providers: {
          twilio: 0,
          meta: 0,
          test: 0
        },
        last_24h: {
          total: 0,
          successful: 0,
          failed: 0
        }
      };

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      logger.error('Error obteniendo estadísticas de webhooks:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estadísticas'
      });
    }
  });

  /**
   * Reinicia una conversación específica
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static restartConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.body;
      
      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Teléfono del cliente es requerido'
        });
      }

      if (!req.restaurant) {
        return res.status(400).json({
          success: false,
          error: 'Restaurante no identificado'
        });
      }

      // Reiniciar conversación
      const result = await ConversationService.restartConversation(
        req.restaurant.id,
        customerPhone
      );

      logger.info('Conversación reiniciada manualmente', {
        restaurantId: req.restaurant.id,
        customerPhone: customerPhone?.substring(0, 8) + '****',
        newConversationId: result.conversation?.id
      });

      res.json({
        success: true,
        message: 'Conversación reiniciada exitosamente',
        data: {
          conversation_id: result.conversation?.id,
          customer_id: result.customer?.id
        }
      });

    } catch (error) {
      logger.error('Error reiniciando conversación:', error);
      res.status(500).json({
        success: false,
        error: 'Error reiniciando conversación'
      });
    }
  });

  /**
   * Envía mensaje manual desde el dashboard
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static sendManualMessage = asyncHandler(async (req, res) => {
    try {
      const { customerPhone, message } = req.body;

      if (!customerPhone || !message) {
        return res.status(400).json({
          success: false,
          error: 'Teléfono del cliente y mensaje son requeridos'
        });
      }

      if (!req.restaurant) {
        return res.status(400).json({
          success: false,
          error: 'Restaurante no identificado'
        });
      }

      // Validar mensaje
      const validation = ValidationService.validateIncomingMessage(message, null);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      // Enviar mensaje
      const result = await WhatsAppService.sendMessage(customerPhone, message, {
        addEmojis: true,
        restaurantName: req.restaurant.name
      });

      logger.info('Mensaje manual enviado', {
        restaurantId: req.restaurant.id,
        customerPhone: customerPhone?.substring(0, 8) + '****',
        messageLength: message.length,
        success: result.success
      });

      res.json({
        success: true,
        message: 'Mensaje enviado exitosamente',
        data: {
          message_id: result.messageId,
          provider: result.provider
        }
      });

    } catch (error) {
      logger.error('Error enviando mensaje manual:', error);
      res.status(500).json({
        success: false,
        error: 'Error enviando mensaje'
      });
    }
  });
}

module.exports = WebhookController;


================================================
File: src/middleware/auth.js
================================================
const jwt = require("jsonwebtoken");
const bcrypt = require("bcryptjs");
const logger = require("../utils/logger");
const { AuthenticationError, AuthorizationError } = require("./errorHandler");

// ============================================
// MIDDLEWARE DE AUTENTICACIÓN
// ============================================

class AuthMiddleware {
  /**
   * Genera un JWT token
   * @param {Object} payload - Datos a incluir en el token
   * @param {Object} options - Opciones del token
   * @returns {string} JWT token
   */
  static generateToken(payload, options = {}) {
    const defaultOptions = {
      expiresIn: process.env.JWT_EXPIRES_IN || "24h",
      issuer: "ChatBot-Chingon",
      audience: "restaurant-api",
    };

    const tokenOptions = { ...defaultOptions, ...options };

    try {
      return jwt.sign(payload, process.env.JWT_SECRET, tokenOptions);
    } catch (error) {
      logger.error("Error generando JWT token:", error);
      throw new Error("Error generando token de autenticación");
    }
  }

  /**
   * Verifica un JWT token
   * @param {string} token - Token a verificar
   * @returns {Object} Payload decodificado
   */
  static verifyToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      if (error.name === "TokenExpiredError") {
        throw new AuthenticationError("Token expirado");
      } else if (error.name === "JsonWebTokenError") {
        throw new AuthenticationError("Token inválido");
      } else {
        logger.error("Error verificando JWT token:", error);
        throw new AuthenticationError("Error de autenticación");
      }
    }
  }

  /**
   * Hash de contraseña usando bcrypt
   * @param {string} password - Contraseña a hashear
   * @returns {Promise<string>} Hash de la contraseña
   */
  static async hashPassword(password) {
    try {
      const saltRounds = parseInt(process.env.BCRYPT_ROUNDS) || 10;
      return await bcrypt.hash(password, saltRounds);
    } catch (error) {
      logger.error("Error hasheando contraseña:", error);
      throw new Error("Error procesando contraseña");
    }
  }

  /**
   * Compara contraseña con hash
   * @param {string} password - Contraseña en texto plano
   * @param {string} hash - Hash almacenado
   * @returns {Promise<boolean>} True si coinciden
   */
  static async comparePassword(password, hash) {
    try {
      return await bcrypt.compare(password, hash);
    } catch (error) {
      logger.error("Error comparando contraseña:", error);
      return false;
    }
  }

  /**
   * Extrae token del header Authorization
   * @param {Object} req - Request object
   * @returns {string|null} Token extraído
   */
  static extractTokenFromHeader(req) {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return null;
    }

    // Formato esperado: "Bearer <token>"
    const parts = authHeader.split(" ");

    if (parts.length !== 2 || parts[0] !== "Bearer") {
      return null;
    }

    return parts[1];
  }

  /**
   * Middleware principal de autenticación JWT
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static authenticateToken = (req, res, next) => {
    try {
      const token = AuthMiddleware.extractTokenFromHeader(req); // Cambiar this por AuthMiddleware

      if (!token) {
        logger.warn("Intento de acceso sin token", {
          ip: req.ip,
          path: req.path,
          userAgent: req.get("User-Agent"),
        });
        throw new AuthenticationError("Token de acceso requerido");
      }

      // Verificar token
      const decoded = AuthMiddleware.verifyToken(token); // Cambiar this por AuthMiddleware

      // Agregar información del usuario al request
      req.user = {
        id: decoded.sub || decoded.userId,
        email: decoded.email,
        role: decoded.role || "user",
        restaurantId: decoded.restaurantId,
        permissions: decoded.permissions || [],
      };

      // Log de acceso exitoso
      logger.debug("Autenticación exitosa", {
        userId: req.user.id,
        role: req.user.role,
        path: req.path,
      });

      next();
    } catch (error) {
      if (error instanceof AuthenticationError) {
        logger.warn("Error de autenticación", {
          error: error.message,
          ip: req.ip,
          path: req.path,
        });
      } else {
        logger.error("Error inesperado en autenticación:", error);
      }

      next(error);
    }
  };

  /**
   * Middleware de autenticación opcional
   * No falla si no hay token, pero lo procesa si existe
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static optionalAuth = (req, res, next) => {
    try {
      const token = AuthMiddleware.extractTokenFromHeader(req);

      if (!token) {
        // No hay token, continuar sin autenticación
        req.user = null;
        return next();
      }

      // Hay token, intentar verificarlo
      try {
        const decoded = AuthMiddleware.verifyToken(token);

        req.user = {
          id: decoded.sub || decoded.userId,
          email: decoded.email,
          role: decoded.role || "user",
          restaurantId: decoded.restaurantId,
          permissions: decoded.permissions || [],
        };

        logger.debug("Autenticación opcional exitosa", {
          userId: req.user.id,
          path: req.path,
        });
      } catch (authError) {
        // Token inválido, continuar sin autenticación
        logger.warn("Token inválido en autenticación opcional", {
          error: authError.message,
          path: req.path,
        });
        req.user = null;
      }

      next();
    } catch (error) {
      logger.error("Error en autenticación opcional:", error);
      // En caso de error, continuar sin autenticación
      req.user = null;
      next();
    }
  };

  /**
   * Middleware para verificar roles específicos
   * @param {Array|string} allowedRoles - Roles permitidos
   * @returns {Function} Middleware function
   */
  static requireRole = (allowedRoles) => {
    const roles = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];

    return (req, res, next) => {
      try {
        if (!req.user) {
          throw new AuthenticationError("Autenticación requerida");
        }

        const userRole = req.user.role;

        if (!roles.includes(userRole)) {
          logger.warn("Acceso denegado por rol insuficiente", {
            userId: req.user.id,
            userRole,
            requiredRoles: roles,
            path: req.path,
          });
          throw new AuthorizationError(
            `Acceso denegado. Roles requeridos: ${roles.join(", ")}`
          );
        }

        logger.debug("Verificación de rol exitosa", {
          userId: req.user.id,
          userRole,
          path: req.path,
        });

        next();
      } catch (error) {
        next(error);
      }
    };
  };

  /**
   * Middleware para verificar permisos específicos
   * @param {Array|string} requiredPermissions - Permisos requeridos
   * @returns {Function} Middleware function
   */
  static requirePermission = (requiredPermissions) => {
    const permissions = Array.isArray(requiredPermissions)
      ? requiredPermissions
      : [requiredPermissions];

    return (req, res, next) => {
      try {
        if (!req.user) {
          throw new AuthenticationError("Autenticación requerida");
        }

        const userPermissions = req.user.permissions || [];

        // Verificar si el usuario tiene todos los permisos requeridos
        const hasAllPermissions = permissions.every((permission) =>
          userPermissions.includes(permission)
        );

        if (!hasAllPermissions) {
          logger.warn("Acceso denegado por permisos insuficientes", {
            userId: req.user.id,
            userPermissions,
            requiredPermissions: permissions,
            path: req.path,
          });
          throw new AuthorizationError("Permisos insuficientes");
        }

        logger.debug("Verificación de permisos exitosa", {
          userId: req.user.id,
          permissions,
          path: req.path,
        });

        next();
      } catch (error) {
        next(error);
      }
    };
  };

  /**
   * Middleware para verificar acceso al restaurante
   * Verifica que el usuario tenga acceso al restaurante especificado
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static requireRestaurantAccess = (req, res, next) => {
    try {
      if (!req.user) {
        throw new AuthenticationError("Autenticación requerida");
      }

      // Super admin puede acceder a cualquier restaurante
      if (req.user.role === "super_admin") {
        return next();
      }

      // Obtener ID del restaurante de diferentes fuentes
      const restaurantId =
        req.restaurant?.id ||
        req.params.restaurantId ||
        req.body.restaurant_id ||
        req.user.restaurantId;

      if (!restaurantId) {
        throw new AuthorizationError("ID de restaurante no especificado");
      }

      // Verificar que el usuario pertenece al restaurante
      if (req.user.restaurantId !== restaurantId) {
        logger.warn("Intento de acceso a restaurante no autorizado", {
          userId: req.user.id,
          userRestaurantId: req.user.restaurantId,
          requestedRestaurantId: restaurantId,
          path: req.path,
        });
        throw new AuthorizationError("Acceso denegado al restaurante");
      }

      logger.debug("Acceso al restaurante autorizado", {
        userId: req.user.id,
        restaurantId,
        path: req.path,
      });

      next();
    } catch (error) {
      next(error);
    }
  };

  /**
   * Middleware para API keys (para integraciones)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static authenticateApiKey = (req, res, next) => {
    try {
      const apiKey = req.headers["x-api-key"] || req.query.api_key;

      if (!apiKey) {
        throw new AuthenticationError("API Key requerida");
      }

      // Verificar API key (en una implementación real, esto estaría en la BD)
      // Por ahora usamos una verificación simple con variable de entorno
      const validApiKeys = (process.env.VALID_API_KEYS || "")
        .split(",")
        .filter(Boolean);

      if (!validApiKeys.includes(apiKey)) {
        logger.warn("API Key inválida utilizada", {
          apiKey: apiKey.substring(0, 8) + "****",
          ip: req.ip,
          path: req.path,
        });
        throw new AuthenticationError("API Key inválida");
      }

      // Establecer información básica del "usuario" API
      req.user = {
        id: "api-user",
        role: "api",
        type: "api_key",
        permissions: ["read", "write"], // Permisos básicos para API
      };

      logger.debug("Autenticación con API Key exitosa", {
        apiKey: apiKey.substring(0, 8) + "****",
        path: req.path,
      });

      next();
    } catch (error) {
      next(error);
    }
  };

  /**
   * Middleware que permite autenticación con JWT o API Key
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static authenticateJwtOrApiKey = (req, res, next) => {
    const hasJwtToken = !!AuthMiddleware.extractTokenFromHeader(req);
    const hasApiKey = !!(req.headers["x-api-key"] || req.query.api_key);

    if (hasJwtToken) {
      // Usar autenticación JWT
      return AuthMiddleware.authenticateToken(req, res, next);
    } else if (hasApiKey) {
      // Usar autenticación API Key
      return AuthMiddleware.authenticateApiKey(req, res, next);
    } else {
      // Ningún método de autenticación proporcionado
      throw new AuthenticationError("Token JWT o API Key requerido");
    }
  };

  /**
   * Middleware para refrescar tokens
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static refreshToken = (req, res, next) => {
    try {
      const { refresh_token } = req.body;

      if (!refresh_token) {
        throw new AuthenticationError("Refresh token requerido");
      }

      // Verificar refresh token
      const decoded = AuthMiddleware.verifyToken(refresh_token); // Cambiar this por AuthMiddleware

      if (decoded.type !== "refresh") {
        throw new AuthenticationError("Token de refresco inválido");
      }

      // Generar nuevo access token
      const newToken = AuthMiddleware.generateToken({
        sub: decoded.sub,
        email: decoded.email,
        role: decoded.role,
        restaurantId: decoded.restaurantId,
        permissions: decoded.permissions,
      });

      req.newToken = newToken;
      req.user = {
        id: decoded.sub,
        email: decoded.email,
        role: decoded.role,
        restaurantId: decoded.restaurantId,
        permissions: decoded.permissions,
      };

      logger.info("Token refrescado exitosamente", {
        userId: req.user.id,
      });

      next();
    } catch (error) {
      next(error);
    }
  };

  /**
   * Genera tokens de acceso y refresco
   * @param {Object} payload - Datos del usuario
   * @returns {Object} Tokens generados
   */
  static generateTokenPair(payload) {
    const accessToken = AuthMiddleware.generateToken(payload, {
      expiresIn: "1h",
    });
    const refreshToken = AuthMiddleware.generateToken(
      { ...payload, type: "refresh" },
      { expiresIn: "7d" }
    );

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      token_type: "Bearer",
      expires_in: 3600, // 1 hora en segundos
    };
  }

  /**
   * Middleware de logging de autenticación
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static logAuthAttempt = (req, res, next) => {
    const hasAuth = !!(
      AuthMiddleware.extractTokenFromHeader(req) || req.headers["x-api-key"]
    );

    if (hasAuth) {
      logger.debug("Intento de autenticación detectado", {
        path: req.path,
        method: req.method,
        ip: req.ip,
        userAgent: req.get("User-Agent"),
      });
    }

    next();
  };
}

module.exports = AuthMiddleware;



================================================
File: src/middleware/errorHandler.js
================================================
const logger = require('../utils/logger');
const { DEFAULT_MESSAGES } = require('../utils/constants');

// ============================================
// CLASES DE ERROR PERSONALIZADAS
// ============================================

/**
 * Error base para errores de negocio
 */
class AppError extends Error {
  constructor(message, statusCode = 500, isOperational = true) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date().toISOString();
    
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Error de validación
 */
class ValidationError extends AppError {
  constructor(message, field = null) {
    super(message, 400);
    this.field = field;
    this.type = 'validation';
  }
}

/**
 * Error de base de datos
 */
class DatabaseError extends AppError {
  constructor(message, originalError = null) {
    super(message, 500);
    this.originalError = originalError;
    this.type = 'database';
  }
}

/**
 * Error de servicio externo (Claude, WhatsApp)
 */
class ExternalServiceError extends AppError {
  constructor(service, message, statusCode = 503) {
    super(`${service}: ${message}`, statusCode);
    this.service = service;
    this.type = 'external_service';
  }
}

/**
 * Error de autenticación
 */
class AuthenticationError extends AppError {
  constructor(message = 'No autorizado') {
    super(message, 401);
    this.type = 'authentication';
  }
}

/**
 * Error de autorización
 */
class AuthorizationError extends AppError {
  constructor(message = 'Acceso denegado') {
    super(message, 403);
    this.type = 'authorization';
  }
}

/**
 * Error de recurso no encontrado
 */
class NotFoundError extends AppError {
  constructor(resource = 'Recurso') {
    super(`${resource} no encontrado`, 404);
    this.type = 'not_found';
  }
}

/**
 * Error de conflicto (recurso ya existe)
 */
class ConflictError extends AppError {
  constructor(message = 'Conflicto con recurso existente') {
    super(message, 409);
    this.type = 'conflict';
  }
}

/**
 * Error de rate limiting
 */
class RateLimitError extends AppError {
  constructor(message = 'Demasiadas solicitudes') {
    super(message, 429);
    this.type = 'rate_limit';
  }
}

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Determina si un error es operacional (esperado) o de programación
 * @param {Error} error 
 * @returns {boolean}
 */
const isOperationalError = (error) => {
  if (error instanceof AppError) {
    return error.isOperational;
  }
  
  // Errores comunes que consideramos operacionales
  const operationalErrors = [
    'ValidationError',
    'CastError',
    'MongoError',
    'SequelizeValidationError',
    'SequelizeUniqueConstraintError'
  ];
  
  return operationalErrors.includes(error.name);
};

/**
 * Extrae información útil del error
 * @param {Error} error 
 * @returns {Object}
 */
const getErrorInfo = (error) => {
  const info = {
    name: error.name,
    message: error.message,
    timestamp: new Date().toISOString(),
  };

  // Información específica por tipo de error
  if (error instanceof AppError) {
    info.type = error.type;
    info.statusCode = error.statusCode;
    info.isOperational = error.isOperational;
  }

  // Errores de base de datos PostgreSQL
  if (error.code) {
    info.code = error.code;
    
    switch (error.code) {
      case '23505': // unique_violation
        info.type = 'unique_constraint';
        info.constraint = error.constraint;
        break;
      case '23503': // foreign_key_violation
        info.type = 'foreign_key_violation';
        info.constraint = error.constraint;
        break;
      case '23502': // not_null_violation
        info.type = 'not_null_violation';
        info.column = error.column;
        break;
      case '22001': // string_data_right_truncation
        info.type = 'string_too_long';
        break;
      case '08006': // connection_failure
        info.type = 'connection_failure';
        break;
    }
  }

  // Errores de validación de Joi
  if (error.isJoi) {
    info.type = 'joi_validation';
    info.details = error.details.map(detail => ({
      field: detail.path.join('.'),
      message: detail.message,
      value: detail.context?.value
    }));
  }

  return info;
};

/**
 * Genera una respuesta de error consistente
 * @param {Error} error 
 * @param {Object} req 
 * @returns {Object}
 */
const generateErrorResponse = (error, req) => {
  const errorInfo = getErrorInfo(error);
  const isDevelopment = process.env.NODE_ENV === 'development';
  
  // Respuesta base
  const response = {
    success: false,
    error: {
      message: errorInfo.message,
      type: errorInfo.type || 'unknown',
      timestamp: errorInfo.timestamp,
      requestId: req.id || req.headers['x-request-id']
    }
  };

  // En desarrollo, incluir más detalles
  if (isDevelopment) {
    response.error.stack = error.stack;
    response.error.details = errorInfo;
    
    if (req.body && Object.keys(req.body).length > 0) {
      response.error.requestBody = req.body;
    }
    
    if (req.params && Object.keys(req.params).length > 0) {
      response.error.requestParams = req.params;
    }
  }

  // Mensajes amigables para usuarios finales
  const userFriendlyMessages = {
    validation: 'Los datos proporcionados no son válidos',
    database: 'Error interno del servidor',
    external_service: 'Servicio temporalmente no disponible',
    authentication: 'Credenciales inválidas',
    authorization: 'No tienes permisos para realizar esta acción',
    not_found: 'El recurso solicitado no existe',
    conflict: 'El recurso ya existe',
    rate_limit: 'Demasiadas solicitudes, intenta más tarde',
    unique_constraint: 'Ya existe un registro con esos datos',
    foreign_key_violation: 'Referencia inválida',
    not_null_violation: 'Campo requerido faltante'
  };

  // Si no es desarrollo, usar mensaje amigable
  if (!isDevelopment && userFriendlyMessages[errorInfo.type]) {
    response.error.message = userFriendlyMessages[errorInfo.type];
  }

  return response;
};

// ============================================
// MIDDLEWARE PRINCIPAL DE MANEJO DE ERRORES
// ============================================

/**
 * Middleware de manejo de errores para Express
 * Este debe ser el ÚLTIMO middleware en la aplicación
 */
const errorHandler = (error, req, res, next) => {
  const errorInfo = getErrorInfo(error);
  const isOperational = isOperationalError(error);
  
  // Log del error
  if (isOperational) {
    logger.warn('Error operacional capturado', {
      ...errorInfo,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
  } else {
    logger.error('Error no esperado capturado', {
      ...errorInfo,
      stack: error.stack,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      body: req.body,
      params: req.params,
      query: req.query
    });
  }

  // Determinar código de estado HTTP
  let statusCode = 500;
  
  if (error instanceof AppError) {
    statusCode = error.statusCode;
  } else if (error.status) {
    statusCode = error.status;
  } else if (error.statusCode) {
    statusCode = error.statusCode;
  }

  // Generar respuesta
  const response = generateErrorResponse(error, req);
  
  // Enviar respuesta
  res.status(statusCode).json(response);
};

// ============================================
// MIDDLEWARE PARA 404
// ============================================

/**
 * Middleware para rutas no encontradas
 */
const notFoundHandler = (req, res, next) => {
  const error = new NotFoundError(`Ruta ${req.originalUrl}`);
  next(error);
};

// ============================================
// WRAPPER PARA FUNCIONES ASYNC
// ============================================

/**
 * Wrapper para capturar errores en funciones async
 * Evita tener que usar try/catch en cada controlador
 * 
 * @param {Function} fn - Función async a envolver
 * @returns {Function} Función envuelta
 */
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// ============================================
// MANEJADORES ESPECÍFICOS
// ============================================

/**
 * Maneja errores específicos de PostgreSQL
 * @param {Error} error 
 * @returns {AppError}
 */
const handleDatabaseError = (error) => {
  let message = 'Error de base de datos';
  let statusCode = 500;

  switch (error.code) {
    case '23505': // unique_violation
      message = 'Ya existe un registro con esos datos';
      statusCode = 409;
      break;
    case '23503': // foreign_key_violation
      message = 'Referencia inválida a otro registro';
      statusCode = 400;
      break;
    case '23502': // not_null_violation
      message = `El campo ${error.column} es requerido`;
      statusCode = 400;
      break;
    case '22001': // string_data_right_truncation
      message = 'Uno de los campos es demasiado largo';
      statusCode = 400;
      break;
    case '08006': // connection_failure
      message = 'Error de conexión a la base de datos';
      statusCode = 503;
      break;
  }

  return new DatabaseError(message, error);
};

/**
 * Maneja errores de validación de Joi
 * @param {Error} error 
 * @returns {ValidationError}
 */
const handleJoiValidationError = (error) => {
  const messages = error.details.map(detail => detail.message);
  return new ValidationError(messages.join(', '));
};

// ============================================
// MIDDLEWARE DE LOGGING DE ERRORES
// ============================================

/**
 * Middleware que loggea todos los errores que pasan por el sistema
 */
const errorLogger = (error, req, res, next) => {
  // Log específico para diferentes tipos de error
  if (error.code && error.code.startsWith('23')) {
    logger.logDatabase('error', 'unknown', 0, 0, { error: error.message, code: error.code });
  } else if (error.service) {
    logger.error(`Error en servicio ${error.service}`, {
      service: error.service,
      message: error.message,
      statusCode: error.statusCode
    });
  } else {
    logger.error('Error no categorizado', {
      name: error.name,
      message: error.message,
      stack: error.stack
    });
  }

  next(error);
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Clases de error
  AppError,
  ValidationError,
  DatabaseError,
  ExternalServiceError,
  AuthenticationError,
  AuthorizationError,
  NotFoundError,
  ConflictError,
  RateLimitError,
  
  // Middleware
  errorHandler,
  notFoundHandler,
  errorLogger,
  asyncHandler,
  
  // Utilidades
  isOperationalError,
  getErrorInfo,
  generateErrorResponse,
  handleDatabaseError,
  handleJoiValidationError
};


================================================
File: src/middleware/rateLimiter.js
================================================
const rateLimit = require('express-rate-limit');
const logger = require('../utils/logger');
const { RATE_LIMITS, SECURITY_EVENTS } = require('../utils/constants');
const { RateLimitError } = require('./errorHandler');

// ============================================
// CONFIGURACIÓN BASE DE RATE LIMITING
// ============================================

/**
 * Configuración base para todos los rate limiters
 */
const baseConfig = {
  standardHeaders: true, // Retorna rate limit info en headers `RateLimit-*`
  legacyHeaders: false, // Deshabilita headers `X-RateLimit-*`
  
  // Función personalizada para generar key
  keyGenerator: (req) => {
    // Usar IP + User-Agent para mejor identificación
    const ip = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('User-Agent') || 'unknown';
    return `${ip}:${Buffer.from(userAgent).toString('base64').substring(0, 20)}`;
  },

  // Handler cuando se excede el límite
  handler: (req, res, next) => {
    const clientInfo = {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      url: req.originalUrl,
      method: req.method
    };

    logger.logSecurity(SECURITY_EVENTS.RATE_LIMIT_EXCEEDED, 'medium', {
      ...clientInfo,
      limit: req.rateLimit.limit,
      remaining: req.rateLimit.remaining,
      resetTime: new Date(req.rateLimit.resetTime)
    });

    const error = new RateLimitError(
      process.env.RATE_LIMIT_MESSAGE || 'Demasiadas solicitudes, intenta en unos minutos'
    );
    
    next(error);
  },

  // Función para omitir ciertos requests
  skip: (req) => {
    // No aplicar rate limiting en desarrollo si está configurado
    if (process.env.NODE_ENV === 'development' && process.env.SKIP_RATE_LIMIT === 'true') {
      return true;
    }

    // No aplicar a health checks
    if (req.path === '/health') {
      return true;
    }

    return false;
  }
};

// ============================================
// RATE LIMITERS ESPECÍFICOS
// ============================================

/**
 * Rate limiter general para API
 */
const apiLimiter = rateLimit({
  ...baseConfig,
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutos
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || RATE_LIMITS.API_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas solicitudes desde esta IP, intenta de nuevo en 15 minutos',
      retryAfter: 15 * 60
    }
  }
});

/**
 * Rate limiter estricto para webhooks
 */
const webhookLimiter = rateLimit({
  ...baseConfig,
  windowMs: 1 * 60 * 1000, // 1 minuto
  max: RATE_LIMITS.WEBHOOK_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas solicitudes al webhook',
      retryAfter: 60
    }
  },
  
  // Key específica para webhooks (por proveedor)
  keyGenerator: (req) => {
    const ip = req.ip;
    const provider = req.headers['user-agent']?.includes('Twilio') ? 'twilio' : 
                    req.headers['user-agent']?.includes('facebookexternalhit') ? 'meta' : 'unknown';
    return `webhook:${provider}:${ip}`;
  }
});

/**
 * Rate limiter para operaciones con Claude AI
 */
const claudeLimiter = rateLimit({
  ...baseConfig,
  windowMs: 1 * 60 * 1000, // 1 minuto
  max: RATE_LIMITS.CLAUDE_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas solicitudes a la IA, intenta en un momento',
      retryAfter: 60
    }
  },
  
  // Solo aplicar a rutas que usen Claude
  skip: (req) => {
    if (baseConfig.skip(req)) return true;
    
    // Solo aplicar a rutas específicas
    const claudeRoutes = ['/webhook', '/api/chat'];
    return !claudeRoutes.some(route => req.path.startsWith(route));
  }
});

/**
 * Rate limiter para WhatsApp
 */
const whatsappLimiter = rateLimit({
  ...baseConfig,
  windowMs: 1 * 60 * 1000, // 1 minuto
  max: RATE_LIMITS.WHATSAPP_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiados mensajes de WhatsApp',
      retryAfter: 60
    }
  }
});

/**
 * Rate limiter muy estricto para autenticación
 */
const authLimiter = rateLimit({
  ...baseConfig,
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 5, // Solo 5 intentos cada 15 minutos
  skipSuccessfulRequests: true, // No contar requests exitosos
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiados intentos de autenticación, intenta en 15 minutos',
      retryAfter: 15 * 60
    }
  },

  // Key específica para auth (incluir endpoint)
  keyGenerator: (req) => {
    const ip = req.ip;
    const endpoint = req.path;
    return `auth:${endpoint}:${ip}`;
  }
});

/**
 * Rate limiter para operaciones de administración
 */
const adminLimiter = rateLimit({
  ...baseConfig,
  windowMs: 5 * 60 * 1000, // 5 minutos
  max: 30, // 30 requests cada 5 minutos
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas operaciones administrativas',
      retryAfter: 5 * 60
    }
  }
});

// ============================================
// RATE LIMITER DINÁMICO
// ============================================

/**
 * Rate limiter que se ajusta basado en el endpoint
 * @param {Object} options - Configuración específica
 * @returns {Function} Middleware de rate limiting
 */
const createDynamicLimiter = (options = {}) => {
  const config = {
    ...baseConfig,
    windowMs: options.windowMs || 15 * 60 * 1000,
    max: options.max || 100,
    message: options.message || {
      success: false,
      error: {
        type: 'rate_limit',
        message: 'Demasiadas solicitudes',
        retryAfter: Math.floor((options.windowMs || 15 * 60 * 1000) / 1000)
      }
    },
    ...options
  };

  return rateLimit(config);
};

// ============================================
// MIDDLEWARE DE LOGGING
// ============================================

/**
 * Middleware que loggea información de rate limiting
 */
const rateLimitLogger = (req, res, next) => {
  // Solo loggear si hay información de rate limit
  if (req.rateLimit) {
    const { limit, remaining, resetTime } = req.rateLimit;
    
    // Loggear cuando quedan pocos requests
    if (remaining <= Math.floor(limit * 0.1)) { // 10% o menos
      logger.warn('Rate limit casi alcanzado', {
        ip: req.ip,
        path: req.path,
        method: req.method,
        limit,
        remaining,
        resetTime: new Date(resetTime),
        userAgent: req.get('User-Agent')
      });
    }

    // Agregar headers informativos
    res.set({
      'X-RateLimit-Limit': limit,
      'X-RateLimit-Remaining': remaining,
      'X-RateLimit-Reset': Math.ceil(resetTime / 1000)
    });
  }

  next();
};

// ============================================
// FUNCIÓN DE BYPASS PARA TESTING
// ============================================

/**
 * Middleware que permite bypass de rate limiting para testing
 */
const testBypass = (req, res, next) => {
  // Solo en modo test
  if (process.env.NODE_ENV === 'test') {
    // Verificar header especial
    if (req.headers['x-test-bypass-rate-limit'] === process.env.TEST_BYPASS_TOKEN) {
      logger.debug('Rate limit bypass activado para testing');
      return next();
    }
  }

  next();
};

// ============================================
// UTILIDADES DE RATE LIMITING
// ============================================

/**
 * Obtiene información actual de rate limiting para una key
 * @param {string} key - Key del rate limit
 * @param {Object} store - Store del rate limiter
 * @returns {Promise<Object>} Información de rate limit
 */
const getRateLimitInfo = async (key, store) => {
  try {
    const record = await store.get(key);
    
    if (!record) {
      return {
        key,
        requests: 0,
        remaining: 'unlimited',
        resetTime: null
      };
    }

    return {
      key,
      requests: record.count || 0,
      remaining: Math.max(0, record.limit - record.count),
      resetTime: record.resetTime,
      limit: record.limit
    };
  } catch (error) {
    logger.error('Error obteniendo información de rate limit:', error);
    return null;
  }
};

/**
 * Limpia manualmente una key del rate limiter
 * @param {string} key - Key a limpiar
 * @param {Object} store - Store del rate limiter
 * @returns {Promise<boolean>} True si se limpió correctamente
 */
const clearRateLimit = async (key, store) => {
  try {
    await store.delete(key);
    logger.info('Rate limit limpiado manualmente', { key });
    return true;
  } catch (error) {
    logger.error('Error limpiando rate limit:', error);
    return false;
  }
};

/**
 * Middleware que permite resetear rate limit para IPs específicas
 */
const createResetMiddleware = (allowedIPs = []) => {
  return (req, res, next) => {
    const clientIP = req.ip;
    
    // Solo permitir desde IPs específicas
    if (allowedIPs.includes(clientIP) || allowedIPs.includes('*')) {
      if (req.query.resetRateLimit === 'true') {
        // Aquí se podría implementar la lógica de reset
        logger.info('Rate limit reset solicitado', {
          ip: clientIP,
          path: req.path
        });
        
        res.json({
          success: true,
          message: 'Rate limit reset solicitado',
          ip: clientIP
        });
        return;
      }
    }

    next();
  };
};

// ============================================
// CONFIGURACIÓN GLOBAL
// ============================================

/**
 * Aplica rate limiting global basado en el entorno
 */
const applyGlobalRateLimit = (app) => {
  // En producción, aplicar rate limiting más estricto
  if (process.env.NODE_ENV === 'production') {
    app.use(rateLimitLogger);
    
    // Rate limiting global menos estricto
    app.use(createDynamicLimiter({
      windowMs: 15 * 60 * 1000, // 15 minutos
      max: 1000, // 1000 requests por IP cada 15 minutos
      message: {
        success: false,
        error: {
          type: 'rate_limit',
          message: 'Demasiadas solicitudes, intenta más tarde',
          retryAfter: 15 * 60
        }
      }
    }));
  } else {
    // En desarrollo, solo logging
    app.use(rateLimitLogger);
  }
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Rate limiters específicos
  apiLimiter,
  webhookLimiter,
  claudeLimiter,
  whatsappLimiter,
  authLimiter,
  adminLimiter,
  
  // Funciones
  createDynamicLimiter,
  rateLimitLogger,
  testBypass,
  applyGlobalRateLimit,
  
  // Utilidades
  getRateLimitInfo,
  clearRateLimit,
  createResetMiddleware,
  
  // Configuración base
  baseConfig
};


================================================
File: src/middleware/tenantResolver.js
================================================
const { query } = require('../config/database');
const logger = require('../utils/logger');
const { NotFoundError, ValidationError } = require('./errorHandler');
const { VALIDATION_PATTERNS } = require('../utils/constants');

// ============================================
// CACHE DE RESTAURANTES
// ============================================

// Cache en memoria para evitar consultas repetitivas
const restaurantCache = new Map();
const cacheTimeout = 5 * 60 * 1000; // 5 minutos

/**
 * Limpia el cache de restaurantes
 */
const clearRestaurantCache = () => {
  restaurantCache.clear();
  logger.debug('Cache de restaurantes limpiado');
};

/**
 * Obtiene un restaurante del cache o base de datos
 * @param {string} key - Clave del cache (slug o phone)
 * @param {string} value - Valor a buscar
 * @param {string} field - Campo por el cual buscar
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const getRestaurantFromCacheOrDB = async (key, value, field) => {
  // Verificar cache
  const cached = restaurantCache.get(key);
  if (cached && Date.now() - cached.timestamp < cacheTimeout) {
    logger.debug('Restaurante obtenido del cache', { key, field });
    return cached.data;
  }

  // Consultar base de datos
  try {
    const result = await query(
      `SELECT 
        r.id,
        r.name,
        r.slug,
        r.phone,
        r.email,
        r.is_active,
        r.opens_at,
        r.closes_at,
        r.delivery_time_min,
        r.delivery_time_max,
        r.delivery_fee,
        r.minimum_order,
        r.whatsapp_phone_id,
        r.twilio_phone_number,
        rs.claude_api_key,
        rs.claude_model,
        rs.ai_personality,
        rs.welcome_message,
        rs.goodbye_message,
        rs.error_message,
        rs.auto_confirm_orders,
        rs.max_conversation_time,
        rs.notification_email,
        rs.notification_phone
      FROM restaurants r
      LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
      WHERE r.${field} = $1 AND r.is_active = true`,
      [value],
      `get_restaurant_by_${field}`
    );

    const restaurant = result.rows[0] || null;

    // Guardar en cache
    if (restaurant) {
      restaurantCache.set(key, {
        data: restaurant,
        timestamp: Date.now()
      });
      logger.debug('Restaurante guardado en cache', { key, field });
    }

    return restaurant;
    
  } catch (error) {
    logger.error(`Error obteniendo restaurante por ${field}:`, error);
    throw error;
  }
};

// ============================================
// RESOLVERS DE TENANT
// ============================================

/**
 * Resuelve tenant por slug en la URL
 * Ejemplo: /webhook/hot-wings
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveBySlug = async (req) => {
  const slug = req.params.restaurantSlug || req.params.slug;
  
  if (!slug) {
    return null;
  }

  // Validar formato del slug
  if (!VALIDATION_PATTERNS.SLUG.test(slug)) {
    throw new ValidationError('Formato de slug inválido');
  }

  logger.debug('Resolviendo tenant por slug', { slug });
  
  const restaurant = await getRestaurantFromCacheOrDB(
    `slug:${slug}`, 
    slug, 
    'slug'
  );

  if (restaurant) {
    logger.debug('Tenant resuelto por slug', { 
      slug, 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

/**
 * Resuelve tenant por número de WhatsApp
 * Para webhooks que llegan con número específico
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveByWhatsAppNumber = async (req) => {
  // Obtener número del webhook (Twilio format: whatsapp:+525512345678)
  let phoneNumber = req.body?.To || req.body?.to;
  
  if (!phoneNumber) {
    return null;
  }

  // Limpiar formato de Twilio
  if (phoneNumber.startsWith('whatsapp:')) {
    phoneNumber = phoneNumber.replace('whatsapp:', '');
  }

  logger.debug('Resolviendo tenant por número WhatsApp', { phoneNumber });

  // Buscar por twilio_phone_number
  let restaurant = await getRestaurantFromCacheOrDB(
    `twilio:${phoneNumber}`,
    phoneNumber,
    'twilio_phone_number'
  );

  // Si no se encuentra, buscar por phone principal
  if (!restaurant) {
    restaurant = await getRestaurantFromCacheOrDB(
      `phone:${phoneNumber}`,
      phoneNumber,
      'phone'
    );
  }

  if (restaurant) {
    logger.debug('Tenant resuelto por WhatsApp', { 
      phoneNumber, 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

/**
 * Resuelve tenant por Meta WhatsApp Phone Number ID
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveByMetaPhoneId = async (req) => {
  const phoneNumberId = req.body?.entry?.[0]?.changes?.[0]?.value?.metadata?.phone_number_id;
  
  if (!phoneNumberId) {
    return null;
  }

  logger.debug('Resolviendo tenant por Meta Phone ID', { phoneNumberId });

  const restaurant = await getRestaurantFromCacheOrDB(
    `meta:${phoneNumberId}`,
    phoneNumberId,
    'whatsapp_phone_id'
  );

  if (restaurant) {
    logger.debug('Tenant resuelto por Meta WhatsApp', { 
      phoneNumberId, 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

/**
 * Resuelve tenant por header personalizado
 * Para casos especiales o APIs internas
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveByHeader = async (req) => {
  const restaurantId = req.headers['x-restaurant-id'];
  const restaurantSlug = req.headers['x-restaurant-slug'];

  if (!restaurantId && !restaurantSlug) {
    return null;
  }

  logger.debug('Resolviendo tenant por header', { restaurantId, restaurantSlug });

  let restaurant = null;

  if (restaurantId) {
    restaurant = await getRestaurantFromCacheOrDB(
      `id:${restaurantId}`,
      restaurantId,
      'id'
    );
  } else if (restaurantSlug) {
    restaurant = await getRestaurantFromCacheOrDB(
      `slug:${restaurantSlug}`,
      restaurantSlug,
      'slug'
    );
  }

  if (restaurant) {
    logger.debug('Tenant resuelto por header', { 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

// ============================================
// MIDDLEWARE PRINCIPAL
// ============================================

/**
 * Middleware principal para resolver tenant
 * Intenta diferentes métodos en orden de prioridad
 * @param {Object} options - Opciones de configuración
 * @returns {Function} Middleware function
 */
const tenantResolver = (options = {}) => {
  const {
    required = false,
    methods = ['slug', 'whatsapp', 'meta', 'header'],
    onNotFound = null,
    skipPaths = ['/health', '/']
  } = options;

  return async (req, res, next) => {
    try {
      // Saltar paths específicos
      if (skipPaths.includes(req.path)) {
        return next();
      }

      logger.debug('Iniciando resolución de tenant', {
        path: req.path,
        method: req.method,
        methods: methods
      });

      let restaurant = null;

      // Intentar diferentes métodos de resolución
      for (const method of methods) {
        switch (method) {
          case 'slug':
            restaurant = await resolveBySlug(req);
            break;
          case 'whatsapp':
            restaurant = await resolveByWhatsAppNumber(req);
            break;
          case 'meta':
            restaurant = await resolveByMetaPhoneId(req);
            break;
          case 'header':
            restaurant = await resolveByHeader(req);
            break;
          default:
            logger.warn('Método de resolución desconocido:', method);
        }

        if (restaurant) {
          break;
        }
      }

      // Verificar si el restaurante está activo
      if (restaurant && !restaurant.is_active) {
        logger.warn('Intento de acceso a restaurante inactivo', {
          restaurantId: restaurant.id,
          restaurantName: restaurant.name
        });
        restaurant = null;
      }

      // Manejar caso de restaurante no encontrado
      if (!restaurant) {
        logger.warn('Tenant no resuelto', {
          path: req.path,
          method: req.method,
          body: req.body,
          params: req.params,
          headers: {
            'x-restaurant-id': req.headers['x-restaurant-id'],
            'x-restaurant-slug': req.headers['x-restaurant-slug']
          }
        });

        if (required) {
          if (onNotFound && typeof onNotFound === 'function') {
            return onNotFound(req, res, next);
          }
          
          throw new NotFoundError('Restaurante no encontrado o inactivo');
        }
      }

      // Agregar datos del restaurante al request
      if (restaurant) {
        req.restaurant = restaurant;
        req.restaurantId = restaurant.id;
        req.tenant = restaurant; // Alias para compatibilidad
        
        logger.info('Tenant resuelto exitosamente', {
          restaurantId: restaurant.id,
          restaurantName: restaurant.name,
          slug: restaurant.slug,
          path: req.path
        });

        // Agregar header de respuesta
        res.set('X-Restaurant-ID', restaurant.id);
        res.set('X-Restaurant-Name', restaurant.name);
      }

      next();

    } catch (error) {
      logger.error('Error en resolución de tenant:', error);
      next(error);
    }
  };
};

// ============================================
// MIDDLEWARES ESPECÍFICOS
// ============================================

/**
 * Middleware para webhooks que requiere tenant
 */
const webhookTenantResolver = tenantResolver({
  required: true,
  methods: ['slug', 'whatsapp', 'meta'],
  onNotFound: (req, res, next) => {
    // Para webhooks, devolver 200 para evitar reintentos
    res.status(200).json({
      success: false,
      message: 'Webhook recibido pero restaurante no encontrado'
    });
  }
});

/**
 * Middleware para API que requiere tenant
 */
const apiTenantResolver = tenantResolver({
  required: true,
  methods: ['header', 'slug'],
  skipPaths: ['/health', '/', '/api/docs']
});

/**
 * Middleware para dashboard que puede ser opcional
 */
const dashboardTenantResolver = tenantResolver({
  required: false,
  methods: ['header', 'slug'],
  skipPaths: ['/health', '/', '/api/docs', '/api/restaurants']
});

// ============================================
// UTILIDADES
// ============================================

/**
 * Obtiene datos completos del restaurante incluyendo menú y reglas
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Object>} Datos completos del restaurante
 */
const getFullRestaurantData = async (restaurantId) => {
  try {
    const cacheKey = `full:${restaurantId}`;
    const cached = restaurantCache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < cacheTimeout) {
      return cached.data;
    }

    // Obtener datos base del restaurante
    const restaurantResult = await query(
      `SELECT * FROM restaurants WHERE id = $1 AND is_active = true`,
      [restaurantId],
      'get_full_restaurant_base'
    );

    if (restaurantResult.rows.length === 0) {
      return null;
    }

    const restaurant = restaurantResult.rows[0];

    // Obtener menú activo
    const menuResult = await query(
      `SELECT 
        mi.id, mi.name, mi.description, mi.price, mi.is_available,
        mi.preparation_time, mi.display_order, mi.image_url,
        mc.name as category_name, mc.emoji as category_emoji
      FROM menu_items mi
      JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE mi.restaurant_id = $1 AND mi.is_available = true
      ORDER BY mc.display_order, mi.display_order`,
      [restaurantId],
      'get_restaurant_menu'
    );

    // Obtener reglas de negocio
    const rulesResult = await query(
      `SELECT 
        id, menu_item_id, rule_type, rule_name, rule_config, ai_message_template
      FROM business_rules 
      WHERE restaurant_id = $1 AND is_active = true`,
      [restaurantId],
      'get_restaurant_rules'
    );

    const fullData = {
      ...restaurant,
      menu: menuResult.rows,
      business_rules: rulesResult.rows
    };

    // Guardar en cache
    restaurantCache.set(cacheKey, {
      data: fullData,
      timestamp: Date.now()
    });

    return fullData;

  } catch (error) {
    logger.error('Error obteniendo datos completos del restaurante:', error);
    throw error;
  }
};

/**
 * Valida si un restaurante está abierto en el horario actual
 * @param {Object} restaurant - Datos del restaurante
 * @returns {boolean} True si está abierto
 */
const isRestaurantOpen = (restaurant) => {
  if (!restaurant.opens_at || !restaurant.closes_at) {
    return true; // Si no hay horarios definidos, asumir abierto
  }

  const now = new Date();
  const currentTime = now.toTimeString().slice(0, 8); // HH:mm:ss

  const opensAt = restaurant.opens_at;
  const closesAt = restaurant.closes_at;

  // Manejar caso donde cierra después de medianoche
  if (closesAt < opensAt) {
    return currentTime >= opensAt || currentTime <= closesAt;
  }

  return currentTime >= opensAt && currentTime <= closesAt;
};

/**
 * Middleware que verifica horarios de operación
 */
const checkOperatingHours = (req, res, next) => {
  if (!req.restaurant) {
    return next();
  }

  if (!isRestaurantOpen(req.restaurant)) {
    logger.info('Intento de acceso fuera de horario', {
      restaurantId: req.restaurant.id,
      currentTime: new Date().toTimeString().slice(0, 8),
      opensAt: req.restaurant.opens_at,
      closesAt: req.restaurant.closes_at
    });

    // Para webhooks, responder con mensaje apropiado
    if (req.path.startsWith('/webhook')) {
      return res.status(200).json({
        success: true,
        message: 'Restaurante cerrado'
      });
    }

    return res.status(400).json({
      success: false,
      error: {
        type: 'restaurant_closed',
        message: `Restaurante cerrado. Horarios: ${req.restaurant.opens_at} - ${req.restaurant.closes_at}`
      }
    });
  }

  next();
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Middleware principal
  tenantResolver,
  
  // Middlewares específicos
  webhookTenantResolver,
  apiTenantResolver,
  dashboardTenantResolver,
  
  // Utilidades
  getFullRestaurantData,
  isRestaurantOpen,
  checkOperatingHours,
  clearRestaurantCache,
  
  // Resolvers individuales (para testing)
  resolveBySlug,
  resolveByWhatsAppNumber,
  resolveByMetaPhoneId,
  resolveByHeader
};


================================================
File: src/models/Conversation.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { CONVERSATION_STATUS, CONVERSATION_STEPS, TIME_LIMITS } = require('../utils/constants');

// ============================================
// MODELO CONVERSATION
// ============================================

class Conversation {

  /**
   * Crea o obtiene una conversación activa
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Teléfono del cliente
   * @returns {Promise<Object>} Conversación activa
   */
  static async getOrCreate(restaurantId, customerPhone) {
    if (!restaurantId || !customerPhone) {
      throw new ValidationError('ID del restaurante y teléfono del cliente son requeridos');
    }

    try {
      // Primero intentar obtener conversación activa
      let conversation = await this.getActive(restaurantId, customerPhone);

      if (conversation) {
        // Verificar si no ha expirado
        const timeLimit = conversation.max_conversation_time || TIME_LIMITS.MAX_CONVERSATION_TIME;
        const timeSinceLastInteraction = Date.now() - new Date(conversation.last_interaction_at).getTime();

        if (timeSinceLastInteraction > timeLimit * 1000) {
          // Marcar como abandonada y crear nueva
          await this.abandon(conversation.id);
          conversation = null;
        } else {
          // Actualizar timestamp de última interacción
          await this.updateLastInteraction(conversation.id);
          return conversation;
        }
      }

      // Crear nueva conversación
      if (!conversation) {
        const result = await query(
          `INSERT INTO conversations (
            id, restaurant_id, customer_phone, status, current_step,
            order_data, ai_context, last_interaction_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP)
          RETURNING *`,
          [
            uuidv4(),
            restaurantId,
            customerPhone,
            CONVERSATION_STATUS.ACTIVE,
            CONVERSATION_STEPS.GREETING,
            JSON.stringify({
              items: [],
              subtotal: 0,
              delivery_fee: 0,
              total: 0
            }),
            JSON.stringify([])
          ],
          'create_conversation'
        );

        conversation = result.rows[0];

        logger.info('Nueva conversación creada', {
          conversationId: conversation.id,
          restaurantId,
          customerPhone: customerPhone.substring(0, 8) + '****'
        });
      }

      return conversation;

    } catch (error) {
      logger.error('Error creando/obteniendo conversación:', error);
      throw new DatabaseError('Error al gestionar conversación', error);
    }
  }

  /**
   * Obtiene conversación activa
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Teléfono del cliente
   * @returns {Promise<Object|null>} Conversación activa
   */
  static async getActive(restaurantId, customerPhone) {
    try {
      const result = await query(
        `SELECT * FROM conversations 
         WHERE restaurant_id = $1 AND customer_phone = $2 AND status = $3
         ORDER BY last_interaction_at DESC
         LIMIT 1`,
        [restaurantId, customerPhone, CONVERSATION_STATUS.ACTIVE],
        'get_active_conversation'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error obteniendo conversación activa:', error);
      throw new DatabaseError('Error al obtener conversación', error);
    }
  }

  /**
   * Obtiene conversación por ID
   * @param {string} conversationId - ID de la conversación
   * @returns {Promise<Object|null>} Conversación
   */
  static async findById(conversationId) {
    try {
      const result = await query(
        'SELECT * FROM conversations WHERE id = $1',
        [conversationId],
        'find_conversation_by_id'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error obteniendo conversación por ID:', error);
      throw new DatabaseError('Error al obtener conversación', error);
    }
  }

  /**
   * Actualiza el estado de la conversación
   * @param {string} conversationId - ID de la conversación
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async update(conversationId, updateData) {
    const allowedFields = [
      'status', 'current_step', 'order_data', 'ai_context', 'conversation_summary'
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        let value = updateData[key];
        
        // Serializar objetos/arrays a JSON
        if (key === 'order_data' || key === 'ai_context') {
          value = JSON.stringify(value);
        }
        
        fields.push(`${key} = $${paramCount}`);
        values.push(value);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos válidos para actualizar');
    }

    // Siempre actualizar timestamp de última interacción
    fields.push(`last_interaction_at = CURRENT_TIMESTAMP`);
    values.push(conversationId);

    try {
      const result = await query(
        `UPDATE conversations 
         SET ${fields.join(', ')}
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_conversation'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Conversación');
      }

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando conversación:', error);
      throw new DatabaseError('Error al actualizar conversación', error);
    }
  }

  /**
   * Actualiza solo el timestamp de última interacción
   * @param {string} conversationId - ID de la conversación
   * @returns {Promise<boolean>} True si se actualizó
   */
  static async updateLastInteraction(conversationId) {
    try {
      const result = await query(
        'UPDATE conversations SET last_interaction_at = CURRENT_TIMESTAMP WHERE id = $1',
        [conversationId],
        'update_last_interaction'
      );

      return result.rowCount > 0;

    } catch (error) {
      logger.error('Error actualizando última interacción:', error);
      throw new DatabaseError('Error al actualizar interacción', error);
    }
  }

  /**
   * Agrega un mensaje al contexto de IA
   * @param {string} conversationId - ID de la conversación
   * @param {string} role - 'user' o 'assistant'
   * @param {string} content - Contenido del mensaje
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async addToContext(conversationId, role, content) {
    if (!['user', 'assistant'].includes(role)) {
      throw new ValidationError('Role debe ser "user" o "assistant"');
    }

    try {
      // Obtener conversación actual
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversación');
      }

      // Obtener contexto actual
      let aiContext = [];
      try {
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando contexto de IA, reiniciando:', e);
        aiContext = [];
      }

      // Agregar nuevo mensaje
      const newMessage = {
        role,
        content,
        timestamp: new Date().toISOString()
      };

      aiContext.push(newMessage);

      // Mantener solo los últimos 12 mensajes (6 intercambios)
      if (aiContext.length > 12) {
        aiContext = aiContext.slice(-12);
      }

      // Actualizar conversación
      return await this.update(conversationId, {
        ai_context: aiContext
      });

    } catch (error) {
      logger.error('Error agregando mensaje al contexto:', error);
      throw new DatabaseError('Error al actualizar contexto', error);
    }
  }

  /**
   * Actualiza los datos del pedido en la conversación
   * @param {string} conversationId - ID de la conversación
   * @param {Object} orderData - Datos del pedido
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async updateOrderData(conversationId, orderData) {
    try {
      // Obtener conversación actual
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversación');
      }

      // Obtener datos actuales del pedido
      let currentOrderData = {};
      try {
        currentOrderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        logger.warn('Error parseando datos del pedido, reiniciando:', e);
        currentOrderData = { items: [], subtotal: 0, delivery_fee: 0, total: 0 };
      }

      // Fusionar con nuevos datos
      const updatedOrderData = {
        ...currentOrderData,
        ...orderData
      };

      // Recalcular totales si hay items
      if (updatedOrderData.items && updatedOrderData.items.length > 0) {
        updatedOrderData.subtotal = updatedOrderData.items.reduce(
          (sum, item) => sum + (item.item_total || 0), 0
        );
        updatedOrderData.total = updatedOrderData.subtotal + (updatedOrderData.delivery_fee || 0);
      }

      return await this.update(conversationId, {
        order_data: updatedOrderData
      });

    } catch (error) {
      logger.error('Error actualizando datos del pedido:', error);
      throw new DatabaseError('Error al actualizar pedido', error);
    }
  }

  /**
   * Agrega un item al pedido
   * @param {string} conversationId - ID de la conversación
   * @param {Object} item - Item a agregar
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async addItemToOrder(conversationId, item) {
    try {
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversación');
      }

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        orderData = { items: [], subtotal: 0, delivery_fee: 0, total: 0 };
      }

      if (!orderData.items) {
        orderData.items = [];
      }

      // Validar item
      if (!item.menu_item_id || !item.name || !item.base_price || !item.quantity) {
        throw new ValidationError('Item incompleto: faltan campos requeridos');
      }

      // Calcular total del item
      const customizationsCost = (item.customizations || [])
        .reduce((sum, custom) => sum + (custom.extra_cost || 0), 0);
      
      item.item_total = (item.base_price + customizationsCost) * item.quantity;
      item.added_at = new Date().toISOString();

      // Agregar item
      orderData.items.push(item);

      return await this.updateOrderData(conversationId, orderData);

    } catch (error) {
      logger.error('Error agregando item al pedido:', error);
      throw new DatabaseError('Error al agregar item', error);
    }
  }

  /**
   * Remueve un item del pedido
   * @param {string} conversationId - ID de la conversación
   * @param {number} itemIndex - Índice del item a remover
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async removeItemFromOrder(conversationId, itemIndex) {
    try {
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversación');
      }

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        throw new ValidationError('Error al procesar datos del pedido');
      }

      if (!orderData.items || itemIndex < 0 || itemIndex >= orderData.items.length) {
        throw new ValidationError('Índice de item inválido');
      }

      // Remover item
      const removedItem = orderData.items.splice(itemIndex, 1)[0];

      logger.info('Item removido del pedido', {
        conversationId,
        removedItem: removedItem.name,
        remainingItems: orderData.items.length
      });

      return await this.updateOrderData(conversationId, orderData);

    } catch (error) {
      logger.error('Error removiendo item del pedido:', error);
      throw new DatabaseError('Error al remover item', error);
    }
  }

  /**
   * Marca conversación como completada
   * @param {string} conversationId - ID de la conversación
   * @param {string} orderId - ID del pedido creado (opcional)
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async complete(conversationId, orderId = null) {
    try {
      const updateData = {
        status: CONVERSATION_STATUS.COMPLETED,
        current_step: CONVERSATION_STEPS.COMPLETED
      };

      if (orderId) {
        // Agregar referencia al pedido en los datos
        const conversation = await this.findById(conversationId);
        if (conversation) {
          let orderData = JSON.parse(conversation.order_data || '{}');
          orderData.order_id = orderId;
          updateData.order_data = orderData;
        }
      }

      const result = await this.update(conversationId, updateData);

      logger.info('Conversación completada', {
        conversationId,
        orderId
      });

      return result;

    } catch (error) {
      logger.error('Error completando conversación:', error);
      throw new DatabaseError('Error al completar conversación', error);
    }
  }

  /**
   * Marca conversación como abandonada
   * @param {string} conversationId - ID de la conversación
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async abandon(conversationId) {
    try {
      const result = await this.update(conversationId, {
        status: CONVERSATION_STATUS.ABANDONED
      });

      logger.info('Conversación marcada como abandonada', { conversationId });
      return result;

    } catch (error) {
      logger.error('Error marcando conversación como abandonada:', error);
      throw new DatabaseError('Error al abandonar conversación', error);
    }
  }

  /**
   * Limpia conversaciones inactivas
   * @param {number} maxInactiveHours - Horas máximas de inactividad
   * @returns {Promise<number>} Número de conversaciones limpiadas
   */
  static async cleanupInactive(maxInactiveHours = 2) {
    try {
      const result = await query(
        `UPDATE conversations 
         SET status = $1 
         WHERE status = $2 
         AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '${maxInactiveHours} hours'`,
        [CONVERSATION_STATUS.ABANDONED, CONVERSATION_STATUS.ACTIVE],
        'cleanup_inactive_conversations'
      );

      const cleanedCount = result.rowCount;

      if (cleanedCount > 0) {
        logger.info('Conversaciones inactivas limpiadas', {
          count: cleanedCount,
          maxInactiveHours
        });
      }

      return cleanedCount;

    } catch (error) {
      logger.error('Error limpiando conversaciones inactivas:', error);
      throw new DatabaseError('Error en limpieza de conversaciones', error);
    }
  }

  /**
   * Obtiene estadísticas de conversaciones
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas
   */
  static async getStats(restaurantId, dateRange = {}) {
    const { startDate, endDate } = dateRange;
    
    try {
      let dateCondition = '';
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = 'AND created_at BETWEEN $2 AND $3';
        values.push(startDate, endDate);
      }

      const result = await query(
        `SELECT 
          COUNT(*) as total_conversations,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_conversations,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_conversations,
          COUNT(CASE WHEN status = 'abandoned' THEN 1 END) as abandoned_conversations,
          COUNT(DISTINCT customer_phone) as unique_customers,
          AVG(EXTRACT(EPOCH FROM (last_interaction_at - created_at))/60) as avg_duration_minutes
        FROM conversations 
        WHERE restaurant_id = $1 ${dateCondition}`,
        values,
        'get_conversation_stats'
      );

      const stats = result.rows[0];

      // Calcular tasas
      const total = parseInt(stats.total_conversations);
      stats.completion_rate = total > 0 
        ? ((parseInt(stats.completed_conversations) / total) * 100).toFixed(2)
        : 0;

      stats.abandonment_rate = total > 0
        ? ((parseInt(stats.abandoned_conversations) / total) * 100).toFixed(2)
        : 0;

      stats.avg_duration_minutes = parseFloat(stats.avg_duration_minutes || 0).toFixed(2);

      return stats;

    } catch (error) {
      logger.error('Error obteniendo estadísticas de conversaciones:', error);
      throw new DatabaseError('Error al obtener estadísticas', error);
    }
  }

  /**
   * Obtiene conversaciones recientes de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Lista paginada de conversaciones
   */
  static async getRecent(restaurantId, options = {}) {
    const {
      page = 1,
      limit = 20,
      status = null,
      customerPhone = null
    } = options;

    const offset = (page - 1) * limit;

    try {
      const conditions = ['restaurant_id = $1'];
      const values = [restaurantId];
      let paramCount = 2;

      if (status) {
        conditions.push(`status = $${paramCount}`);
        values.push(status);
        paramCount++;
      }

      if (customerPhone) {
        conditions.push(`customer_phone = $${paramCount}`);
        values.push(customerPhone);
        paramCount++;
      }

      const whereClause = conditions.join(' AND ');

      // Consulta principal
      const conversationsResult = await query(
        `SELECT 
          id, customer_phone, status, current_step,
          last_interaction_at, created_at,
          CASE 
            WHEN order_data::text != '{}' THEN 
              (order_data->>'total')::numeric 
            ELSE 0 
          END as order_total
        FROM conversations 
        WHERE ${whereClause}
        ORDER BY last_interaction_at DESC
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'get_recent_conversations'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM conversations WHERE ${whereClause}`,
        values.slice(0, -2),
        'count_conversations'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        conversations: conversationsResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error obteniendo conversaciones recientes:', error);
      throw new DatabaseError('Error al obtener conversaciones', error);
    }
  }
}

module.exports = Conversation;


================================================
File: src/models/Customer.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { formatPhoneNumber, isValidWhatsAppNumber } = require('../config/whatsapp');

// ============================================
// MODELO CUSTOMER
// ============================================

class Customer {

  /**
   * Crea o obtiene un cliente por teléfono
   * @param {string} phone - Número de teléfono
   * @param {Object} additionalData - Datos adicionales del cliente
   * @returns {Promise<Object>} Cliente creado o existente
   */
  static async findOrCreate(phone, additionalData = {}) {
    if (!phone) {
      throw new ValidationError('Número de teléfono es requerido');
    }

    const formattedPhone = formatPhoneNumber(phone);
    
    if (!isValidWhatsAppNumber(formattedPhone)) {
      throw new ValidationError('Número de teléfono inválido');
    }

    try {
      // Primero intentar encontrar cliente existente
      let customer = await this.findByPhone(formattedPhone);

      if (customer) {
        // Si hay datos adicionales, actualizar
        if (Object.keys(additionalData).length > 0) {
          customer = await this.update(customer.id, additionalData);
        }
        return customer;
      }

      // Crear nuevo cliente
      const {
        name = null,
        default_address = null,
        default_references = null
      } = additionalData;

      const result = await query(
        `INSERT INTO customers (
          id, phone, name, default_address, default_references, first_order_at
        ) VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)
        RETURNING *`,
        [uuidv4(), formattedPhone, name, default_address, default_references],
        'create_customer'
      );

      customer = result.rows[0];

      logger.info('Nuevo cliente creado', {
        customerId: customer.id,
        phone: formattedPhone.substring(0, 8) + '****'
      });

      return customer;

    } catch (error) {
      if (error.code === '23505') { // unique violation
        // Race condition - otro proceso creó el cliente
        return await this.findByPhone(formattedPhone);
      }

      logger.error('Error creando/obteniendo cliente:', error);
      throw new DatabaseError('Error al gestionar cliente', error);
    }
  }

  /**
   * Busca un cliente por teléfono
   * @param {string} phone - Número de teléfono
   * @returns {Promise<Object|null>} Cliente encontrado
   */
  static async findByPhone(phone) {
    try {
      const formattedPhone = formatPhoneNumber(phone);
      
      const result = await query(
        'SELECT * FROM customers WHERE phone = $1',
        [formattedPhone],
        'find_customer_by_phone'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error buscando cliente por teléfono:', error);
      throw new DatabaseError('Error al buscar cliente', error);
    }
  }

  /**
   * Busca un cliente por ID
   * @param {string} customerId - ID del cliente
   * @returns {Promise<Object|null>} Cliente encontrado
   */
  static async findById(customerId) {
    try {
      const result = await query(
        'SELECT * FROM customers WHERE id = $1',
        [customerId],
        'find_customer_by_id'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error buscando cliente por ID:', error);
      throw new DatabaseError('Error al buscar cliente', error);
    }
  }

  /**
   * Actualiza datos de un cliente
   * @param {string} customerId - ID del cliente
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Cliente actualizado
   */
  static async update(customerId, updateData) {
    const allowedFields = ['name', 'default_address', 'default_references'];
    
    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos válidos para actualizar');
    }

    values.push(customerId);

    try {
      const result = await query(
        `UPDATE customers 
         SET ${fields.join(', ')}
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_customer'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Cliente');
      }

      logger.info('Cliente actualizado', {
        customerId,
        updatedFields: Object.keys(updateData)
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando cliente:', error);
      throw new DatabaseError('Error al actualizar cliente', error);
    }
  }

  /**
   * Obtiene el historial de pedidos de un cliente
   * @param {string} customerId - ID del cliente
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Historial paginado
   */
  static async getOrderHistory(customerId, options = {}) {
    const {
      page = 1,
      limit = 10,
      restaurantId = null,
      startDate = null,
      endDate = null
    } = options;

    const offset = (page - 1) * limit;

    try {
      const conditions = ['o.customer_id = $1'];
      const values = [customerId];
      let paramCount = 2;

      if (restaurantId) {
        conditions.push(`o.restaurant_id = $${paramCount}`);
        values.push(restaurantId);
        paramCount++;
      }

      if (startDate) {
        conditions.push(`o.created_at >= $${paramCount}`);
        values.push(startDate);
        paramCount++;
      }

      if (endDate) {
        conditions.push(`o.created_at <= $${paramCount}`);
        values.push(endDate);
        paramCount++;
      }

      const whereClause = conditions.join(' AND ');

      // Consulta principal
      const ordersResult = await query(
        `SELECT 
          o.id, o.status, o.total, o.created_at, o.delivered_at,
          r.name as restaurant_name,
          COUNT(oi.id) as items_count
        FROM orders o
        JOIN restaurants r ON o.restaurant_id = r.id
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE ${whereClause}
        GROUP BY o.id, r.name
        ORDER BY o.created_at DESC
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'get_customer_order_history'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM orders o WHERE ${whereClause}`,
        values.slice(0, -2),
        'count_customer_orders'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        orders: ordersResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error obteniendo historial de pedidos:', error);
      throw new DatabaseError('Error al obtener historial', error);
    }
  }

  /**
   * Obtiene estadísticas de un cliente
   * @param {string} customerId - ID del cliente
   * @returns {Promise<Object>} Estadísticas del cliente
   */
  static async getStats(customerId) {
    try {
      const result = await query(
        `SELECT 
          c.total_orders,
          c.total_spent,
          c.first_order_at,
          c.last_order_at,
          COUNT(DISTINCT o.restaurant_id) as restaurants_visited,
          COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as completed_orders,
          COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders,
          COALESCE(AVG(CASE WHEN o.status = 'delivered' THEN o.total END), 0) as avg_order_value,
          
          -- Items favoritos
          (SELECT oi.item_name 
           FROM order_items oi 
           JOIN orders o2 ON oi.order_id = o2.id
           WHERE o2.customer_id = c.id AND o2.status = 'delivered'
           GROUP BY oi.item_name 
           ORDER BY COUNT(*) DESC 
           LIMIT 1) as favorite_item,
           
          -- Restaurante favorito
          (SELECT r.name 
           FROM orders o3 
           JOIN restaurants r ON o3.restaurant_id = r.id
           WHERE o3.customer_id = c.id AND o3.status = 'delivered'
           GROUP BY r.id, r.name 
           ORDER BY COUNT(*) DESC 
           LIMIT 1) as favorite_restaurant

        FROM customers c
        LEFT JOIN orders o ON c.id = o.customer_id
        WHERE c.id = $1
        GROUP BY c.id`,
        [customerId],
        'get_customer_stats'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Cliente');
      }

      const stats = result.rows[0];

      // Calcular métricas adicionales
      stats.completion_rate = stats.total_orders > 0 
        ? ((stats.completed_orders / stats.total_orders) * 100).toFixed(2)
        : 0;

      stats.cancellation_rate = stats.total_orders > 0
        ? ((stats.cancelled_orders / stats.total_orders) * 100).toFixed(2)
        : 0;

      // Calcular días como cliente
      if (stats.first_order_at) {
        const daysSinceFirstOrder = Math.floor(
          (Date.now() - new Date(stats.first_order_at).getTime()) / (1000 * 60 * 60 * 24)
        );
        stats.days_as_customer = daysSinceFirstOrder;
        stats.orders_per_month = daysSinceFirstOrder > 0 
          ? ((stats.total_orders / daysSinceFirstOrder) * 30).toFixed(2)
          : 0;
      }

      return stats;

    } catch (error) {
      logger.error('Error obteniendo estadísticas de cliente:', error);
      throw new DatabaseError('Error al obtener estadísticas', error);
    }
  }

  /**
   * Obtiene los items favoritos de un cliente
   * @param {string} customerId - ID del cliente
   * @param {number} limit - Límite de resultados
   * @returns {Promise<Array>} Items favoritos
   */
  static async getFavoriteItems(customerId, limit = 5) {
    try {
      const result = await query(
        `SELECT 
          oi.item_name,
          oi.menu_item_id,
          COUNT(*) as order_count,
          SUM(oi.quantity) as total_quantity,
          AVG(oi.base_price) as avg_price,
          MAX(o.created_at) as last_ordered,
          mi.image_url
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE o.customer_id = $1 AND o.status = 'delivered'
        GROUP BY oi.menu_item_id, oi.item_name, mi.image_url
        ORDER BY order_count DESC, total_quantity DESC
        LIMIT $2`,
        [customerId, limit],
        'get_customer_favorite_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo items favoritos del cliente:', error);
      throw new DatabaseError('Error al obtener items favoritos', error);
    }
  }

  /**
   * Obtiene clientes frecuentes de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Array>} Clientes frecuentes
   */
  static async getFrequentCustomers(restaurantId, options = {}) {
    const {
      limit = 20,
      minOrders = 3,
      period = null // 'month', 'week', etc.
    } = options;

    try {
      let dateCondition = '';
      const values = [restaurantId, minOrders, limit];

      if (period === 'month') {
        dateCondition = "AND o.created_at >= CURRENT_DATE - INTERVAL '30 days'";
      } else if (period === 'week') {
        dateCondition = "AND o.created_at >= CURRENT_DATE - INTERVAL '7 days'";
      }

      const result = await query(
        `SELECT 
          c.id,
          c.phone,
          c.name,
          c.default_address,
          COUNT(o.id) as total_orders,
          SUM(CASE WHEN o.status = 'delivered' THEN o.total ELSE 0 END) as total_spent,
          MAX(o.created_at) as last_order_date,
          AVG(CASE WHEN o.status = 'delivered' THEN o.total END) as avg_order_value
        FROM customers c
        JOIN orders o ON c.id = o.customer_id
        WHERE o.restaurant_id = $1 ${dateCondition}
        GROUP BY c.id
        HAVING COUNT(o.id) >= $2
        ORDER BY total_orders DESC, total_spent DESC
        LIMIT $3`,
        values,
        'get_frequent_customers'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo clientes frecuentes:', error);
      throw new DatabaseError('Error al obtener clientes frecuentes', error);
    }
  }

  /**
   * Busca clientes por criterios
   * @param {Object} searchCriteria - Criterios de búsqueda
   * @param {Object} options - Opciones de paginación
   * @returns {Promise<Object>} Resultados paginados
   */
  static async search(searchCriteria = {}, options = {}) {
    const {
      phone = null,
      name = null,
      minOrders = null,
      maxOrders = null,
      minSpent = null,
      maxSpent = null
    } = searchCriteria;

    const {
      page = 1,
      limit = 20,
      sortBy = 'total_orders',
      sortOrder = 'DESC'
    } = options;

    const offset = (page - 1) * limit;

    try {
      const conditions = [];
      const values = [];
      let paramCount = 1;

      if (phone) {
        conditions.push(`c.phone ILIKE $${paramCount}`);
        values.push(`%${phone}%`);
        paramCount++;
      }

      if (name) {
        conditions.push(`c.name ILIKE $${paramCount}`);
        values.push(`%${name}%`);
        paramCount++;
      }

      if (minOrders !== null) {
        conditions.push(`c.total_orders >= $${paramCount}`);
        values.push(minOrders);
        paramCount++;
      }

      if (maxOrders !== null) {
        conditions.push(`c.total_orders <= $${paramCount}`);
        values.push(maxOrders);
        paramCount++;
      }

      if (minSpent !== null) {
        conditions.push(`c.total_spent >= $${paramCount}`);
        values.push(minSpent);
        paramCount++;
      }

      if (maxSpent !== null) {
        conditions.push(`c.total_spent <= $${paramCount}`);
        values.push(maxSpent);
        paramCount++;
      }

      const whereClause = conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : '';

      // Consulta principal
      const customersResult = await query(
        `SELECT 
          c.*,
          EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - c.last_order_at))/86400 as days_since_last_order
        FROM customers c
        ${whereClause}
        ORDER BY c.${sortBy} ${sortOrder.toUpperCase()}
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'search_customers'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM customers c ${whereClause}`,
        values.slice(0, -2),
        'count_search_customers'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        customers: customersResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error buscando clientes:', error);
      throw new DatabaseError('Error al buscar clientes', error);
    }
  }

  /**
   * Actualiza estadísticas después de un pedido
   * Esta función es llamada automáticamente cuando se crea un pedido
   * @param {string} customerId - ID del cliente
   * @param {number} orderTotal - Total del pedido
   * @returns {Promise<boolean>} True si se actualizó correctamente
   */
  static async updateOrderStats(customerId, orderTotal) {
    try {
      await query(
        `UPDATE customers 
         SET total_orders = total_orders + 1,
             total_spent = total_spent + $1,
             last_order_at = CURRENT_TIMESTAMP
         WHERE id = $2`,
        [orderTotal, customerId],
        'update_customer_order_stats'
      );

      return true;

    } catch (error) {
      logger.error('Error actualizando estadísticas de cliente:', error);
      // No lanzar error para no afectar el flujo del pedido
      return false;
    }
  }

  /**
   * Obtiene recomendaciones para un cliente basadas en su historial
   * @param {string} customerId - ID del cliente
   * @param {string} restaurantId - ID del restaurante
   * @param {number} limit - Límite de recomendaciones
   * @returns {Promise<Array>} Items recomendados
   */
  static async getRecommendations(customerId, restaurantId, limit = 5) {
    try {
      // Obtener items que el cliente no ha pedido pero que han pedido clientes similares
      const result = await query(
        `WITH customer_items AS (
          SELECT DISTINCT oi.menu_item_id
          FROM order_items oi
          JOIN orders o ON oi.order_id = o.id
          WHERE o.customer_id = $1 AND o.restaurant_id = $2
        ),
        similar_customers AS (
          SELECT DISTINCT o2.customer_id
          FROM orders o1
          JOIN orders o2 ON o1.restaurant_id = o2.restaurant_id
          JOIN order_items oi1 ON o1.id = oi1.order_id
          JOIN order_items oi2 ON o2.id = oi2.order_id
          WHERE o1.customer_id = $1 
          AND o1.restaurant_id = $2
          AND o2.customer_id != $1
          AND oi1.menu_item_id = oi2.menu_item_id
        ),
        recommended_items AS (
          SELECT 
            mi.id, mi.name, mi.description, mi.price, mi.image_url,
            COUNT(*) as popularity_score
          FROM menu_items mi
          JOIN order_items oi ON mi.id = oi.menu_item_id
          JOIN orders o ON oi.order_id = o.id
          WHERE o.customer_id IN (SELECT customer_id FROM similar_customers)
          AND o.restaurant_id = $2
          AND mi.is_available = true
          AND mi.id NOT IN (SELECT menu_item_id FROM customer_items)
          GROUP BY mi.id
        )
        SELECT * FROM recommended_items
        ORDER BY popularity_score DESC
        LIMIT $3`,
        [customerId, restaurantId, limit],
        'get_customer_recommendations'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo recomendaciones para cliente:', error);
      // Retornar array vacío en caso de error
      return [];
    }
  }
}

module.exports = Customer;


================================================
File: src/models/Menu.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { getFoodEmoji } = require('../utils/constants');

// ============================================
// MODELO MENU
// ============================================

class Menu {

  // ============================================
  // CATEGORÍAS
  // ============================================

  /**
   * Crea una nueva categoría de menú
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} categoryData - Datos de la categoría
   * @returns {Promise<Object>} Categoría creada
   */
  static async createCategory(restaurantId, categoryData) {
    const {
      name,
      description = '',
      display_order = 0,
      emoji = null
    } = categoryData;

    if (!name) {
      throw new ValidationError('El nombre de la categoría es requerido');
    }

    try {
      // Auto-asignar emoji si no se proporciona
      const finalEmoji = emoji || getFoodEmoji(name);

      const result = await query(
        `INSERT INTO menu_categories (
          id, restaurant_id, name, description, display_order, emoji
        ) VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING *`,
        [uuidv4(), restaurantId, name, description, display_order, finalEmoji],
        'create_menu_category'
      );

      logger.info('Categoría de menú creada', {
        restaurantId,
        categoryId: result.rows[0].id,
        name
      });

      return result.rows[0];

    } catch (error) {
      if (error.code === '23505') { // unique violation
        throw new ValidationError('Ya existe una categoría con ese nombre en este restaurante');
      }

      logger.error('Error creando categoría de menú:', error);
      throw new DatabaseError('Error al crear categoría', error);
    }
  }

  /**
   * Obtiene todas las categorías de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {boolean} activeOnly - Solo categorías activas
   * @returns {Promise<Array>} Lista de categorías
   */
  static async getCategories(restaurantId, activeOnly = true) {
    try {
      let whereClause = 'WHERE restaurant_id = $1';
      if (activeOnly) {
        whereClause += ' AND is_active = true';
      }

      const result = await query(
        `SELECT 
          id, name, description, display_order, emoji, is_active,
          created_at,
          (SELECT COUNT(*) FROM menu_items WHERE category_id = mc.id AND is_available = true) as items_count
        FROM menu_categories mc
        ${whereClause}
        ORDER BY display_order, name`,
        [restaurantId],
        'get_menu_categories'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo categorías de menú:', error);
      throw new DatabaseError('Error al obtener categorías', error);
    }
  }

  /**
   * Actualiza una categoría
   * @param {string} categoryId - ID de la categoría
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Categoría actualizada
   */
  static async updateCategory(categoryId, updateData) {
    const allowedFields = ['name', 'description', 'display_order', 'emoji', 'is_active'];
    
    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos válidos para actualizar');
    }

    values.push(categoryId);

    try {
      const result = await query(
        `UPDATE menu_categories 
         SET ${fields.join(', ')}
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_menu_category'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Categoría');
      }

      logger.info('Categoría actualizada', {
        categoryId,
        updatedFields: Object.keys(updateData)
      });

      return result.rows[0];

    } catch (error) {
      if (error.code === '23505') {
        throw new ValidationError('Ya existe una categoría con ese nombre');
      }

      logger.error('Error actualizando categoría:', error);
      throw new DatabaseError('Error al actualizar categoría', error);
    }
  }

  // ============================================
  // ITEMS DEL MENÚ
  // ============================================

  /**
   * Crea un nuevo item del menú
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} itemData - Datos del item
   * @returns {Promise<Object>} Item creado
   */
  static async createItem(restaurantId, itemData) {
    const {
      category_id,
      name,
      description = '',
      price,
      preparation_time = 15,
      display_order = 0,
      ingredients = [],
      allergens = [],
      calories = null,
      image_url = null
    } = itemData;

    if (!category_id || !name || !price) {
      throw new ValidationError('Categoría, nombre y precio son requeridos');
    }

    if (price <= 0) {
      throw new ValidationError('El precio debe ser mayor a 0');
    }

    try {
      // Verificar que la categoría pertenece al restaurante
      const categoryCheck = await query(
        'SELECT id FROM menu_categories WHERE id = $1 AND restaurant_id = $2',
        [category_id, restaurantId],
        'check_category_ownership'
      );

      if (categoryCheck.rows.length === 0) {
        throw new ValidationError('La categoría no pertenece a este restaurante');
      }

      const result = await query(
        `INSERT INTO menu_items (
          id, restaurant_id, category_id, name, description, price,
          preparation_time, display_order, ingredients, allergens, calories, image_url
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        RETURNING *`,
        [
          uuidv4(), restaurantId, category_id, name, description, price,
          preparation_time, display_order, ingredients, allergens, calories, image_url
        ],
        'create_menu_item'
      );

      logger.info('Item de menú creado', {
        restaurantId,
        itemId: result.rows[0].id,
        name,
        price
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error creando item de menú:', error);
      throw new DatabaseError('Error al crear item de menú', error);
    }
  }

  /**
   * Obtiene el menú completo de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {boolean} availableOnly - Solo items disponibles
   * @returns {Promise<Object>} Menú organizado por categorías
   */
  static async getFullMenu(restaurantId, availableOnly = true) {
    try {
      let itemCondition = 'mi.restaurant_id = $1';
      if (availableOnly) {
        itemCondition += ' AND mi.is_available = true AND mc.is_active = true';
      }

      const result = await query(
        `SELECT 
          mc.id as category_id,
          mc.name as category_name,
          mc.description as category_description,
          mc.emoji as category_emoji,
          mc.display_order as category_order,
          mi.id as item_id,
          mi.name as item_name,
          mi.description as item_description,
          mi.price,
          mi.preparation_time,
          mi.display_order as item_order,
          mi.ingredients,
          mi.allergens,
          mi.calories,
          mi.image_url,
          mi.is_available
        FROM menu_categories mc
        LEFT JOIN menu_items mi ON mc.id = mi.category_id AND ${itemCondition}
        WHERE mc.restaurant_id = $1
        ORDER BY mc.display_order, mc.name, mi.display_order, mi.name`,
        [restaurantId],
        'get_full_menu'
      );

      // Organizar por categorías
      const menu = {};
      
      result.rows.forEach(row => {
        const categoryKey = row.category_id;
        
        if (!menu[categoryKey]) {
          menu[categoryKey] = {
            id: row.category_id,
            name: row.category_name,
            description: row.category_description,
            emoji: row.category_emoji,
            display_order: row.category_order,
            items: []
          };
        }

        if (row.item_id) {
          menu[categoryKey].items.push({
            id: row.item_id,
            name: row.item_name,
            description: row.item_description,
            price: parseFloat(row.price),
            preparation_time: row.preparation_time,
            display_order: row.item_order,
            ingredients: row.ingredients || [],
            allergens: row.allergens || [],
            calories: row.calories,
            image_url: row.image_url,
            is_available: row.is_available
          });
        }
      });

      // Convertir a array ordenado
      const menuArray = Object.values(menu).sort((a, b) => a.display_order - b.display_order);

      return {
        restaurant_id: restaurantId,
        categories: menuArray,
        total_categories: menuArray.length,
        total_items: menuArray.reduce((sum, cat) => sum + cat.items.length, 0)
      };

    } catch (error) {
      logger.error('Error obteniendo menú completo:', error);
      throw new DatabaseError('Error al obtener menú', error);
    }
  }

  /**
   * Obtiene un item específico del menú
   * @param {string} itemId - ID del item
   * @param {string} restaurantId - ID del restaurante (para verificación)
   * @returns {Promise<Object|null>} Item del menú
   */
  static async getItem(itemId, restaurantId = null) {
    try {
      let whereClause = 'WHERE mi.id = $1';
      const values = [itemId];

      if (restaurantId) {
        whereClause += ' AND mi.restaurant_id = $2';
        values.push(restaurantId);
      }

      const result = await query(
        `SELECT 
          mi.*,
          mc.name as category_name,
          mc.emoji as category_emoji
        FROM menu_items mi
        JOIN menu_categories mc ON mi.category_id = mc.id
        ${whereClause}`,
        values,
        'get_menu_item'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error obteniendo item de menú:', error);
      throw new DatabaseError('Error al obtener item', error);
    }
  }

  /**
   * Actualiza un item del menú
   * @param {string} itemId - ID del item
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Item actualizado
   */
  static async updateItem(itemId, updateData) {
    const allowedFields = [
      'category_id', 'name', 'description', 'price', 'is_available',
      'preparation_time', 'display_order', 'ingredients', 'allergens',
      'calories', 'image_url'
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos válidos para actualizar');
    }

    // Validar precio si se está actualizando
    if (updateData.price !== undefined && updateData.price <= 0) {
      throw new ValidationError('El precio debe ser mayor a 0');
    }

    values.push(itemId);

    try {
      const result = await query(
        `UPDATE menu_items 
         SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_menu_item'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Item de menú');
      }

      logger.info('Item de menú actualizado', {
        itemId,
        updatedFields: Object.keys(updateData)
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando item de menú:', error);
      throw new DatabaseError('Error al actualizar item', error);
    }
  }

  /**
   * Cambia disponibilidad de un item
   * @param {string} itemId - ID del item
   * @param {boolean} isAvailable - Nueva disponibilidad
   * @returns {Promise<boolean>} True si se actualizó correctamente
   */
  static async setItemAvailability(itemId, isAvailable) {
    try {
      const result = await query(
        'UPDATE menu_items SET is_available = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING id',
        [isAvailable, itemId],
        'set_item_availability'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Item de menú');
      }

      logger.info('Disponibilidad de item actualizada', {
        itemId,
        isAvailable
      });

      return true;

    } catch (error) {
      logger.error('Error actualizando disponibilidad de item:', error);
      throw new DatabaseError('Error al actualizar disponibilidad', error);
    }
  }

  /**
   * Elimina un item del menú (soft delete)
   * @param {string} itemId - ID del item
   * @returns {Promise<boolean>} True si se eliminó correctamente
   */
  static async deleteItem(itemId) {
    try {
      // Verificar si el item tiene pedidos asociados
      const ordersCheck = await query(
        'SELECT COUNT(*) as count FROM order_items WHERE menu_item_id = $1',
        [itemId],
        'check_item_orders'
      );

      if (parseInt(ordersCheck.rows[0].count) > 0) {
        // Si hay pedidos, solo desactivar
        return await this.setItemAvailability(itemId, false);
      }

      // Si no hay pedidos, eliminar físicamente
      const result = await query(
        'DELETE FROM menu_items WHERE id = $1 RETURNING id',
        [itemId],
        'delete_menu_item'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Item de menú');
      }

      logger.info('Item de menú eliminado', { itemId });
      return true;

    } catch (error) {
      logger.error('Error eliminando item de menú:', error);
      throw new DatabaseError('Error al eliminar item', error);
    }
  }

  /**
   * Busca items en el menú
   * @param {string} restaurantId - ID del restaurante
   * @param {string} searchTerm - Término de búsqueda
   * @param {Object} filters - Filtros adicionales
   * @returns {Promise<Array>} Items encontrados
   */
  static async searchItems(restaurantId, searchTerm, filters = {}) {
    const {
      categoryId = null,
      minPrice = null,
      maxPrice = null,
      availableOnly = true
    } = filters;

    try {
      const conditions = ['mi.restaurant_id = $1'];
      const values = [restaurantId];
      let paramCount = 2;

      if (searchTerm) {
        conditions.push(`(mi.name ILIKE $${paramCount} OR mi.description ILIKE $${paramCount})`);
        values.push(`%${searchTerm}%`);
        paramCount++;
      }

      if (categoryId) {
        conditions.push(`mi.category_id = $${paramCount}`);
        values.push(categoryId);
        paramCount++;
      }

      if (minPrice !== null) {
        conditions.push(`mi.price >= $${paramCount}`);
        values.push(minPrice);
        paramCount++;
      }

      if (maxPrice !== null) {
        conditions.push(`mi.price <= $${paramCount}`);
        values.push(maxPrice);
        paramCount++;
      }

      if (availableOnly) {
        conditions.push('mi.is_available = true');
        conditions.push('mc.is_active = true');
      }

      const result = await query(
        `SELECT 
          mi.*,
          mc.name as category_name,
          mc.emoji as category_emoji
        FROM menu_items mi
        JOIN menu_categories mc ON mi.category_id = mc.id
        WHERE ${conditions.join(' AND ')}
        ORDER BY mi.name`,
        values,
        'search_menu_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error buscando items de menú:', error);
      throw new DatabaseError('Error al buscar items', error);
    }
  }

  /**
   * Obtiene items más populares de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {number} limit - Número de items a retornar
   * @returns {Promise<Array>} Items más populares
   */
  static async getPopularItems(restaurantId, limit = 10) {
    try {
      const result = await query(
        `SELECT 
          mi.*,
          mc.name as category_name,
          COUNT(oi.id) as order_count,
          SUM(oi.quantity) as total_quantity,
          COALESCE(SUM(oi.item_total), 0) as total_revenue
        FROM menu_items mi
        JOIN menu_categories mc ON mi.category_id = mc.id
        LEFT JOIN order_items oi ON mi.id = oi.menu_item_id
        WHERE mi.restaurant_id = $1 AND mi.is_available = true
        GROUP BY mi.id, mc.name
        ORDER BY order_count DESC, total_quantity DESC
        LIMIT $2`,
        [restaurantId, limit],
        'get_popular_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo items populares:', error);
      throw new DatabaseError('Error al obtener items populares', error);
    }
  }

  /**
   * Actualiza orden de display en lote
   * @param {Array} updates - Array de {id, display_order}
   * @returns {Promise<boolean>} True si se actualizó correctamente
   */
  static async updateDisplayOrder(updates) {
    if (!Array.isArray(updates) || updates.length === 0) {
      throw new ValidationError('Se requiere un array de actualizaciones');
    }

    try {
      return await transaction(async (client) => {
        for (const update of updates) {
          await client.query(
            'UPDATE menu_items SET display_order = $1 WHERE id = $2',
            [update.display_order, update.id]
          );
        }

        logger.info('Orden de display actualizado', {
          updatedCount: updates.length
        });

        return true;
      });

    } catch (error) {
      logger.error('Error actualizando orden de display:', error);
      throw new DatabaseError('Error al actualizar orden', error);
    }
  }
}

module.exports = Menu;


================================================
File: src/models/Order.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { ORDER_STATUS, BUSINESS_CONFIG } = require('../utils/constants');

// ============================================
// MODELO ORDER
// ============================================

class Order {

  /**
   * Crea un nuevo pedido desde una conversación
   * @param {Object} orderData - Datos del pedido
   * @returns {Promise<Object>} Pedido creado
   */
  static async create(orderData) {
    const {
      restaurant_id,
      customer_id = null,
      conversation_id = null,
      customer_phone,
      customer_name = null,
      delivery_street,
      delivery_number,
      delivery_neighborhood,
      delivery_references = null,
      delivery_postal_code = null,
      items = [],
      subtotal,
      delivery_fee = 0,
      total,
      estimated_delivery_time = null,
      special_instructions = null
    } = orderData;

    // Validaciones básicas
    if (!restaurant_id || !customer_phone || !items || items.length === 0) {
      throw new ValidationError('Datos de pedido incompletos');
    }

    if (!delivery_street || !delivery_number || !delivery_neighborhood) {
      throw new ValidationError('Dirección de entrega incompleta');
    }

    if (subtotal <= 0 || total <= 0) {
      throw new ValidationError('Montos del pedido inválidos');
    }

    try {
      return await transaction(async (client) => {
        // Crear el pedido principal
        const orderResult = await client.query(
          `INSERT INTO orders (
            id, restaurant_id, customer_id, conversation_id, customer_phone, customer_name,
            delivery_street, delivery_number, delivery_neighborhood, 
            delivery_references, delivery_postal_code,
            subtotal, delivery_fee, total, estimated_delivery_time, special_instructions
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
          RETURNING *`,
          [
            uuidv4(), restaurant_id, customer_id, conversation_id, customer_phone, customer_name,
            delivery_street, delivery_number, delivery_neighborhood,
            delivery_references, delivery_postal_code,
            subtotal, delivery_fee, total, estimated_delivery_time, special_instructions
          ]
        );

        const order = orderResult.rows[0];

        // Crear los items del pedido
        for (const item of items) {
          await client.query(
            `INSERT INTO order_items (
              id, order_id, menu_item_id, item_name, base_price, quantity,
              customizations, customizations_cost, item_total, special_notes
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
            [
              uuidv4(),
              order.id,
              item.menu_item_id,
              item.name,
              item.base_price,
              item.quantity,
              JSON.stringify(item.customizations || []),
              item.customizations_cost || 0,
              item.item_total,
              item.notes || null
            ]
          );
        }

        // Actualizar estadísticas del cliente si existe
        if (customer_id) {
          await client.query(
            `UPDATE customers 
             SET total_orders = total_orders + 1,
                 total_spent = total_spent + $1,
                 last_order_at = CURRENT_TIMESTAMP
             WHERE id = $2`,
            [total, customer_id]
          );
        }

        logger.info('Pedido creado exitosamente', {
          orderId: order.id,
          restaurantId: restaurant_id,
          customerPhone: customer_phone.substring(0, 8) + '****',
          total: total,
          itemsCount: items.length
        });

        return order;
      });

    } catch (error) {
      logger.error('Error creando pedido:', error);
      throw new DatabaseError('Error al crear pedido', error);
    }
  }

  /**
   * Obtiene un pedido por ID
   * @param {string} orderId - ID del pedido
   * @param {string} restaurantId - ID del restaurante (opcional, para verificación)
   * @returns {Promise<Object|null>} Pedido con sus items
   */
  static async findById(orderId, restaurantId = null) {
    try {
      let whereClause = 'WHERE o.id = $1';
      const values = [orderId];

      if (restaurantId) {
        whereClause += ' AND o.restaurant_id = $2';
        values.push(restaurantId);
      }

      // Obtener datos del pedido
      const orderResult = await query(
        `SELECT 
          o.*,
          r.name as restaurant_name,
          r.phone as restaurant_phone
        FROM orders o
        JOIN restaurants r ON o.restaurant_id = r.id
        ${whereClause}`,
        values,
        'find_order_by_id'
      );

      if (orderResult.rows.length === 0) {
        return null;
      }

      const order = orderResult.rows[0];

      // Obtener items del pedido
      const itemsResult = await query(
        `SELECT 
          oi.*,
          mi.description as menu_item_description,
          mi.image_url as menu_item_image
        FROM order_items oi
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE oi.order_id = $1
        ORDER BY oi.created_at`,
        [orderId],
        'get_order_items'
      );

      // Parsear customizaciones
      order.items = itemsResult.rows.map(item => ({
        ...item,
        customizations: JSON.parse(item.customizations || '[]')
      }));

      return order;

    } catch (error) {
      logger.error('Error obteniendo pedido por ID:', error);
      throw new DatabaseError('Error al obtener pedido', error);
    }
  }

  /**
   * Actualiza el estado de un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} newStatus - Nuevo estado
   * @param {Object} additionalData - Datos adicionales
   * @returns {Promise<Object>} Pedido actualizado
   */
  static async updateStatus(orderId, newStatus, additionalData = {}) {
    const validStatuses = Object.values(ORDER_STATUS);
    
    if (!validStatuses.includes(newStatus)) {
      throw new ValidationError('Estado de pedido inválido');
    }

    try {
      const fields = ['status = $2'];
      const values = [orderId, newStatus];
      let paramCount = 3;

      // Agregar timestamp específico según el estado
      if (newStatus === ORDER_STATUS.DELIVERED) {
        fields.push(`delivered_at = CURRENT_TIMESTAMP`);
      }

      // Agregar notas internas si se proporcionan
      if (additionalData.internal_notes) {
        fields.push(`internal_notes = $${paramCount}`);
        values.push(additionalData.internal_notes);
        paramCount++;
      }

      // Agregar tiempo estimado si se proporciona
      if (additionalData.estimated_delivery_time) {
        fields.push(`estimated_delivery_time = $${paramCount}`);
        values.push(additionalData.estimated_delivery_time);
        paramCount++;
      }

      const result = await query(
        `UPDATE orders 
         SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP
         WHERE id = $1
         RETURNING *`,
        values,
        'update_order_status'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Pedido');
      }

      logger.info('Estado de pedido actualizado', {
        orderId,
        newStatus,
        previousStatus: result.rows[0].status
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando estado de pedido:', error);
      throw new DatabaseError('Error al actualizar pedido', error);
    }
  }

  /**
   * Obtiene pedidos de un restaurante con filtros
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Lista paginada de pedidos
   */
  static async findByRestaurant(restaurantId, options = {}) {
    const {
      page = 1,
      limit = 20,
      status = null,
      customerPhone = null,
      startDate = null,
      endDate = null,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = options;

    const offset = (page - 1) * limit;
    const validSortFields = ['created_at', 'total', 'status', 'customer_name'];
    const validSortOrders = ['ASC', 'DESC'];

    if (!validSortFields.includes(sortBy)) {
      throw new ValidationError('Campo de ordenamiento inválido');
    }

    if (!validSortOrders.includes(sortOrder.toUpperCase())) {
      throw new ValidationError('Orden de ordenamiento inválido');
    }

    try {
      const conditions = ['o.restaurant_id = $1'];
      const values = [restaurantId];
      let paramCount = 2;

      if (status) {
        conditions.push(`o.status = $${paramCount}`);
        values.push(status);
        paramCount++;
      }

      if (customerPhone) {
        conditions.push(`o.customer_phone = $${paramCount}`);
        values.push(customerPhone);
        paramCount++;
      }

      if (startDate) {
        conditions.push(`o.created_at >= $${paramCount}`);
        values.push(startDate);
        paramCount++;
      }

      if (endDate) {
        conditions.push(`o.created_at <= $${paramCount}`);
        values.push(endDate);
        paramCount++;
      }

      const whereClause = conditions.join(' AND ');

      // Consulta principal
      const ordersResult = await query(
        `SELECT 
          o.id, o.customer_phone, o.customer_name, o.status,
          o.total, o.created_at, o.estimated_delivery_time,
          o.delivery_neighborhood,
          COUNT(oi.id) as items_count
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE ${whereClause}
        GROUP BY o.id
        ORDER BY o.${sortBy} ${sortOrder.toUpperCase()}
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'find_orders_by_restaurant'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM orders o WHERE ${whereClause}`,
        values.slice(0, -2),
        'count_orders_by_restaurant'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        orders: ordersResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error obteniendo pedidos por restaurante:', error);
      throw new DatabaseError('Error al obtener pedidos', error);
    }
  }

  /**
   * Obtiene pedidos de un cliente
   * @param {string} customerPhone - Teléfono del cliente
   * @param {string} restaurantId - ID del restaurante (opcional)
   * @param {number} limit - Límite de resultados
   * @returns {Promise<Array>} Lista de pedidos del cliente
   */
  static async findByCustomer(customerPhone, restaurantId = null, limit = 10) {
    try {
      let whereClause = 'WHERE o.customer_phone = $1';
      const values = [customerPhone];

      if (restaurantId) {
        whereClause += ' AND o.restaurant_id = $2';
        values.push(restaurantId);
        values.push(limit);
      } else {
        values.push(limit);
      }

      const result = await query(
        `SELECT 
          o.*,
          r.name as restaurant_name,
          COUNT(oi.id) as items_count
        FROM orders o
        JOIN restaurants r ON o.restaurant_id = r.id
        LEFT JOIN order_items oi ON o.id = oi.order_id
        ${whereClause}
        GROUP BY o.id, r.name
        ORDER BY o.created_at DESC
        LIMIT $${values.length}`,
        values,
        'find_orders_by_customer'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo pedidos por cliente:', error);
      throw new DatabaseError('Error al obtener pedidos del cliente', error);
    }
  }

  /**
   * Obtiene estadísticas de pedidos
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas de pedidos
   */
  static async getStats(restaurantId, dateRange = {}) {
    const { startDate, endDate } = dateRange;
    
    try {
      let dateCondition = '';
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = 'AND o.created_at BETWEEN $2 AND $3';
        values.push(startDate, endDate);
      }

      const result = await query(
        `SELECT 
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as delivered_orders,
          COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_orders,
          COUNT(CASE WHEN status = 'preparing' THEN 1 END) as preparing_orders,
          COUNT(DISTINCT customer_phone) as unique_customers,
          COALESCE(SUM(total), 0) as total_revenue,
          COALESCE(AVG(total), 0) as average_order_value,
          COALESCE(SUM(delivery_fee), 0) as total_delivery_fees,
          AVG(CASE 
            WHEN delivered_at IS NOT NULL THEN 
              EXTRACT(EPOCH FROM (delivered_at - created_at))/60 
            END) as avg_delivery_time_minutes
        FROM orders o
        WHERE restaurant_id = $1 ${dateCondition}`,
        values,
        'get_order_stats'
      );

      const stats = result.rows[0];

      // Calcular tasas
      const totalOrders = parseInt(stats.total_orders);
      stats.delivery_rate = totalOrders > 0 
        ? ((parseInt(stats.delivered_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.cancellation_rate = totalOrders > 0
        ? ((parseInt(stats.cancelled_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.average_order_value = parseFloat(stats.average_order_value || 0).toFixed(2);
      stats.avg_delivery_time_minutes = parseFloat(stats.avg_delivery_time_minutes || 0).toFixed(2);

      return stats;

    } catch (error) {
      logger.error('Error obteniendo estadísticas de pedidos:', error);
      throw new DatabaseError('Error al obtener estadísticas', error);
    }
  }

  /**
   * Obtiene los items más vendidos
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @param {number} limit - Límite de resultados
   * @returns {Promise<Array>} Items más vendidos
   */
  static async getTopItems(restaurantId, dateRange = {}, limit = 10) {
    const { startDate, endDate } = dateRange;
    
    try {
      let dateCondition = '';
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = 'AND o.created_at BETWEEN $2 AND $3';
        values.push(startDate, endDate);
        values.push(limit);
      } else {
        values.push(limit);
      }

      const result = await query(
        `SELECT 
          oi.item_name,
          oi.menu_item_id,
          COUNT(*) as order_count,
          SUM(oi.quantity) as total_quantity,
          SUM(oi.item_total) as total_revenue,
          AVG(oi.base_price) as avg_price,
          mi.image_url
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE o.restaurant_id = $1 AND o.status != 'cancelled' ${dateCondition}
        GROUP BY oi.menu_item_id, oi.item_name, mi.image_url
        ORDER BY total_quantity DESC, order_count DESC
        LIMIT $${values.length}`,
        values,
        'get_top_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo items más vendidos:', error);
      throw new DatabaseError('Error al obtener items populares', error);
    }
  }

  /**
   * Obtiene pedidos activos (en preparación/camino)
   * @param {string} restaurantId - ID del restaurante
   * @returns {Promise<Array>} Pedidos activos
   */
  static async getActiveOrders(restaurantId) {
    try {
      const result = await query(
        `SELECT 
          o.*,
          COUNT(oi.id) as items_count,
          EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - o.created_at))/60 as minutes_since_order
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE o.restaurant_id = $1 
        AND o.status IN ('confirmed', 'preparing', 'ready', 'out_for_delivery')
        GROUP BY o.id
        ORDER BY o.created_at ASC`,
        [restaurantId],
        'get_active_orders'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo pedidos activos:', error);
      throw new DatabaseError('Error al obtener pedidos activos', error);
    }
  }

  /**
   * Cancela un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} reason - Razón de cancelación
   * @returns {Promise<Object>} Pedido cancelado
   */
  static async cancel(orderId, reason = null) {
    try {
      // Verificar que el pedido pueda ser cancelado
      const order = await this.findById(orderId);
      if (!order) {
        throw new NotFoundError('Pedido');
      }

      if (order.status === ORDER_STATUS.DELIVERED) {
        throw new ValidationError('No se puede cancelar un pedido ya entregado');
      }

      if (order.status === ORDER_STATUS.CANCELLED) {
        throw new ValidationError('El pedido ya está cancelado');
      }

      const result = await this.updateStatus(orderId, ORDER_STATUS.CANCELLED, {
        internal_notes: reason ? `Cancelado: ${reason}` : 'Pedido cancelado'
      });

      logger.info('Pedido cancelado', {
        orderId,
        reason,
        previousStatus: order.status
      });

      return result;

    } catch (error) {
      logger.error('Error cancelando pedido:', error);
      throw new DatabaseError('Error al cancelar pedido', error);
    }
  }

  /**
   * Calcula el tiempo estimado de entrega
   * @param {string} restaurantId - ID del restaurante
   * @param {string} neighborhood - Colonia de entrega
   * @returns {Promise<number>} Tiempo estimado en minutos
   */
  static async calculateDeliveryTime(restaurantId, neighborhood = null) {
    try {
      // Obtener configuración base del restaurante
      const restaurantResult = await query(
        'SELECT delivery_time_min, delivery_time_max FROM restaurants WHERE id = $1',
        [restaurantId],
        'get_restaurant_delivery_times'
      );

      if (restaurantResult.rows.length === 0) {
        return 30; // Valor por defecto
      }

      const { delivery_time_min, delivery_time_max } = restaurantResult.rows[0];

      // Verificar si hay zona específica con tiempo extra
      if (neighborhood) {
        const zoneResult = await query(
          `SELECT extra_fee FROM delivery_zones 
           WHERE restaurant_id = $1 AND $2 = ANY(neighborhoods) AND is_active = true`,
          [restaurantId, neighborhood],
          'check_delivery_zone'
        );

        // Si está en zona especial, agregar tiempo extra
        if (zoneResult.rows.length > 0) {
          return delivery_time_max + 10; // 10 minutos extra para zonas especiales
        }
      }

      // Calcular basado en pedidos actuales
      const activeOrdersResult = await query(
        `SELECT COUNT(*) as active_count 
         FROM orders 
         WHERE restaurant_id = $1 
         AND status IN ('confirmed', 'preparing')`,
        [restaurantId],
        'count_active_orders'
      );

      const activeCount = parseInt(activeOrdersResult.rows[0].active_count);

      // Ajustar tiempo basado en carga de trabajo
      let estimatedTime = delivery_time_min;
      if (activeCount > 5) {
        estimatedTime = delivery_time_max;
      } else if (activeCount > 2) {
        estimatedTime = Math.round((delivery_time_min + delivery_time_max) / 2);
      }

      return estimatedTime;

    } catch (error) {
      logger.error('Error calculando tiempo de entrega:', error);
      return 30; // Valor por defecto en caso de error
    }
  }

  /**
   * Obtiene el resumen de ventas por período
   * @param {string} restaurantId - ID del restaurante
   * @param {string} period - Período: 'today', 'week', 'month'
   * @returns {Promise<Object>} Resumen de ventas
   */
  static async getSalesSummary(restaurantId, period = 'today') {
    try {
      let dateCondition = '';
      
      switch (period) {
        case 'today':
          dateCondition = "AND DATE(created_at) = CURRENT_DATE";
          break;
        case 'week':
          dateCondition = "AND created_at >= CURRENT_DATE - INTERVAL '7 days'";
          break;
        case 'month':
          dateCondition = "AND created_at >= CURRENT_DATE - INTERVAL '30 days'";
          break;
        default:
          dateCondition = "AND DATE(created_at) = CURRENT_DATE";
      }

      const result = await query(
        `SELECT 
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as completed_orders,
          COALESCE(SUM(CASE WHEN status = 'delivered' THEN total ELSE 0 END), 0) as total_sales,
          COALESCE(AVG(CASE WHEN status = 'delivered' THEN total ELSE NULL END), 0) as avg_order_value,
          COUNT(DISTINCT customer_phone) as unique_customers
        FROM orders 
        WHERE restaurant_id = $1 ${dateCondition}`,
        [restaurantId],
        'get_sales_summary'
      );

      const summary = result.rows[0];
      summary.period = period;
      summary.completion_rate = summary.total_orders > 0 
        ? ((summary.completed_orders / summary.total_orders) * 100).toFixed(2)
        : 0;

      return summary;

    } catch (error) {
      logger.error('Error obteniendo resumen de ventas:', error);
      throw new DatabaseError('Error al obtener resumen de ventas', error);
    }
  }
}

module.exports = Order;


================================================
File: src/models/Restaurant.js
================================================
const { query, transaction } = require("../config/database");
const logger = require("../utils/logger");
const { v4: uuidv4 } = require("uuid");
const bcrypt = require("bcryptjs");
const {
  ValidationError,
  DatabaseError,
  NotFoundError,
} = require("../middleware/errorHandler");

// ============================================
// MODELO RESTAURANT
// ============================================

class Restaurant {
  /**
   * Crea un nuevo restaurante
   * @param {Object} restaurantData - Datos del restaurante
   * @returns {Promise<Object>} Restaurante creado
   */
  static async create(restaurantData) {
    const {
      name,
      slug,
      phone,
      email,
      address,
      logo_url,
      country_code = "MX", // NUEVO
      currency = "MXN", // NUEVO
      timezone = "America/Mexico_City", // NUEVO
      opens_at = "09:00:00",
      closes_at = "23:00:00",
      delivery_time_min = 25,
      delivery_time_max = 35,
      delivery_fee = 0.0,
      minimum_order = 0.0,
      whatsapp_phone_id,
      twilio_phone_number,
    } = restaurantData;

    // Validaciones básicas
    if (!name || !slug || !phone) {
      throw new ValidationError("Nombre, slug y teléfono son requeridos");
    }

    try {
      return await transaction(async (client) => {
        // Crear restaurante
        const restaurantResult = await client.query(
          `INSERT INTO restaurants (
    id, name, slug, phone, email, address, logo_url,
    country_code, currency, timezone,
    opens_at, closes_at, delivery_time_min, delivery_time_max,
    delivery_fee, minimum_order, whatsapp_phone_id, twilio_phone_number
  ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
  RETURNING *`,
          [
            uuidv4(),
            name,
            slug,
            phone,
            email,
            address,
            logo_url,
            country_code,
            currency,
            timezone,
            opens_at,
            closes_at,
            delivery_time_min,
            delivery_time_max,
            delivery_fee,
            minimum_order,
            whatsapp_phone_id,
            twilio_phone_number,
          ]
        );

        const restaurant = restaurantResult.rows[0];

        // Crear configuración por defecto
        await client.query(
          `INSERT INTO restaurant_settings (
            id, restaurant_id, ai_personality, welcome_message, goodbye_message, error_message
          ) VALUES ($1, $2, $3, $4, $5, $6)`,
          [
            uuidv4(),
            restaurant.id,
            "Amigable y servicial",
            `¡Hola! 👋 Bienvenido a ${name}. ¿En qué puedo ayudarte hoy?`,
            "¡Gracias por tu pedido! 🙏 Te esperamos pronto.",
            "Lo siento, tuve un problema técnico. ¿Podrías repetir tu mensaje?",
          ]
        );

        logger.info("Restaurante creado exitosamente", {
          restaurantId: restaurant.id,
          name: restaurant.name,
          slug: restaurant.slug,
        });

        return restaurant;
      });
    } catch (error) {
      if (error.code === "23505") {
        // unique violation
        if (error.constraint === "restaurants_slug_key") {
          throw new ValidationError("El slug ya está en uso");
        }
        if (error.constraint === "restaurants_phone_key") {
          throw new ValidationError("El teléfono ya está registrado");
        }
      }

      logger.error("Error creando restaurante:", error);
      throw new DatabaseError("Error al crear restaurante", error);
    }
  }

  /**
   * Obtiene un restaurante por ID
   * @param {string} id - ID del restaurante
   * @returns {Promise<Object|null>} Datos del restaurante
   */
  static async findById(id) {
    try {
      const result = await query(
        `SELECT 
          r.*,
          rs.claude_api_key,
          rs.claude_model,
          rs.ai_personality,
          rs.welcome_message,
          rs.goodbye_message,
          rs.error_message,
          rs.auto_confirm_orders,
          rs.max_conversation_time,
          rs.notification_email,
          rs.notification_phone
        FROM restaurants r
        LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
        WHERE r.id = $1`,
        [id],
        "find_restaurant_by_id"
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error("Error obteniendo restaurante por ID:", error);
      throw new DatabaseError("Error al obtener restaurante", error);
    }
  }

  /**
   * Obtiene un restaurante por slug
   * @param {string} slug - Slug del restaurante
   * @returns {Promise<Object|null>} Datos del restaurante
   */
  static async findBySlug(slug) {
    try {
      const result = await query(
        `SELECT 
          r.*,
          rs.claude_api_key,
          rs.claude_model,
          rs.ai_personality,
          rs.welcome_message,
          rs.goodbye_message,
          rs.error_message,
          rs.auto_confirm_orders,
          rs.max_conversation_time,
          rs.notification_email,
          rs.notification_phone
        FROM restaurants r
        LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
        WHERE r.slug = $1`,
        [slug],
        "find_restaurant_by_slug"
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error("Error obteniendo restaurante por slug:", error);
      throw new DatabaseError("Error al obtener restaurante", error);
    }
  }

  /**
   * Obtiene un restaurante por teléfono
   * @param {string} phone - Teléfono del restaurante
   * @returns {Promise<Object|null>} Datos del restaurante
   */
  static async findByPhone(phone) {
    try {
      const result = await query(
        `SELECT 
          r.*,
          rs.claude_api_key,
          rs.claude_model,
          rs.ai_personality,
          rs.welcome_message,
          rs.goodbye_message,
          rs.error_message
        FROM restaurants r
        LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
        WHERE r.phone = $1 OR r.twilio_phone_number = $1`,
        [phone],
        "find_restaurant_by_phone"
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error("Error obteniendo restaurante por teléfono:", error);
      throw new DatabaseError("Error al obtener restaurante", error);
    }
  }

  /**
   * Actualiza un restaurante
   * @param {string} id - ID del restaurante
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Restaurante actualizado
   */
  static async update(id, updateData) {
    const allowedFields = [
      "name",
      "phone",
      "email",
      "address",
      "logo_url",
      "is_active",
      "opens_at",
      "closes_at",
      "delivery_time_min",
      "delivery_time_max",
      "delivery_fee",
      "minimum_order",
      "whatsapp_phone_id",
      "twilio_phone_number",
      "country_code",
      "currency",
      "timezone",
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    // Construir query dinámicamente
    Object.keys(updateData).forEach((key) => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError("No hay campos válidos para actualizar");
    }

    values.push(id); // ID va al final

    try {
      const result = await query(
        `UPDATE restaurants 
         SET ${fields.join(", ")}, updated_at = CURRENT_TIMESTAMP
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        "update_restaurant"
      );

      if (result.rows.length === 0) {
        throw new NotFoundError("Restaurante");
      }

      logger.info("Restaurante actualizado", {
        restaurantId: id,
        updatedFields: Object.keys(updateData),
      });

      return result.rows[0];
    } catch (error) {
      if (error.code === "23505") {
        // unique violation
        if (error.constraint === "restaurants_phone_key") {
          throw new ValidationError("El teléfono ya está registrado");
        }
      }

      logger.error("Error actualizando restaurante:", error);
      throw new DatabaseError("Error al actualizar restaurante", error);
    }
  }

  /**
   * Actualiza configuración del restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} settingsData - Configuración a actualizar
   * @returns {Promise<Object>} Configuración actualizada
   */
  static async updateSettings(restaurantId, settingsData) {
    const allowedFields = [
      "claude_api_key",
      "claude_model",
      "ai_personality",
      "welcome_message",
      "goodbye_message",
      "error_message",
      "auto_confirm_orders",
      "require_phone_validation",
      "max_conversation_time",
      "notification_email",
      "notification_phone",
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(settingsData).forEach((key) => {
      if (allowedFields.includes(key) && settingsData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(settingsData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError("No hay campos válidos para actualizar");
    }

    values.push(restaurantId);

    try {
      // Verificar si existe configuración
      const existsResult = await query(
        "SELECT id FROM restaurant_settings WHERE restaurant_id = $1",
        [restaurantId],
        "check_restaurant_settings_exists"
      );

      let result;

      if (existsResult.rows.length > 0) {
        // Actualizar existente
        result = await query(
          `UPDATE restaurant_settings 
           SET ${fields.join(", ")}, updated_at = CURRENT_TIMESTAMP
           WHERE restaurant_id = $${paramCount}
           RETURNING *`,
          values,
          "update_restaurant_settings"
        );
      } else {
        // Crear nueva configuración
        const insertFields = [
          "id",
          "restaurant_id",
          ...Object.keys(settingsData),
        ];
        const insertValues = [
          uuidv4(),
          restaurantId,
          ...Object.values(settingsData),
        ];
        const placeholders = insertValues.map((_, i) => `$${i + 1}`).join(", ");

        result = await query(
          `INSERT INTO restaurant_settings (${insertFields.join(", ")})
           VALUES (${placeholders})
           RETURNING *`,
          insertValues,
          "create_restaurant_settings"
        );
      }

      logger.info("Configuración de restaurante actualizada", {
        restaurantId,
        updatedFields: Object.keys(settingsData),
      });

      return result.rows[0];
    } catch (error) {
      logger.error("Error actualizando configuración de restaurante:", error);
      throw new DatabaseError("Error al actualizar configuración", error);
    }
  }

  /**
   * Obtiene lista de restaurantes con paginación
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Lista paginada de restaurantes
   */
  static async findAll(options = {}) {
    const {
      page = 1,
      limit = 10,
      search = "",
      isActive = null,
      sortBy = "created_at",
      sortOrder = "DESC",
    } = options;

    const offset = (page - 1) * limit;
    const validSortFields = ["name", "created_at", "updated_at"];
    const validSortOrders = ["ASC", "DESC"];

    if (!validSortFields.includes(sortBy)) {
      throw new ValidationError("Campo de ordenamiento inválido");
    }

    if (!validSortOrders.includes(sortOrder.toUpperCase())) {
      throw new ValidationError("Orden de ordenamiento inválido");
    }

    try {
      // Construir WHERE clause
      const conditions = [];
      const values = [];
      let paramCount = 1;

      if (search) {
        conditions.push(
          `(r.name ILIKE $${paramCount} OR r.slug ILIKE $${paramCount})`
        );
        values.push(`%${search}%`);
        paramCount++;
      }

      if (isActive !== null) {
        conditions.push(`r.is_active = $${paramCount}`);
        values.push(isActive);
        paramCount++;
      }

      const whereClause =
        conditions.length > 0 ? "WHERE " + conditions.join(" AND ") : "";

      // Consulta principal
      const restaurantsResult = await query(
        `SELECT 
          r.id, r.name, r.slug, r.phone, r.email, r.is_active,
          r.opens_at, r.closes_at, r.created_at, r.updated_at,
          COUNT(o.id) as total_orders,
          COALESCE(SUM(o.total), 0) as total_revenue
        FROM restaurants r
        LEFT JOIN orders o ON r.id = o.restaurant_id
        ${whereClause}
        GROUP BY r.id
        ORDER BY r.${sortBy} ${sortOrder.toUpperCase()}
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        "find_all_restaurants"
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM restaurants r ${whereClause}`,
        values.slice(0, -2), // Remover limit y offset
        "count_all_restaurants"
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        restaurants: restaurantsResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1,
        },
      };
    } catch (error) {
      logger.error("Error obteniendo lista de restaurantes:", error);
      throw new DatabaseError("Error al obtener restaurantes", error);
    }
  }

  /**
   * Desactiva un restaurante (soft delete)
   * @param {string} id - ID del restaurante
   * @returns {Promise<boolean>} True si se desactivó correctamente
   */
  static async deactivate(id) {
    try {
      const result = await query(
        "UPDATE restaurants SET is_active = false, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id",
        [id],
        "deactivate_restaurant"
      );

      if (result.rows.length === 0) {
        throw new NotFoundError("Restaurante");
      }

      logger.info("Restaurante desactivado", { restaurantId: id });
      return true;
    } catch (error) {
      logger.error("Error desactivando restaurante:", error);
      throw new DatabaseError("Error al desactivar restaurante", error);
    }
  }

  /**
   * Activa un restaurante
   * @param {string} id - ID del restaurante
   * @returns {Promise<boolean>} True si se activó correctamente
   */
  static async activate(id) {
    try {
      const result = await query(
        "UPDATE restaurants SET is_active = true, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id",
        [id],
        "activate_restaurant"
      );

      if (result.rows.length === 0) {
        throw new NotFoundError("Restaurante");
      }

      logger.info("Restaurante activado", { restaurantId: id });
      return true;
    } catch (error) {
      logger.error("Error activando restaurante:", error);
      throw new DatabaseError("Error al activar restaurante", error);
    }
  }

  /**
   * Obtiene estadísticas básicas de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas del restaurante
   */
  static async getStats(restaurantId, dateRange = {}) {
    const { startDate, endDate } = dateRange;

    try {
      let dateCondition = "";
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = "AND o.created_at BETWEEN $2 AND $3";
        values.push(startDate, endDate);
      }

      const result = await query(
        `SELECT 
          COUNT(DISTINCT o.id) as total_orders,
          COUNT(DISTINCT o.customer_phone) as unique_customers,
          COALESCE(SUM(o.total), 0) as total_revenue,
          COALESCE(AVG(o.total), 0) as average_order_value,
          COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as delivered_orders,
          COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders,
          COUNT(DISTINCT c.id) as total_conversations,
          COUNT(CASE WHEN c.status = 'completed' THEN 1 END) as completed_conversations
        FROM orders o
        LEFT JOIN conversations c ON o.restaurant_id = c.restaurant_id
        WHERE o.restaurant_id = $1 ${dateCondition}`,
        values,
        "get_restaurant_stats"
      );

      const stats = result.rows[0];

      // Calcular tasas
      stats.completion_rate =
        stats.total_orders > 0
          ? ((stats.delivered_orders / stats.total_orders) * 100).toFixed(2)
          : 0;

      stats.cancellation_rate =
        stats.total_orders > 0
          ? ((stats.cancelled_orders / stats.total_orders) * 100).toFixed(2)
          : 0;

      stats.conversion_rate =
        stats.total_conversations > 0
          ? (
              (stats.completed_conversations / stats.total_conversations) *
              100
            ).toFixed(2)
          : 0;

      return stats;
    } catch (error) {
      logger.error("Error obteniendo estadísticas de restaurante:", error);
      throw new DatabaseError("Error al obtener estadísticas", error);
    }
  }

  /**
   * Verifica si un slug está disponible
   * @param {string} slug - Slug a verificar
   * @param {string} excludeId - ID a excluir de la verificación
   * @returns {Promise<boolean>} True si está disponible
   */
  static async isSlugAvailable(slug, excludeId = null) {
    try {
      let queryText = "SELECT id FROM restaurants WHERE slug = $1";
      const values = [slug];

      if (excludeId) {
        queryText += " AND id != $2";
        values.push(excludeId);
      }

      const result = await query(queryText, values, "check_slug_availability");
      return result.rows.length === 0;
    } catch (error) {
      logger.error("Error verificando disponibilidad de slug:", error);
      throw new DatabaseError("Error al verificar slug", error);
    }
  }
}

module.exports = Restaurant;



================================================
File: src/models/User.js
================================================
const { query, transaction } = require('../../database/connection');
const bcrypt = require('bcryptjs');
const logger = require('../utils/logger');
const { DatabaseError, NotFoundError, AuthenticationError } = require('../middleware/errorHandler');

// ============================================
// MODELO DE USUARIO
// ============================================

class User {
  /**
   * Busca usuario por email con perfil y rol
   * @param {string} email - Email del usuario
   * @returns {Promise<Object|null>} Usuario con perfil y rol
   */
  static async findByEmailWithProfile(email) {
    try {
      const result = await query(
        `SELECT 
          u.id as user_id,
          u.email,
          u.password_hash,
          u.first_name,
          u.last_name,
          u.is_active,
          u.email_verified,
          u.last_login,
          
          up.id as profile_id,
          up.restaurant_id,
          up.phone,
          up.avatar_url,
          up.settings,
          
          r.name as role_name,
          r.display_name as role_display_name,
          r.permissions,
          
          rest.name as restaurant_name,
          rest.slug as restaurant_slug
          
        FROM users u
        INNER JOIN user_profiles up ON u.id = up.user_id
        INNER JOIN roles r ON up.role_id = r.id
        LEFT JOIN restaurants rest ON up.restaurant_id = rest.id
        WHERE u.email = $1 AND u.is_active = true`,
        [email],
        'find_user_by_email_with_profile'
      );

      if (result.rows.length === 0) {
        return null;
      }

      const userData = result.rows[0];

      return {
        id: userData.user_id,
        email: userData.email,
        password_hash: userData.password_hash,
        first_name: userData.first_name,
        last_name: userData.last_name,
        is_active: userData.is_active,
        email_verified: userData.email_verified,
        last_login: userData.last_login,
        profile: {
          id: userData.profile_id,
          restaurant_id: userData.restaurant_id,
          phone: userData.phone,
          avatar_url: userData.avatar_url,
          settings: userData.settings,
          role: {
            name: userData.role_name,
            display_name: userData.role_display_name,
            permissions: userData.permissions
          },
          restaurant: userData.restaurant_name ? {
            name: userData.restaurant_name,
            slug: userData.restaurant_slug
          } : null
        }
      };

    } catch (error) {
      logger.error('Error buscando usuario por email:', error);
      throw new DatabaseError('Error al buscar usuario', error);
    }
  }

  /**
   * Actualiza último login del usuario
   * @param {string} userId - ID del usuario
   * @returns {Promise<void>}
   */
  static async updateLastLogin(userId) {
    try {
      await query(
        'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1',
        [userId],
        'update_last_login'
      );

      logger.debug('Último login actualizado', { userId });

    } catch (error) {
      logger.error('Error actualizando último login:', error);
      // No lanzamos error para no interrumpir el login
    }
  }

  /**
   * Verifica contraseña
   * @param {string} plainPassword - Contraseña en texto plano
   * @param {string} hashedPassword - Contraseña hasheada
   * @returns {Promise<boolean>} True si la contraseña es correcta
   */
  static async verifyPassword(plainPassword, hashedPassword) {
    try {
      return await bcrypt.compare(plainPassword, hashedPassword);
    } catch (error) {
      logger.error('Error verificando contraseña:', error);
      return false;
    }
  }
}

module.exports = User;


================================================
File: src/routes/auth.js
================================================
const express = require('express');
const AuthController = require('../controllers/authController');
const AuthMiddleware = require('../middleware/auth');
const logger = require('../utils/logger');

const router = express.Router();

// ============================================
// RUTAS PÚBLICAS DE AUTENTICACIÓN
// ============================================

/**
 * Login de usuario
 * URL: POST /api/auth/login
 * Body: { email, password }
 */
router.post('/login', AuthController.login);

/**
 * Refresh token
 * URL: POST /api/auth/refresh
 * Body: { refresh_token }
 */
router.post('/refresh', AuthMiddleware.refreshToken, AuthController.refreshToken);

// ============================================
// RUTAS PROTEGIDAS
// ============================================

/**
 * Obtiene información del usuario actual
 * URL: GET /api/auth/me
 * Headers: Authorization: Bearer <token>
 */
router.get('/me', 
  AuthMiddleware.authenticateToken, 
  AuthController.getCurrentUser
);

/**
 * Logout (invalidar token - opcional)
 * URL: POST /api/auth/logout
 */
router.post('/logout', 
  AuthMiddleware.authenticateToken, 
  (req, res) => {
    // En una implementación real, aquí invalidarías el token en una blacklist
    logger.info('Usuario cerró sesión', { userId: req.user.id });
    
    res.json({
      success: true,
      message: 'Sesión cerrada exitosamente'
    });
  }
);

module.exports = router;


================================================
File: src/routes/dashboard.js
================================================
const express = require('express');
const ConversationController = require('../controllers/conversationController');
const RestaurantController = require('../controllers/restaurantController');
const OrderController = require('../controllers/orderController');
const MenuController = require('../controllers/menuController');
const WhatsAppService = require('../services/whatsappService');
const ClaudeService = require('../services/claudeService');
const AuthMiddleware = require('../middleware/auth');
const { dashboardTenantResolver } = require('../middleware/tenantResolver');
const { asyncHandler } = require('../middleware/errorHandler');
const logger = require('../utils/logger');

const router = express.Router();

// ============================================
// TODAS LAS RUTAS REQUIEREN AUTENTICACIÓN
// ============================================

router.use(AuthMiddleware.authenticateToken);
router.use(dashboardTenantResolver);

// ============================================
// RESUMEN GENERAL DEL DASHBOARD
// ============================================

/**
 * Obtiene resumen completo del dashboard
 * URL: GET /api/dashboard
 */
router.get('/', 
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant.id;

      // Obtener datos en paralelo para mejor rendimiento
      const [
        restaurantSummary,
        ordersSummary,
        menuSummary,
        conversationStats
      ] = await Promise.all([
        RestaurantController.getDashboardSummary(req, { json: () => {} }),
        OrderController.getOrdersSummary(req, { json: () => {} }),
        MenuController.getMenuSummary(req, { json: () => {} }),
        ConversationController.getConversationStatistics(req, { json: () => {} })
      ]);

      const dashboardData = {
        restaurant: req.restaurant,
        summary: {
          orders: ordersSummary?.data || {},
          menu: menuSummary?.data || {},
          conversations: conversationStats?.data || {}
        },
        last_updated: new Date().toISOString()
      };

      logger.info('Resumen de dashboard obtenido', {
        restaurantId,
        userId: req.user.id
      });

      res.json({
        success: true,
        data: dashboardData
      });

    } catch (error) {
      logger.error('Error obteniendo resumen de dashboard:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo resumen del dashboard'
      });
    }
  })
);

// ============================================
// GESTIÓN DE CONVERSACIONES
// ============================================

/**
 * Obtiene conversaciones del restaurante
 * URL: GET /api/dashboard/conversations
 */
router.get('/conversations',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversations
);

/**
 * Obtiene una conversación específica
 * URL: GET /api/dashboard/conversations/:conversationId
 */
router.get('/conversations/:conversationId',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversationById
);

/**
 * Obtiene conversación activa de un cliente
 * URL: GET /api/dashboard/conversations/customer/:customerPhone
 */
router.get('/conversations/customer/:customerPhone',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getActiveConversation
);

/**
 * Obtiene estado de conversación de un cliente
 * URL: GET /api/dashboard/conversations/customer/:customerPhone/status
 */
router.get('/conversations/customer/:customerPhone/status',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversationStatus
);

/**
 * Inicia una nueva conversación
 * URL: POST /api/dashboard/conversations
 */
router.post('/conversations',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.startConversation
);

/**
 * Reinicia una conversación
 * URL: POST /api/dashboard/conversations/customer/:customerPhone/restart
 */
router.post('/conversations/customer/:customerPhone/restart',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.restartConversation
);

/**
 * Actualiza una conversación
 * URL: PUT /api/dashboard/conversations/:conversationId
 */
router.put('/conversations/:conversationId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.updateConversation
);

/**
 * Marca conversación como abandonada
 * URL: POST /api/dashboard/conversations/:conversationId/abandon
 */
router.post('/conversations/:conversationId/abandon',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.abandonConversation
);

/**
 * Envía mensaje manual en conversación
 * URL: POST /api/dashboard/conversations/:conversationId/send
 */
router.post('/conversations/:conversationId/send',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.sendManualMessage
);

/**
 * Obtiene estadísticas de conversaciones
 * URL: GET /api/dashboard/conversations/statistics
 */
router.get('/conversations/statistics',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversationStatistics
);

/**
 * Limpia conversaciones inactivas
 * URL: POST /api/dashboard/conversations/cleanup
 */
router.post('/conversations/cleanup',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.cleanupInactiveConversations
);

/**
 * Exporta conversaciones
 * URL: GET /api/dashboard/conversations/export
 */
router.get('/conversations/export',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.exportConversations
);

// ============================================
// MÉTRICAS Y ESTADÍSTICAS
// ============================================

/**
 * Obtiene métricas en tiempo real
 * URL: GET /api/dashboard/metrics/realtime
 */
router.get('/metrics/realtime',
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant.id;

      // Obtener métricas en tiempo real
      const [activeOrders, recentConversations] = await Promise.all([
        OrderController.getActiveOrders(req, { json: () => {} }),
        ConversationController.getConversations(req, { 
          query: { limit: 5, status: 'active' }, 
          json: () => {} 
        })
      ]);

      const metrics = {
        active_orders: activeOrders?.data?.summary || { total: 0, delayed: 0, urgent: 0 },
        active_conversations: recentConversations?.data?.length || 0,
        restaurant_status: req.restaurant.is_active ? 'active' : 'inactive',
        last_updated: new Date().toISOString()
      };

      res.json({
        success: true,
        data: metrics
      });

    } catch (error) {
      logger.error('Error obteniendo métricas en tiempo real:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo métricas'
      });
    }
  })
);

/**
 * Obtiene métricas de rendimiento
 * URL: GET /api/dashboard/metrics/performance
 */
router.get('/metrics/performance',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant.id;

      // Obtener estadísticas de rendimiento
      const [orderStats, conversationStats] = await Promise.all([
        OrderController.getOrderStatistics(req, { json: () => {} }),
        ConversationController.getConversationStatistics(req, { json: () => {} })
      ]);

      const performance = {
        order_stats: orderStats?.data?.basic || {},
        conversation_stats: conversationStats?.data || {},
        generated_at: new Date().toISOString()
      };

      res.json({
        success: true,
        data: performance
      });

    } catch (error) {
      logger.error('Error obteniendo métricas de rendimiento:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo métricas de rendimiento'
      });
    }
  })
);

// ============================================
// CONFIGURACIÓN Y AJUSTES
// ============================================

/**
 * Obtiene configuración actual del restaurante
 * URL: GET /api/dashboard/settings
 */
router.get('/settings',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.getCurrentRestaurant
);

/**
 * Actualiza configuración del restaurante
 * URL: PUT /api/dashboard/settings
 */
router.put('/settings',
  AuthMiddleware.requireRole(['admin']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.updateCurrentRestaurant
);

/**
 * Actualiza configuración avanzada
 * URL: PUT /api/dashboard/settings/advanced
 */
router.put('/settings/advanced',
  AuthMiddleware.requireRole(['admin']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      // Reutilizar lógica del controlador de restaurantes
      req.params.id = req.restaurant.id;
      return RestaurantController.updateRestaurantSettings(req, res);

    } catch (error) {
      logger.error('Error actualizando configuración avanzada:', error);
      res.status(500).json({
        success: false,
        error: 'Error actualizando configuración'
      });
    }
  })
);

// ============================================
// HERRAMIENTAS DE DIAGNÓSTICO
// ============================================

/**
 * Verifica estado de servicios externos
 * URL: GET /api/dashboard/health/services
 */
router.get('/health/services',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      // Verificar estado de servicios
      const [whatsappStatus, claudeStatus] = await Promise.all([
        WhatsAppService.checkServicesStatus(),
        // ClaudeService.testClaudeConnection() // Implementar si es necesario
        Promise.resolve({ available: true }) // Placeholder
      ]);

      const servicesHealth = {
        whatsapp: {
          status: whatsappStatus.healthy ? 'healthy' : 'unhealthy',
          active_provider: whatsappStatus.activeProvider,
          details: whatsappStatus
        },
        claude: {
          status: claudeStatus.available ? 'healthy' : 'unhealthy',
          details: claudeStatus
        },
        database: {
          status: 'healthy' // Si llegamos aquí, la BD está funcionando
        },
        last_checked: new Date().toISOString()
      };

      res.json({
        success: true,
        data: servicesHealth
      });

    } catch (error) {
      logger.error('Error verificando estado de servicios:', error);
      res.status(500).json({
        success: false,
        error: 'Error verificando servicios'
      });
    }
  })
);

/**
 * Prueba de conexión con WhatsApp
 * URL: POST /api/dashboard/test/whatsapp
 */
router.post('/test/whatsapp',
  AuthMiddleware.requireRole(['admin']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const { phone_number, test_message = '🧪 Mensaje de prueba desde ChatBot Chingón' } = req.body;

      if (!phone_number) {
        return res.status(400).json({
          success: false,
          error: 'Número de teléfono requerido para la prueba'
        });
      }

      // Enviar mensaje de prueba
      const result = await WhatsAppService.sendMessage(phone_number, test_message);

      logger.info('Prueba de WhatsApp ejecutada', {
        restaurantId: req.restaurant.id,
        phoneNumber: phone_number.substring(0, 8) + '****',
        success: result.success,
        userId: req.user.id
      });

      res.json({
        success: true,
        message: 'Mensaje de prueba enviado',
        data: {
          phone_number: phone_number,
          message_sent: test_message,
          provider_result: result
        }
      });

    } catch (error) {
      logger.error('Error en prueba de WhatsApp:', error);
      res.status(500).json({
        success: false,
        error: 'Error enviando mensaje de prueba'
      });
    }
  })
);

// ============================================
// ACTIVIDAD Y LOGS
// ============================================

/**
 * Obtiene actividad reciente
 * URL: GET /api/dashboard/activity
 */
router.get('/activity',
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const { limit = 20 } = req.query;
      const limitNumber = Math.min(parseInt(limit), 100);

      // Obtener actividad reciente (combinando pedidos y conversaciones)
      const [recentOrders, recentConversations] = await Promise.all([
        OrderController.getOrders(req, { 
          query: { limit: limitNumber / 2, sort_by: 'created_at', sort_order: 'DESC' }, 
          json: () => {} 
        }),
        ConversationController.getConversations(req, { 
          query: { limit: limitNumber / 2, sort_by: 'last_interaction_at', sort_order: 'DESC' }, 
          json: () => {} 
        })
      ]);

      // Combinar y ordenar actividad
      const activity = [];

      // Agregar pedidos a la actividad
      if (recentOrders?.data) {
        recentOrders.data.forEach(order => {
          activity.push({
            type: 'order',
            id: order.id,
            title: `Pedido ${order.id.substring(0, 8)}`,
            description: `Total: $${order.total} - Estado: ${order.status}`,
            timestamp: order.created_at,
            customer_phone: order.customer_phone?.substring(0, 8) + '****'
          });
        });
      }

      // Agregar conversaciones a la actividad
      if (recentConversations?.data) {
        recentConversations.data.forEach(conv => {
          activity.push({
            type: 'conversation',
            id: conv.id,
            title: `Conversación ${conv.id.substring(0, 8)}`,
            description: `Estado: ${conv.status} - Paso: ${conv.current_step}`,
            timestamp: conv.last_interaction_at,
            customer_phone: conv.customer_phone?.substring(0, 8) + '****'
          });
        });
      }

      // Ordenar por timestamp descendente
      activity.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

      res.json({
        success: true,
        data: {
          activity: activity.slice(0, limitNumber),
          total_items: activity.length
        }
      });

    } catch (error) {
      logger.error('Error obteniendo actividad:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo actividad'
      });
    }
  })
);

module.exports = router;


================================================
File: src/routes/menu.js
================================================
const express = require('express');
const MenuController = require('../controllers/menuController');
const AuthMiddleware = require('../middleware/auth');
const { apiTenantResolver, dashboardTenantResolver } = require('../middleware/tenantResolver');

const router = express.Router();

// ============================================
// RUTAS PÚBLICAS DEL MENÚ
// ============================================

/**
 * Obtiene el menú completo de un restaurante (público)
 * URL: GET /api/menu/restaurant/:restaurantId
 */
router.get('/restaurant/:restaurantId',
  MenuController.getFullMenu
);

/**
 * Obtiene un item específico del menú (público)
 * URL: GET /api/menu/item/:itemId
 */
router.get('/item/:itemId',
  MenuController.getMenuItem
);

/**
 * Busca items en el menú de un restaurante (público)
 * URL: GET /api/menu/restaurant/:restaurantId/search
 */
router.get('/restaurant/:restaurantId/search',
  MenuController.searchMenuItems
);

/**
 * Obtiene items populares de un restaurante (público)
 * URL: GET /api/menu/restaurant/:restaurantId/popular
 */
router.get('/restaurant/:restaurantId/popular',
  MenuController.getPopularItems
);

// ============================================
// RUTAS ADMINISTRATIVAS (REQUIEREN AUTENTICACIÓN)
// ============================================

// Middleware de autenticación para rutas administrativas
router.use(AuthMiddleware.authenticateToken);

// ============================================
// GESTIÓN DE CATEGORÍAS
// ============================================

/**
 * Obtiene categorías del restaurante actual
 * URL: GET /api/menu/categories
 */
router.get('/categories',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getCategories
);

/**
 * Crea una nueva categoría
 * URL: POST /api/menu/categories
 */
router.post('/categories',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  MenuController.createCategory
);

/**
 * Actualiza una categoría
 * URL: PUT /api/menu/categories/:categoryId
 */
router.put('/categories/:categoryId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.updateCategory
);

// ============================================
// GESTIÓN DE ITEMS DEL MENÚ
// ============================================

/**
 * Obtiene el menú completo del restaurante actual
 * URL: GET /api/menu
 */
router.get('/',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getFullMenu
);

/**
 * Obtiene resumen del menú del restaurante actual
 * URL: GET /api/menu/summary
 */
router.get('/summary',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getMenuSummary
);

/**
 * Busca items en el menú del restaurante actual
 * URL: GET /api/menu/search
 */
router.get('/search',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.searchMenuItems
);

/**
 * Obtiene items populares del restaurante actual
 * URL: GET /api/menu/popular
 */
router.get('/popular',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getPopularItems
);

/**
 * Crea un nuevo item del menú
 * URL: POST /api/menu/items
 */
router.post('/items',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  MenuController.createMenuItem
);

/**
 * Obtiene un item específico del menú del restaurante actual
 * URL: GET /api/menu/items/:itemId
 */
router.get('/items/:itemId',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getMenuItem
);

/**
 * Actualiza un item del menú
 * URL: PUT /api/menu/items/:itemId
 */
router.put('/items/:itemId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.updateMenuItem
);

/**
 * Cambia disponibilidad de un item
 * URL: PATCH /api/menu/items/:itemId/availability
 */
router.patch('/items/:itemId/availability',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  MenuController.toggleItemAvailability
);

/**
 * Elimina un item del menú
 * URL: DELETE /api/menu/items/:itemId
 */
router.delete('/items/:itemId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.deleteMenuItem
);

// ============================================
// OPERACIONES EN LOTE
// ============================================

/**
 * Actualiza orden de display de items
 * URL: PUT /api/menu/items/display-order
 */
router.put('/items/display-order',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.updateDisplayOrder
);

/**
 * Actualización en lote de disponibilidad
 * URL: PATCH /api/menu/items/batch-availability
 */
router.patch('/items/batch-availability',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  MenuController.batchUpdateAvailability
);

// ============================================
// RUTAS ESPECÍFICAS POR RESTAURANTE (PARA SUPER ADMIN)
// ============================================

/**
 * Obtiene categorías de un restaurante específico
 * URL: GET /api/menu/restaurant/:restaurantId/categories
 */
router.get('/restaurant/:restaurantId/categories',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.getCategories
);

/**
 * Crea categoría en un restaurante específico
 * URL: POST /api/menu/restaurant/:restaurantId/categories
 */
router.post('/restaurant/:restaurantId/categories',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.createCategory
);

/**
 * Crea item en un restaurante específico
 * URL: POST /api/menu/restaurant/:restaurantId/items
 */
router.post('/restaurant/:restaurantId/items',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.createMenuItem
);

/**
 * Obtiene resumen del menú de un restaurante específico
 * URL: GET /api/menu/restaurant/:restaurantId/summary
 */
router.get('/restaurant/:restaurantId/summary',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.getMenuSummary
);

module.exports = router;


================================================
File: src/routes/orders.js
================================================
const express = require('express');
const OrderController = require('../controllers/orderController');
const AuthMiddleware = require('../middleware/auth');
const { dashboardTenantResolver } = require('../middleware/tenantResolver');

const router = express.Router();

// ============================================
// TODAS LAS RUTAS REQUIEREN AUTENTICACIÓN
// ============================================

router.use(AuthMiddleware.authenticateToken);

// ============================================
// RUTAS DEL RESTAURANTE ACTUAL
// ============================================

/**
 * Obtiene pedidos del restaurante actual
 * URL: GET /api/orders
 */
router.get('/',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrders
);

/**
 * Obtiene resumen de pedidos del restaurante actual
 * URL: GET /api/orders/summary
 */
router.get('/summary',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrdersSummary
);

/**
 * Obtiene pedidos activos del restaurante actual
 * URL: GET /api/orders/active
 */
router.get('/active',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getActiveOrders
);

/**
 * Busca pedidos del restaurante actual
 * URL: GET /api/orders/search
 */
router.get('/search',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.searchOrders
);

/**
 * Obtiene estadísticas de pedidos del restaurante actual
 * URL: GET /api/orders/statistics
 */
router.get('/statistics',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrderStatistics
);

/**
 * Genera reporte de ventas del restaurante actual
 * URL: GET /api/orders/reports/sales
 */
router.get('/reports/sales',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.generateSalesReport
);

/**
 * Crea un nuevo pedido manual
 * URL: POST /api/orders
 */
router.post('/',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.createOrder
);

/**
 * Actualización en lote de pedidos
 * URL: PATCH /api/orders/batch
 */
router.patch('/batch',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.batchUpdateOrders
);

// ============================================
// RUTAS DE PEDIDOS ESPECÍFICOS
// ============================================

/**
 * Obtiene un pedido específico
 * URL: GET /api/orders/:orderId
 */
router.get('/:orderId',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrderById
);

/**
 * Actualiza el estado de un pedido
 * URL: PATCH /api/orders/:orderId/status
 */
router.patch('/:orderId/status',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  OrderController.updateOrderStatus
);

/**
 * Cancela un pedido
 * URL: POST /api/orders/:orderId/cancel
 */
router.post('/:orderId/cancel',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  OrderController.cancelOrder
);

/**
 * Valida si un pedido puede ser modificado
 * URL: GET /api/orders/:orderId/validate-modification
 */
router.get('/:orderId/validate-modification',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  OrderController.validateOrderModification
);

// ============================================
// RUTAS POR CLIENTE
// ============================================

/**
 * Obtiene pedidos de un cliente específico
 * URL: GET /api/orders/customer/:customerPhone
 */
router.get('/customer/:customerPhone',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getCustomerOrders
);

// ============================================
// RUTAS ESPECÍFICAS POR RESTAURANTE (PARA SUPER ADMIN)
// ============================================

/**
 * Obtiene pedidos de un restaurante específico
 * URL: GET /api/orders/restaurant/:restaurantId
 */
router.get('/restaurant/:restaurantId',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getOrders
);

/**
 * Obtiene pedidos activos de un restaurante específico
 * URL: GET /api/orders/restaurant/:restaurantId/active
 */
router.get('/restaurant/:restaurantId/active',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getActiveOrders
);

/**
 * Obtiene estadísticas de un restaurante específico
 * URL: GET /api/orders/restaurant/:restaurantId/statistics
 */
router.get('/restaurant/:restaurantId/statistics',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getOrderStatistics
);

/**
 * Genera reporte de ventas de un restaurante específico
 * URL: GET /api/orders/restaurant/:restaurantId/reports/sales
 */
router.get('/restaurant/:restaurantId/reports/sales',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.generateSalesReport
);

/**
 * Busca pedidos en un restaurante específico
 * URL: GET /api/orders/restaurant/:restaurantId/search
 */
router.get('/restaurant/:restaurantId/search',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.searchOrders
);

/**
 * Obtiene resumen de pedidos de un restaurante específico
 * URL: GET /api/orders/restaurant/:restaurantId/summary
 */
router.get('/restaurant/:restaurantId/summary',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getOrdersSummary
);

module.exports = router;


================================================
File: src/routes/restaurants.js
================================================
const express = require('express');
const RestaurantController = require('../controllers/restaurantController');
const AuthMiddleware = require('../middleware/auth');
const { apiTenantResolver, dashboardTenantResolver } = require('../middleware/tenantResolver');

const router = express.Router();

// ============================================
// RUTAS PÚBLICAS
// ============================================

/**
 * Obtiene un restaurante por slug
 * URL: GET /api/restaurants/slug/:slug
 */
router.get('/slug/:slug',
  RestaurantController.getRestaurantBySlug
);

/**
 * Verifica disponibilidad de slug
 * URL: GET /api/restaurants/check-slug/:slug
 */
router.get('/check-slug/:slug',
  RestaurantController.checkSlugAvailability
);

// ============================================
// RUTAS ADMINISTRATIVAS (REQUIEREN AUTENTICACIÓN)
// ============================================

// Middleware de autenticación para rutas administrativas
router.use(AuthMiddleware.authenticateToken);

/**
 * Obtiene lista de restaurantes (solo super admin)
 * URL: GET /api/restaurants
 */
router.get('/',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.getAllRestaurants
);

/**
 * Crea un nuevo restaurante (solo super admin)
 * URL: POST /api/restaurants
 */
router.post('/',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.createRestaurant
);

/**
 * Obtiene un restaurante por ID (super admin o propietario)
 * URL: GET /api/restaurants/:id
 */
router.get('/:id',
  AuthMiddleware.requireRole(['super_admin', 'admin', 'manager']),
  RestaurantController.getRestaurantById
);

/**
 * Actualiza un restaurante (super admin o propietario)
 * URL: PUT /api/restaurants/:id
 */
router.put('/:id',
  AuthMiddleware.requireRole(['super_admin', 'admin']),
  RestaurantController.updateRestaurant
);

/**
 * Actualiza configuración de un restaurante
 * URL: PUT /api/restaurants/:id/settings
 */
router.put('/:id/settings',
  AuthMiddleware.requireRole(['super_admin', 'admin']),
  RestaurantController.updateRestaurantSettings
);

/**
 * Obtiene estadísticas de un restaurante
 * URL: GET /api/restaurants/:id/stats
 */
router.get('/:id/stats',
  AuthMiddleware.requireRole(['super_admin', 'admin', 'manager']),
  RestaurantController.getRestaurantStats
);

/**
 * Activa un restaurante (solo super admin)
 * URL: POST /api/restaurants/:id/activate
 */
router.post('/:id/activate',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.activateRestaurant
);

/**
 * Desactiva un restaurante (solo super admin)
 * URL: POST /api/restaurants/:id/deactivate
 */
router.post('/:id/deactivate',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.deactivateRestaurant
);

// ============================================
// RUTAS DEL RESTAURANTE ACTUAL
// ============================================

/**
 * Obtiene el restaurante actual (basado en el token/tenant)
 * URL: GET /api/restaurants/current
 */
router.get('/current',
  dashboardTenantResolver,
  RestaurantController.getCurrentRestaurant
);

/**
 * Actualiza el restaurante actual
 * URL: PUT /api/restaurants/current
 */
router.put('/current',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.updateCurrentRestaurant
);

/**
 * Obtiene estadísticas del restaurante actual
 * URL: GET /api/restaurants/current/stats
 */
router.get('/current/stats',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.getCurrentRestaurantStats
);

/**
 * Obtiene resumen del dashboard del restaurante actual
 * URL: GET /api/restaurants/current/dashboard
 */
router.get('/current/dashboard',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.getDashboardSummary
);

module.exports = router;


================================================
File: src/routes/webhook.js
================================================
const express = require('express');
const WebhookController = require('../controllers/webhookController');
const { webhookTenantResolver } = require('../middleware/tenantResolver');
const { webhookLimiter } = require('../middleware/rateLimiter');

const router = express.Router();

// ============================================
// RUTAS DE WEBHOOKS
// ============================================

// Aplicar rate limiting específico para webhooks
router.use(webhookLimiter);

// ============================================
// WEBHOOKS DE WHATSAPP
// ============================================

/**
 * Webhook genérico de WhatsApp
 * Maneja tanto Twilio como Meta WhatsApp
 * URL: /webhook/:restaurantSlug
 */
router.all('/:restaurantSlug', 
  webhookTenantResolver,
  WebhookController.handleWhatsAppWebhook
);

/**
 * Webhook específico de Twilio
 * URL: /webhook/twilio/:restaurantSlug
 */
router.post('/twilio/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.handleTwilioWebhook
);

/**
 * Webhook específico de Meta WhatsApp
 * Maneja tanto GET (verificación) como POST (mensajes)
 * URL: /webhook/meta/:restaurantSlug
 */
router.all('/meta/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.handleMetaWebhook
);

// ============================================
// WEBHOOKS DE PRUEBA Y DESARROLLO
// ============================================

/**
 * Webhook de prueba para desarrollo
 * URL: /webhook/test/:restaurantSlug
 */
router.post('/test/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.handleTestWebhook
);

// ============================================
// OPERACIONES DE GESTIÓN
// ============================================

/**
 * Reinicia una conversación específica
 * URL: POST /webhook/restart/:restaurantSlug
 */
router.post('/restart/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.restartConversation
);

/**
 * Envía mensaje manual desde el dashboard
 * URL: POST /webhook/send/:restaurantSlug
 */
router.post('/send/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.sendManualMessage
);

// ============================================
// ESTADÍSTICAS Y MONITOREO
// ============================================

/**
 * Obtiene estadísticas de webhooks
 * URL: GET /webhook/stats
 */
router.get('/stats',
  WebhookController.getWebhookStats
);

module.exports = router;


================================================
File: src/services/claudeService.js
================================================
const { getClaude3Response, buildContext } = require('../config/claude');
const logger = require('../utils/logger');
const { CONVERSATION_STEPS, DEFAULT_MESSAGES } = require('../utils/constants');
const Menu = require('../models/Menu');
const { query } = require('../config/database');

// ============================================
// SERVICIO CLAUDE AI
// ============================================

class ClaudeService {

  /**
   * Procesa un mensaje del usuario con Claude AI
   * @param {Object} params - Parámetros del procesamiento
   * @returns {Promise<Object>} Respuesta procesada
   */
  static async processMessage(params) {
    const {
      restaurant,
      conversation,
      userMessage,
      customerData = null
    } = params;

    try {
      // Preparar datos del contexto
      const contextData = await this.prepareContextData(restaurant, conversation, customerData);
      
      // Llamar a Claude
      const claudeResponse = await getClaude3Response(
        contextData,
        userMessage,
        {
          model: restaurant.claude_model,
          temperature: 0.7,
          maxTokens: 500
        }
      );

      // Analizar la respuesta para detectar intenciones
      const analysis = await this.analyzeResponse(claudeResponse.response, conversation);

      return {
        success: true,
        response: claudeResponse.response,
        analysis,
        usage: claudeResponse.usage,
        model: claudeResponse.model,
        duration: claudeResponse.duration
      };

    } catch (error) {
      logger.error('Error procesando mensaje con Claude:', error);
      
      // Retornar respuesta de fallback
      return {
        success: false,
        response: restaurant.error_message || DEFAULT_MESSAGES.ERROR,
        analysis: {
          intent: 'error',
          confidence: 0,
          next_step: conversation.current_step
        },
        error: error.message
      };
    }
  }

  /**
   * Prepara los datos de contexto para Claude
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} conversation - Conversación actual
   * @param {Object} customerData - Datos del cliente
   * @returns {Promise<Object>} Datos de contexto preparados
   */
  static async prepareContextData(restaurant, conversation, customerData = null) {
    try {
      // Obtener menú completo si no está en los datos del restaurante
      if (!restaurant.menu) {
        const menuData = await Menu.getFullMenu(restaurant.id, true);
        restaurant.menu = this.flattenMenuForContext(menuData.categories);
      }

      // Obtener reglas de negocio si no están incluidas
      if (!restaurant.business_rules) {
        const rulesResult = await query(
          'SELECT * FROM business_rules WHERE restaurant_id = $1 AND is_active = true',
          [restaurant.id],
          'get_business_rules_for_context'
        );
        restaurant.business_rules = rulesResult.rows;
      }

      // Parsear datos de la conversación
      let orderState = null;
      let conversationHistory = [];

      try {
        orderState = JSON.parse(conversation.order_data || '{}');
        conversationHistory = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversación:', e);
        orderState = { items: [], subtotal: 0, delivery_fee: 0, total: 0 };
        conversationHistory = [];
      }

      // Agregar información del cliente si está disponible
      let customerContext = '';
      if (customerData && customerData.name) {
        customerContext = `\nCLIENTE: ${customerData.name}`;
        if (customerData.total_orders > 0) {
          customerContext += ` (${customerData.total_orders} pedidos anteriores)`;
        }
        if (customerData.favorite_item) {
          customerContext += `\nItem favorito: ${customerData.favorite_item}`;
        }
      }

      return {
        restaurant: {
          ...restaurant,
          customer_context: customerContext
        },
        orderState,
        conversationHistory,
        currentStep: conversation.current_step || CONVERSATION_STEPS.GREETING
      };

    } catch (error) {
      logger.error('Error preparando contexto para Claude:', error);
      throw error;
    }
  }

  /**
   * Aplana el menú para el contexto de Claude
   * @param {Array} categories - Categorías del menú
   * @returns {Array} Menú aplanado
   */
  static flattenMenuForContext(categories) {
    const flatMenu = [];
    
    categories.forEach(category => {
      category.items.forEach(item => {
        flatMenu.push({
          ...item,
          category_name: category.name,
          category_emoji: category.emoji
        });
      });
    });

    return flatMenu;
  }

  /**
   * Analiza la respuesta de Claude para detectar intenciones
   * @param {string} response - Respuesta de Claude
   * @param {Object} conversation - Conversación actual
   * @returns {Promise<Object>} Análisis de la respuesta
   */
  static async analyzeResponse(response, conversation) {
    try {
      const analysis = {
        intent: 'chat',
        confidence: 0.5,
        next_step: conversation.current_step,
        actions: [],
        extracted_data: {}
      };

      const responseLower = response.toLowerCase();

      // Detectar intenciones comunes
      if (this.containsOrderingKeywords(responseLower)) {
        analysis.intent = 'ordering';
        analysis.confidence = 0.8;
        analysis.next_step = CONVERSATION_STEPS.ORDERING;
      }

      if (this.containsAddressKeywords(responseLower)) {
        analysis.intent = 'address_request';
        analysis.confidence = 0.9;
        analysis.next_step = CONVERSATION_STEPS.ADDRESS;
      }

      if (this.containsConfirmationKeywords(responseLower)) {
        analysis.intent = 'confirmation';
        analysis.confidence = 0.8;
        analysis.next_step = CONVERSATION_STEPS.CONFIRMING;
      }

      if (this.containsModificationKeywords(responseLower)) {
        analysis.intent = 'modify_order';
        analysis.confidence = 0.7;
        analysis.actions.push('modify_order');
      }

      // Extraer información específica
      const extractedAddress = this.extractAddressInfo(response);
      if (extractedAddress) {
        analysis.extracted_data.address = extractedAddress;
        analysis.actions.push('save_address');
      }

      const extractedItems = this.extractOrderItems(response);
      if (extractedItems.length > 0) {
        analysis.extracted_data.items = extractedItems;
        analysis.actions.push('add_items');
      }

      return analysis;

    } catch (error) {
      logger.error('Error analizando respuesta de Claude:', error);
      
      return {
        intent: 'unknown',
        confidence: 0,
        next_step: conversation.current_step,
        actions: [],
        extracted_data: {}
      };
    }
  }

  /**
   * Detecta palabras clave relacionadas con pedidos
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de pedido
   */
  static containsOrderingKeywords(text) {
    const orderKeywords = [
      'quiero', 'pedir', 'ordenar', 'llevar', 'agregar',
      'menu', 'menú', 'carta', 'disponible', 'precio',
      'cuanto cuesta', 'alitas', 'hamburguesa', 'bebida'
    ];

    return orderKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Detecta palabras clave relacionadas con dirección
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de dirección
   */
  static containsAddressKeywords(text) {
    const addressKeywords = [
      'dirección', 'direccion', 'domicilio', 'entregar',
      'calle', 'colonia', 'número', 'numero', 'referencias'
    ];

    return addressKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Detecta palabras clave de confirmación
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de confirmación
   */
  static containsConfirmationKeywords(text) {
    const confirmKeywords = [
      'confirmar', 'pedido listo', 'es todo', 'sería todo',
      'así está bien', 'perfecto', 'proceder'
    ];

    return confirmKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Detecta palabras clave de modificación
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de modificación
   */
  static containsModificationKeywords(text) {
    const modifyKeywords = [
      'cambiar', 'quitar', 'eliminar', 'modificar',
      'en lugar de', 'mejor', 'cancelar', 'ya no'
    ];

    return modifyKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Extrae información de dirección del texto
   * @param {string} text - Texto a analizar
   * @returns {Object|null} Información de dirección extraída
   */
  static extractAddressInfo(text) {
    try {
      const addressInfo = {};

      // Patrones para extraer información
      const streetPattern = /(?:calle|avenida|av\.?|blvd\.?)\s+([^,\n]+)/i;
      const numberPattern = /(?:número|numero|#|num\.?)\s*(\d+)/i;
      const neighborhoodPattern = /(?:colonia|col\.?)\s+([^,\n]+)/i;
      const referencesPattern = /(?:referencias?|entre|cerca de|enfrente de)\s+([^,\n]+)/i;

      const streetMatch = text.match(streetPattern);
      if (streetMatch) {
        addressInfo.street = streetMatch[1].trim();
      }

      const numberMatch = text.match(numberPattern);
      if (numberMatch) {
        addressInfo.number = numberMatch[1].trim();
      }

      const neighborhoodMatch = text.match(neighborhoodPattern);
      if (neighborhoodMatch) {
        addressInfo.neighborhood = neighborhoodMatch[1].trim();
      }

      const referencesMatch = text.match(referencesPattern);
      if (referencesMatch) {
        addressInfo.references = referencesMatch[1].trim();
      }

      // Retornar solo si se encontró al menos un campo
      return Object.keys(addressInfo).length > 0 ? addressInfo : null;

    } catch (error) {
      logger.error('Error extrayendo información de dirección:', error);
      return null;
    }
  }

  /**
   * Extrae items del pedido del texto
   * @param {string} text - Texto a analizar
   * @returns {Array} Items extraídos
   */
  static extractOrderItems(text) {
    try {
      const items = [];
      const textLower = text.toLowerCase();

      // Patrones comunes para items
      const itemPatterns = [
        /(\d+)\s*(?:media orden|orden|pieza|piezas|pedazo|pedazos)\s+(?:de\s+)?([^,\n]+)/gi,
        /(?:quiero|pedir|llevar)\s+(?:una|un|dos|tres|cuatro|cinco)?\s*([^,\n]+)/gi,
        /(\d+)\s*([^,\n]*(?:alitas|hamburguesa|hotdog|bebida|refresco)[^,\n]*)/gi
      ];

      itemPatterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(textLower)) !== null) {
          const quantity = match[1] ? parseInt(match[1]) : 1;
          const itemName = (match[2] || match[1]).trim();
          
          if (itemName && itemName.length > 2) {
            items.push({
              name: itemName,
              quantity: quantity || 1,
              confidence: 0.6
            });
          }
        }
      });

      return items;

    } catch (error) {
      logger.error('Error extrayendo items del pedido:', error);
      return [];
    }
  }

  /**
   * Genera respuesta de bienvenida personalizada
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} customerData - Datos del cliente
   * @returns {Promise<string>} Mensaje de bienvenida
   */
  static async generateWelcomeMessage(restaurant, customerData = null) {
    try {
      let welcomeMessage = restaurant.welcome_message || DEFAULT_MESSAGES.WELCOME;

      // Personalizar si es cliente recurrente
      if (customerData && customerData.total_orders > 0) {
        const personalizedMessages = [
          `¡Hola de nuevo${customerData.name ? `, ${customerData.name}` : ''}! 👋 Es un placer verte otra vez.`,
          `¡Bienvenido de vuelta${customerData.name ? `, ${customerData.name}` : ''}! 😊 ¿Lo de siempre o algo diferente hoy?`,
          `¡Hey${customerData.name ? `, ${customerData.name}` : ''}! 🎉 Gracias por elegirnos nuevamente.`
        ];

        welcomeMessage = personalizedMessages[Math.floor(Math.random() * personalizedMessages.length)];

        // Agregar sugerencia del item favorito
        if (customerData.favorite_item) {
          welcomeMessage += `\n\n¿Te gustaría tu favorito: ${customerData.favorite_item}? 🍗`;
        }
      }

      return welcomeMessage;

    } catch (error) {
      logger.error('Error generando mensaje de bienvenida:', error);
      return restaurant.welcome_message || DEFAULT_MESSAGES.WELCOME;
    }
  }

  /**
   * Valida la respuesta de Claude antes de enviarla
   * @param {string} response - Respuesta a validar
   * @param {Object} context - Contexto de la conversación
   * @returns {Object} Respuesta validada
   */
  static validateResponse(response, context = {}) {
    try {
      let validatedResponse = response;
      const issues = [];

      // Verificar longitud
      if (response.length > 1000) {
        validatedResponse = response.substring(0, 997) + '...';
        issues.push('response_truncated');
      }

      // Verificar que no contenga información sensible
      const sensitivePatterns = [
        /api[_-]?key/i,
        /password/i,
        /secret/i,
        /token/i
      ];

      sensitivePatterns.forEach(pattern => {
        if (pattern.test(response)) {
          issues.push('sensitive_data_detected');
        }
      });

      // Verificar que la respuesta sea apropiada
      if (response.length < 10) {
        issues.push('response_too_short');
      }

      return {
        response: validatedResponse,
        isValid: issues.length === 0,
        issues
      };

    } catch (error) {
      logger.error('Error validando respuesta de Claude:', error);
      
      return {
        response: DEFAULT_MESSAGES.ERROR,
        isValid: false,
        issues: ['validation_error']
      };
    }
  }

  /**
   * Genera resumen de conversación para logging
   * @param {Object} conversation - Conversación a resumir
   * @returns {Promise<string>} Resumen generado
   */
  static async generateConversationSummary(conversation) {
    try {
      let aiContext = [];
      try {
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        return 'Error parseando contexto de conversación';
      }

      if (aiContext.length === 0) {
        return 'Conversación sin mensajes';
      }

      const messageCount = aiContext.length;
      const userMessages = aiContext.filter(msg => msg.role === 'user').length;
      const assistantMessages = aiContext.filter(msg => msg.role === 'assistant').length;

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        orderData = {};
      }

      const summary = [
        `Conversación con ${messageCount} mensajes (${userMessages} del cliente, ${assistantMessages} del asistente)`,
        `Estado: ${conversation.status}`,
        `Paso actual: ${conversation.current_step}`
      ];

      if (orderData.items && orderData.items.length > 0) {
        summary.push(`Pedido: ${orderData.items.length} items, total: $${orderData.total || 0}`);
      }

      return summary.join(' | ');

    } catch (error) {
      logger.error('Error generando resumen de conversación:', error);
      return 'Error generando resumen';
    }
  }

  /**
   * Obtiene estadísticas de uso de Claude
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas de uso
   */
  static async getUsageStats(restaurantId, dateRange = {}) {
    try {
      // Esta función requeriría una tabla de logs de Claude
      // Por ahora retornamos un placeholder
      return {
        total_requests: 0,
        total_tokens: 0,
        avg_response_time: 0,
        error_rate: 0,
        cost_estimate: 0
      };

    } catch (error) {
      logger.error('Error obteniendo estadísticas de Claude:', error);
      throw error;
    }
  }
}

module.exports = ClaudeService;


================================================
File: src/services/conversationService.js
================================================
const Conversation = require('../models/Conversation');
const Customer = require('../models/Customer');
const Menu = require('../models/Menu');
const ClaudeService = require('./claudeService');
const WhatsAppService = require('./whatsappService');
const ValidationService = require('./validationService');
const logger = require('../utils/logger');
const { 
  CONVERSATION_STATUS, 
  CONVERSATION_STEPS, 
  TIME_LIMITS,
  DEFAULT_MESSAGES 
} = require('../utils/constants');
const { ValidationError, DatabaseError } = require('../middleware/errorHandler');

// ============================================
// SERVICIO DE CONVERSACIONES
// ============================================

class ConversationService {

  /**
   * Procesa un mensaje entrante y genera respuesta
   * @param {Object} params - Parámetros del procesamiento
   * @returns {Promise<Object>} Resultado del procesamiento
   */
  static async processIncomingMessage(params) {
    const {
      restaurant,
      customerPhone,
      messageText,
      messageData = null
    } = params;

    try {
      // 1. Obtener o crear conversación
      const conversation = await Conversation.getOrCreate(restaurant.id, customerPhone);
      
      // 2. Obtener datos del cliente
      const customer = await Customer.findOrCreate(customerPhone);
      
      // 3. Validar mensaje
      const validationResult = ValidationService.validateIncomingMessage(messageText, conversation);
      if (!validationResult.isValid) {
        return await this.handleInvalidMessage(conversation, restaurant, validationResult.error);
      }

      // 4. Agregar mensaje del usuario al contexto
      await Conversation.addToContext(conversation.id, 'user', messageText);

      // 5. Verificar si es mensaje multimedia
      if (messageData?.mediaUrl) {
        const mediaResult = await WhatsAppService.processMediaMessage(messageData);
        if (mediaResult && mediaResult.message) {
          return await this.sendResponse(customerPhone, mediaResult.message, restaurant);
        }
      }

      // 6. Procesar con Claude AI
      const claudeResult = await ClaudeService.processMessage({
        restaurant,
        conversation,
        userMessage: messageText,
        customerData: customer
      });

      // 7. Procesar acciones detectadas por la IA
      const updatedConversation = await this.processDetectedActions(
        conversation,
        claudeResult.analysis,
        messageText,
        restaurant
      );

      // 8. Agregar respuesta de la IA al contexto
      await Conversation.addToContext(updatedConversation.id, 'assistant', claudeResult.response);

      // 9. Enviar respuesta al cliente
      const sendResult = await this.sendResponse(customerPhone, claudeResult.response, restaurant);

      return {
        success: true,
        conversation: updatedConversation,
        claudeResult,
        sendResult,
        actions_processed: claudeResult.analysis.actions || []
      };

    } catch (error) {
      logger.error('Error procesando mensaje entrante:', error);
      
      // Enviar mensaje de error al cliente
      try {
        await this.sendResponse(
          customerPhone, 
          restaurant.error_message || DEFAULT_MESSAGES.ERROR, 
          restaurant
        );
      } catch (sendError) {
        logger.error('Error enviando mensaje de error:', sendError);
      }

      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Procesa las acciones detectadas por Claude AI
   * @param {Object} conversation - Conversación actual
   * @param {Object} analysis - Análisis de Claude
   * @param {string} messageText - Texto del mensaje
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async processDetectedActions(conversation, analysis, messageText, restaurant) {
    try {
      let updatedConversation = conversation;
      const actions = analysis.actions || [];

      for (const action of actions) {
        switch (action) {
          case 'add_items':
            updatedConversation = await this.processAddItems(
              updatedConversation, 
              analysis.extracted_data.items || [],
              restaurant
            );
            break;

          case 'modify_order':
            updatedConversation = await this.processModifyOrder(
              updatedConversation,
              messageText,
              restaurant
            );
            break;

          case 'save_address':
            updatedConversation = await this.processSaveAddress(
              updatedConversation,
              analysis.extracted_data.address
            );
            break;

          case 'confirm_order':
            updatedConversation = await this.processConfirmOrder(
              updatedConversation,
              restaurant
            );
            break;

          default:
            logger.debug('Acción no reconocida:', action);
        }
      }

      // Actualizar paso de la conversación si cambió
      if (analysis.next_step && analysis.next_step !== conversation.current_step) {
        updatedConversation = await Conversation.update(updatedConversation.id, {
          current_step: analysis.next_step
        });
      }

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando acciones detectadas:', error);
      return conversation; // Retornar conversación original si hay error
    }
  }

  /**
   * Procesa la adición de items al pedido
   * @param {Object} conversation - Conversación actual
   * @param {Array} detectedItems - Items detectados por la IA
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async processAddItems(conversation, detectedItems, restaurant) {
    try {
      if (!detectedItems || detectedItems.length === 0) {
        return conversation;
      }

      // Obtener menú del restaurante
      const menuData = await Menu.getFullMenu(restaurant.id, true);
      const flatMenu = this.flattenMenuItems(menuData.categories);

      let updatedConversation = conversation;

      for (const detectedItem of detectedItems) {
        // Buscar item en el menú por nombre
        const menuItem = this.findMenuItemByName(detectedItem.name, flatMenu);
        
        if (menuItem) {
          const orderItem = {
            menu_item_id: menuItem.id,
            name: menuItem.name,
            base_price: menuItem.price,
            quantity: detectedItem.quantity || 1,
            customizations: [],
            customizations_cost: 0,
            notes: null
          };

          // Calcular total del item
          orderItem.item_total = orderItem.base_price * orderItem.quantity;

          // Agregar item al pedido
          updatedConversation = await Conversation.addItemToOrder(updatedConversation.id, orderItem);

          logger.info('Item agregado al pedido', {
            conversationId: conversation.id,
            itemName: menuItem.name,
            quantity: orderItem.quantity,
            total: orderItem.item_total
          });
        } else {
          logger.warn('Item no encontrado en menú', {
            conversationId: conversation.id,
            searchedItem: detectedItem.name
          });
        }
      }

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando adición de items:', error);
      return conversation;
    }
  }

  /**
   * Procesa modificaciones al pedido
   * @param {Object} conversation - Conversación actual
   * @param {string} messageText - Texto del mensaje
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async processModifyOrder(conversation, messageText, restaurant) {
    try {
      const messageLower = messageText.toLowerCase();
      
      // Detectar tipo de modificación
      if (messageLower.includes('quitar') || messageLower.includes('eliminar') || messageLower.includes('cancelar')) {
        return await this.processRemoveItems(conversation, messageText);
      }

      if (messageLower.includes('cambiar') || messageLower.includes('modificar')) {
        return await this.processChangeItems(conversation, messageText, restaurant);
      }

      return conversation;

    } catch (error) {
      logger.error('Error procesando modificación de pedido:', error);
      return conversation;
    }
  }

  /**
   * Procesa la eliminación de items del pedido
   * @param {Object} conversation - Conversación actual
   * @param {string} messageText - Texto del mensaje
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async processRemoveItems(conversation, messageText) {
    try {
      let orderData = JSON.parse(conversation.order_data || '{}');
      
      if (!orderData.items || orderData.items.length === 0) {
        return conversation;
      }

      // Buscar índices de items a remover
      const itemsToRemove = [];
      const messageLower = messageText.toLowerCase();

      orderData.items.forEach((item, index) => {
        if (messageLower.includes(item.name.toLowerCase())) {
          itemsToRemove.push(index);
        }
      });

      // Si no se encuentra específicamente, y hay indicación numérica
      const numberMatch = messageText.match(/(\d+)/);
      if (itemsToRemove.length === 0 && numberMatch) {
        const itemIndex = parseInt(numberMatch[1]) - 1; // Convertir a índice base 0
        if (itemIndex >= 0 && itemIndex < orderData.items.length) {
          itemsToRemove.push(itemIndex);
        }
      }

      // Remover items (en orden descendente para no afectar índices)
      let updatedConversation = conversation;
      for (const index of itemsToRemove.sort((a, b) => b - a)) {
        updatedConversation = await Conversation.removeItemFromOrder(updatedConversation.id, index);
      }

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando eliminación de items:', error);
      return conversation;
    }
  }

  /**
   * Procesa el guardado de dirección
   * @param {Object} conversation - Conversación actual
   * @param {Object} addressData - Datos de dirección extraídos
   * @returns {Promise<Object>} Conversación actualizada
   */
  static async processSaveAddress(conversation, addressData) {
    try {
      if (!addressData || Object.keys(addressData).length === 0) {
        return conversation;
      }

      let orderData = JSON.parse(conversation.order_data || '{}');
      
      if (!orderData.delivery_address) {
        orderData.delivery_address = {};
      }

      // Fusionar datos de dirección
      Object.assign(orderData.delivery_address, addressData);

      const updatedConversation = await Conversation.updateOrderData(conversation.id, orderData);

      logger.info('Dirección guardada en pedido', {
        conversationId: conversation.id,
        addressFields: Object.keys(addressData)
      });

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando guardado de dirección:', error);
      return conversation;
    }
  }

  /**
   * Maneja mensajes inválidos
   * @param {Object} conversation - Conversación actual
   * @param {Object} restaurant - Datos del restaurante
   * @param {string} errorMessage - Mensaje de error
   * @returns {Promise<Object>} Resultado del manejo
   */
  static async handleInvalidMessage(conversation, restaurant, errorMessage) {
    try {
      const response = `${DEFAULT_MESSAGES.INVALID_INPUT}\n\n${errorMessage}`;
      
      const sendResult = await this.sendResponse(
        conversation.customer_phone, 
        response, 
        restaurant
      );

      return {
        success: false,
        error: errorMessage,
        sendResult
      };

    } catch (error) {
      logger.error('Error manejando mensaje inválido:', error);
      throw error;
    }
  }

  /**
   * Envía respuesta al cliente
   * @param {string} customerPhone - Teléfono del cliente
   * @param {string} message - Mensaje a enviar
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Resultado del envío
   */
  static async sendResponse(customerPhone, message, restaurant) {
    try {
      return await WhatsAppService.sendMessageWithRetry(
        customerPhone,
        message,
        { 
          addEmojis: true,
          restaurantName: restaurant.name 
        },
        2 // máximo 2 reintentos
      );

    } catch (error) {
      logger.error('Error enviando respuesta:', error);
      throw error;
    }
  }

  /**
   * Inicia una nueva conversación con mensaje de bienvenida
   * @param {Object} restaurant - Datos del restaurante
   * @param {string} customerPhone - Teléfono del cliente
   * @returns {Promise<Object>} Resultado de la iniciación
   */
  static async startConversation(restaurant, customerPhone) {
    try {
      // Obtener o crear cliente
      const customer = await Customer.findOrCreate(customerPhone);
      
      // Crear nueva conversación
      const conversation = await Conversation.getOrCreate(restaurant.id, customerPhone);
      
      // Generar mensaje de bienvenida personalizado
      const welcomeMessage = await ClaudeService.generateWelcomeMessage(restaurant, customer);
      
      // Obtener menú para incluir en bienvenida si es cliente nuevo
      let fullMessage = welcomeMessage;
      
      if (customer.total_orders === 0) {
        const menuData = await Menu.getFullMenu(restaurant.id, true);
        const menuMessage = WhatsAppService.generateMenuMessage(menuData.categories, restaurant);
        fullMessage = `${welcomeMessage}\n\n${menuMessage}`;
      }

      // Agregar mensaje de bienvenida al contexto
      await Conversation.addToContext(conversation.id, 'assistant', fullMessage);
      
      // Enviar mensaje
      const sendResult = await this.sendResponse(customerPhone, fullMessage, restaurant);

      return {
        success: true,
        conversation,
        customer,
        sendResult
      };

    } catch (error) {
      logger.error('Error iniciando conversación:', error);
      throw error;
    }
  }

  /**
   * Limpia conversaciones inactivas
   * @param {number} maxInactiveHours - Horas máximas de inactividad
   * @returns {Promise<number>} Número de conversaciones limpiadas
   */
  static async cleanupInactiveConversations(maxInactiveHours = 2) {
    try {
      const cleanedCount = await Conversation.cleanupInactive(maxInactiveHours);
      
      if (cleanedCount > 0) {
        logger.info('Conversaciones inactivas limpiadas', {
          count: cleanedCount,
          maxInactiveHours
        });
      }

      return cleanedCount;

    } catch (error) {
      logger.error('Error limpiando conversaciones inactivas:', error);
      throw error;
    }
  }

  /**
   * Obtiene el estado actual de una conversación
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Teléfono del cliente
   * @returns {Promise<Object|null>} Estado de la conversación
   */
  static async getConversationStatus(restaurantId, customerPhone) {
    try {
      const conversation = await Conversation.getActive(restaurantId, customerPhone);
      
      if (!conversation) {
        return null;
      }

      let orderData = {};
      let aiContext = [];

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversación para status:', e);
      }

      return {
        id: conversation.id,
        status: conversation.status,
        current_step: conversation.current_step,
        last_interaction: conversation.last_interaction_at,
        items_count: orderData.items ? orderData.items.length : 0,
        total: orderData.total || 0,
        messages_count: aiContext.length,
        created_at: conversation.created_at
      };

    } catch (error) {
      logger.error('Error obteniendo estado de conversación:', error);
      throw error;
    }
  }

  /**
   * Reinicia una conversación abandonada
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Teléfono del cliente
   * @returns {Promise<Object>} Nueva conversación iniciada
   */
  static async restartConversation(restaurantId, customerPhone) {
    try {
      // Marcar conversación actual como abandonada si existe
      const existingConversation = await Conversation.getActive(restaurantId, customerPhone);
      if (existingConversation) {
        await Conversation.abandon(existingConversation.id);
      }

      // Obtener datos del restaurante
      const Restaurant = require('../models/Restaurant');
      const restaurant = await Restaurant.findById(restaurantId);
      
      if (!restaurant) {
        throw new ValidationError('Restaurante no encontrado');
      }

      // Iniciar nueva conversación
      return await this.startConversation(restaurant, customerPhone);

    } catch (error) {
      logger.error('Error reiniciando conversación:', error);
      throw error;
    }
  }

  /**
   * Obtiene estadísticas de conversaciones
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas
   */
  static async getConversationStats(restaurantId, dateRange = {}) {
    try {
      const stats = await Conversation.getStats(restaurantId, dateRange);
      
      // Agregar métricas adicionales
      const additionalStats = await this.calculateAdditionalStats(restaurantId, dateRange);
      
      return {
        ...stats,
        ...additionalStats
      };

    } catch (error) {
      logger.error('Error obteniendo estadísticas de conversaciones:', error);
      throw error;
    }
  }

  /**
   * Calcula estadísticas adicionales
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas adicionales
   */
  static async calculateAdditionalStats(restaurantId, dateRange) {
    try {
      // Aquí se podrían calcular más métricas específicas
      return {
        peak_hours: [],
        avg_items_per_order: 0,
        most_common_step: CONVERSATION_STEPS.GREETING,
        customer_satisfaction: 0
      };

    } catch (error) {
      logger.error('Error calculando estadísticas adicionales:', error);
      return {};
    }
  }

  // ============================================
  // MÉTODOS AUXILIARES
  // ============================================

  /**
   * Aplana los items del menú para búsqueda
   * @param {Array} categories - Categorías del menú
   * @returns {Array} Items aplanados
   */
  static flattenMenuItems(categories) {
    const flatItems = [];
    
    categories.forEach(category => {
      category.items.forEach(item => {
        flatItems.push({
          ...item,
          category_name: category.name
        });
      });
    });

    return flatItems;
  }

  /**
   * Busca un item del menú por nombre
   * @param {string} searchName - Nombre a buscar
   * @param {Array} menuItems - Items del menú
   * @returns {Object|null} Item encontrado
   */
  static findMenuItemByName(searchName, menuItems) {
    const searchLower = searchName.toLowerCase();
    
    // Búsqueda exacta primero
    let found = menuItems.find(item => 
      item.name.toLowerCase() === searchLower
    );

    // Búsqueda parcial si no se encuentra exacta
    if (!found) {
      found = menuItems.find(item => 
        item.name.toLowerCase().includes(searchLower) ||
        searchLower.includes(item.name.toLowerCase())
      );
    }

    // Búsqueda por palabras clave
    if (!found) {
      const keywords = searchLower.split(' ');
      found = menuItems.find(item => {
        const itemWords = item.name.toLowerCase().split(' ');
        return keywords.some(keyword => 
          itemWords.some(word => word.includes(keyword))
        );
      });
    }

    return found || null;
  }

  /**
   * Valida si una conversación puede proceder al siguiente paso
   * @param {Object} conversation - Conversación a validar
   * @param {string} nextStep - Siguiente paso propuesto
   * @returns {boolean} True si puede proceder
   */
  static canProceedToStep(conversation, nextStep) {
    try {
      const currentStep = conversation.current_step;
      let orderData = {};

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        orderData = { items: [] };
      }

      switch (nextStep) {
        case CONVERSATION_STEPS.ORDERING:
          return true; // Siempre se puede empezar a ordenar

        case CONVERSATION_STEPS.ADDRESS:
          return orderData.items && orderData.items.length > 0;

        case CONVERSATION_STEPS.CONFIRMING:
          return orderData.items && 
                 orderData.items.length > 0 && 
                 orderData.delivery_address &&
                 orderData.delivery_address.street &&
                 orderData.delivery_address.number &&
                 orderData.delivery_address.neighborhood;

        case CONVERSATION_STEPS.COMPLETED:
          return currentStep === CONVERSATION_STEPS.CONFIRMING;

        default:
          return true;
      }

    } catch (error) {
      logger.error('Error validando paso de conversación:', error);
      return false;
    }
  }
}

module.exports = ConversationService;


================================================
File: src/services/orderService.js
================================================
const Order = require('../models/Order');
const Customer = require('../models/Customer');
const Conversation = require('../models/Conversation');
const WhatsAppService = require('./whatsappService');
const ValidationService = require('./validationService');
const logger = require('../utils/logger');
const { 
  ORDER_STATUS, 
  CONVERSATION_STATUS,
  DEFAULT_MESSAGES,
  BUSINESS_CONFIG 
} = require('../utils/constants');
const { ValidationError, DatabaseError } = require('../middleware/errorHandler');

// ============================================
// SERVICIO DE PEDIDOS
// ============================================

class OrderService {

  /**
   * Crea un pedido desde una conversación
   * @param {Object} conversation - Conversación con el pedido
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Pedido creado
   */
  static async createFromConversation(conversation, restaurant) {
    try {
      // Validar conversación
      const validationResult = ValidationService.validateOrderFromConversation(conversation);
      if (!validationResult.isValid) {
        throw new ValidationError(validationResult.error);
      }

      // Parsear datos del pedido
      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        throw new ValidationError('Error parseando datos del pedido');
      }

      // Obtener o crear cliente
      const customer = await Customer.findOrCreate(conversation.customer_phone);

      // Calcular tiempo estimado de entrega
      const estimatedTime = await Order.calculateDeliveryTime(
        restaurant.id,
        orderData.delivery_address?.neighborhood
      );

      // Preparar datos del pedido
      const orderPayload = {
        restaurant_id: restaurant.id,
        customer_id: customer.id,
        conversation_id: conversation.id,
        customer_phone: conversation.customer_phone,
        customer_name: customer.name,
        delivery_street: orderData.delivery_address.street,
        delivery_number: orderData.delivery_address.number,
        delivery_neighborhood: orderData.delivery_address.neighborhood,
        delivery_references: orderData.delivery_address.references,
        delivery_postal_code: orderData.delivery_address.postal_code,
        items: orderData.items || [],
        subtotal: orderData.subtotal || 0,
        delivery_fee: this.calculateDeliveryFee(restaurant, orderData),
        total: (orderData.subtotal || 0) + this.calculateDeliveryFee(restaurant, orderData),
        estimated_delivery_time: estimatedTime,
        special_instructions: orderData.special_instructions
      };

      // Crear pedido
      const order = await Order.create(orderPayload);

      // Marcar conversación como completada
      await Conversation.complete(conversation.id, order.id);

      // Actualizar estadísticas del cliente
      await Customer.updateOrderStats(customer.id, order.total);

      // Enviar confirmación al cliente
      await this.sendOrderConfirmation(order, restaurant, customer);

      // Notificar al restaurante si está configurado
      await this.notifyRestaurant(order, restaurant);

      logger.info('Pedido creado exitosamente', {
        orderId: order.id,
        restaurantId: restaurant.id,
        customerPhone: customer.phone.substring(0, 8) + '****',
        total: order.total,
        itemsCount: orderPayload.items.length
      });

      return order;

    } catch (error) {
      logger.error('Error creando pedido desde conversación:', error);
      throw error;
    }
  }

  /**
   * Actualiza el estado de un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} newStatus - Nuevo estado
   * @param {Object} options - Opciones adicionales
   * @returns {Promise<Object>} Pedido actualizado
   */
  static async updateOrderStatus(orderId, newStatus, options = {}) {
    try {
      const { 
        internal_notes = null,
        estimated_delivery_time = null,
        notify_customer = true,
        restaurant = null
      } = options;

      // Actualizar estado en base de datos
      const updatedOrder = await Order.updateStatus(orderId, newStatus, {
        internal_notes,
        estimated_delivery_time
      });

      // Obtener datos completos del pedido
      const fullOrder = await Order.findById(orderId);

      // Notificar al cliente si está habilitado
      if (notify_customer && fullOrder) {
        await this.notifyCustomerStatusChange(fullOrder, newStatus);
      }

      // Log del cambio de estado
      logger.info('Estado de pedido actualizado', {
        orderId,
        newStatus,
        previousStatus: updatedOrder.status,
        notifyCustomer: notify_customer
      });

      return fullOrder;

    } catch (error) {
      logger.error('Error actualizando estado de pedido:', error);
      throw error;
    }
  }

  /**
   * Cancela un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} reason - Razón de cancelación
   * @param {Object} options - Opciones adicionales
   * @returns {Promise<Object>} Pedido cancelado
   */
  static async cancelOrder(orderId, reason, options = {}) {
    try {
      const { notify_customer = true, cancelled_by = 'restaurant' } = options;

      // Cancelar pedido
      const cancelledOrder = await Order.cancel(orderId, reason);

      // Obtener datos completos
      const fullOrder = await Order.findById(orderId);

      // Notificar al cliente
      if (notify_customer && fullOrder) {
        await this.notifyCustomerCancellation(fullOrder, reason, cancelled_by);
      }

      logger.info('Pedido cancelado', {
        orderId,
        reason,
        cancelledBy: cancelled_by
      });

      return fullOrder;

    } catch (error) {
      logger.error('Error cancelando pedido:', error);
      throw error;
    }
  }

  /**
   * Calcula el costo de envío
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} orderData - Datos del pedido
   * @returns {number} Costo de envío
   */
  static calculateDeliveryFee(restaurant, orderData) {
    try {
      let deliveryFee = restaurant.delivery_fee || 0;

      // Verificar si hay costo extra por zona
      const neighborhood = orderData.delivery_address?.neighborhood;
      
      // Aquí se podría consultar la tabla delivery_zones
      // Por ahora usamos el fee base del restaurante

      // Envío gratis si supera el mínimo (si está configurado)
      if (restaurant.free_delivery_minimum && 
          orderData.subtotal >= restaurant.free_delivery_minimum) {
        deliveryFee = 0;
      }

      return deliveryFee;

    } catch (error) {
      logger.error('Error calculando costo de envío:', error);
      return restaurant.delivery_fee || 0;
    }
  }

  /**
   * Envía confirmación de pedido al cliente
   * @param {Object} order - Datos del pedido
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} customer - Datos del cliente
   * @returns {Promise<void>}
   */
  static async sendOrderConfirmation(order, restaurant, customer) {
    try {
      // Preparar datos para el mensaje
      const orderData = {
        items: [],
        subtotal: order.subtotal,
        delivery_fee: order.delivery_fee,
        total: order.total,
        estimated_delivery_time: order.estimated_delivery_time,
        delivery_address: {
          street: order.delivery_street,
          number: order.delivery_number,
          neighborhood: order.delivery_neighborhood,
          references: order.delivery_references
        }
      };

      // Obtener items del pedido
      const fullOrder = await Order.findById(order.id);
      if (fullOrder && fullOrder.items) {
        orderData.items = fullOrder.items;
      }

      // Generar mensaje de confirmación
      const confirmationMessage = WhatsAppService.generateOrderConfirmation(orderData, restaurant);

      // Enviar mensaje
      await WhatsAppService.sendMessage(order.customer_phone, confirmationMessage);

      logger.info('Confirmación de pedido enviada', {
        orderId: order.id,
        customerPhone: order.customer_phone.substring(0, 8) + '****'
      });

    } catch (error) {
      logger.error('Error enviando confirmación de pedido:', error);
      // No lanzar error para no afectar la creación del pedido
    }
  }

  /**
   * Notifica cambio de estado al cliente
   * @param {Object} order - Datos del pedido
   * @param {string} newStatus - Nuevo estado
   * @returns {Promise<void>}
   */
  static async notifyCustomerStatusChange(order, newStatus) {
    try {
      const statusMessages = {
        [ORDER_STATUS.CONFIRMED]: `✅ Tu pedido ha sido confirmado y está siendo preparado. Tiempo estimado: ${order.estimated_delivery_time || 30} minutos.`,
        [ORDER_STATUS.PREPARING]: `👨‍🍳 Tu pedido está siendo preparado con mucho cariño. ¡Ya casi está listo!`,
        [ORDER_STATUS.READY]: `🛵 ¡Tu pedido está listo! El repartidor saldrá en breve.`,
        [ORDER_STATUS.OUT_FOR_DELIVERY]: `🚗 ¡Tu pedido está en camino! El repartidor llegará pronto.`,
        [ORDER_STATUS.DELIVERED]: `✅ ¡Pedido entregado! Gracias por tu preferencia. ¡Esperamos verte pronto! 🙏`
      };

      const message = statusMessages[newStatus];
      
      if (message) {
        await WhatsAppService.sendMessage(order.customer_phone, message);
        
        logger.info('Notificación de estado enviada', {
          orderId: order.id,
          newStatus,
          customerPhone: order.customer_phone.substring(0, 8) + '****'
        });
      }

    } catch (error) {
      logger.error('Error notificando cambio de estado:', error);
      // No lanzar error para no afectar la actualización
    }
  }

  /**
   * Notifica cancelación al cliente
   * @param {Object} order - Datos del pedido
   * @param {string} reason - Razón de cancelación
   * @param {string} cancelledBy - Quién canceló
   * @returns {Promise<void>}
   */
  static async notifyCustomerCancellation(order, reason, cancelledBy) {
    try {
      let message = `❌ Lamentamos informarte que tu pedido ha sido cancelado.`;
      
      if (reason) {
        message += `\n\nMotivo: ${reason}`;
      }

      if (cancelledBy === 'restaurant') {
        message += `\n\nNos disculpamos por las molestias. Te invitamos a realizar un nuevo pedido cuando gustes. 🙏`;
      }

      message += `\n\n¿Hay algo más en lo que podamos ayudarte?`;

      await WhatsAppService.sendMessage(order.customer_phone, message);

      logger.info('Notificación de cancelación enviada', {
        orderId: order.id,
        reason,
        cancelledBy,
        customerPhone: order.customer_phone.substring(0, 8) + '****'
      });

    } catch (error) {
      logger.error('Error notificando cancelación:', error);
      // No lanzar error para no afectar la cancelación
    }
  }

  /**
   * Notifica al restaurante sobre nuevo pedido
   * @param {Object} order - Datos del pedido
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<void>}
   */
  static async notifyRestaurant(order, restaurant) {
    try {
      // Notificación por WhatsApp si está configurado
      if (restaurant.notification_phone) {
        const message = this.generateRestaurantNotification(order);
        await WhatsAppService.sendMessage(restaurant.notification_phone, message);
      }

      // Notificación por email (se implementaría en el futuro)
      if (restaurant.notification_email) {
        // TODO: Implementar notificación por email
        logger.info('Email notification would be sent to:', restaurant.notification_email);
      }

      logger.info('Restaurante notificado sobre nuevo pedido', {
        orderId: order.id,
        restaurantId: restaurant.id,
        notificationMethods: {
          whatsapp: !!restaurant.notification_phone,
          email: !!restaurant.notification_email
        }
      });

    } catch (error) {
      logger.error('Error notificando al restaurante:', error);
      // No lanzar error para no afectar la creación del pedido
    }
  }

  /**
   * Genera mensaje de notificación para el restaurante
   * @param {Object} order - Datos del pedido
   * @returns {string} Mensaje de notificación
   */
  static generateRestaurantNotification(order) {
    try {
      let message = `🔔 *NUEVO PEDIDO*\n\n`;
      message += `*ID:* ${order.id.substring(0, 8)}\n`;
      message += `*Cliente:* ${order.customer_phone}\n`;
      
      if (order.customer_name) {
        message += `*Nombre:* ${order.customer_name}\n`;
      }

      message += `*Total:* $${order.total}\n`;
      message += `*Dirección:* ${order.delivery_street} ${order.delivery_number}, ${order.delivery_neighborhood}\n`;
      
      if (order.delivery_references) {
        message += `*Referencias:* ${order.delivery_references}\n`;
      }

      if (order.special_instructions) {
        message += `*Instrucciones:* ${order.special_instructions}\n`;
      }

      message += `\n*Items:*\n`;
      
      // Si tenemos los items detallados
      if (order.items && order.items.length > 0) {
        order.items.forEach((item, index) => {
          message += `${index + 1}. ${item.item_name} (${item.quantity}x)\n`;
          
          if (item.customizations && item.customizations.length > 0) {
            const customizations = JSON.parse(item.customizations);
            customizations.forEach(custom => {
              message += `   • ${custom.name}\n`;
            });
          }
        });
      }

      message += `\n⏰ Tiempo estimado: ${order.estimated_delivery_time || 30} min`;
      message += `\n📅 ${new Date(order.created_at).toLocaleString('es-MX')}`;

      return message;

    } catch (error) {
      logger.error('Error generando notificación para restaurante:', error);
      return `🔔 Nuevo pedido recibido. ID: ${order.id.substring(0, 8)}, Total: $${order.total}`;
    }
  }

  /**
   * Obtiene pedidos activos de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @returns {Promise<Array>} Pedidos activos
   */
  static async getActiveOrders(restaurantId) {
    try {
      const activeOrders = await Order.getActiveOrders(restaurantId);
      
      // Agregar tiempo transcurrido y alertas
      const ordersWithAlerts = activeOrders.map(order => {
        const minutesSinceOrder = parseFloat(order.minutes_since_order || 0);
        const estimatedTime = order.estimated_delivery_time || 30;
        
        return {
          ...order,
          is_delayed: minutesSinceOrder > estimatedTime + 10, // 10 minutos de gracia
          is_urgent: minutesSinceOrder > estimatedTime - 5,   // Falta poco para el tiempo estimado
          minutes_since_order: Math.round(minutesSinceOrder)
        };
      });

      return ordersWithAlerts;

    } catch (error) {
      logger.error('Error obteniendo pedidos activos:', error);
      throw error;
    }
  }

  /**
   * Obtiene estadísticas de pedidos
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas detalladas
   */
  static async getOrderStatistics(restaurantId, dateRange = {}) {
    try {
      // Estadísticas básicas
      const basicStats = await Order.getStats(restaurantId, dateRange);
      
      // Items más vendidos
      const topItems = await Order.getTopItems(restaurantId, dateRange, 10);
      
      // Resumen por períodos
      const dailySummary = await Order.getSalesSummary(restaurantId, 'today');
      const weeklySummary = await Order.getSalesSummary(restaurantId, 'week');
      const monthlySummary = await Order.getSalesSummary(restaurantId, 'month');

      return {
        basic: basicStats,
        top_items: topItems,
        summaries: {
          today: dailySummary,
          week: weeklySummary,
          month: monthlySummary
        },
        generated_at: new Date().toISOString()
      };

    } catch (error) {
      logger.error('Error obteniendo estadísticas de pedidos:', error);
      throw error;
    }
  }

  /**
   * Busca pedidos con filtros avanzados
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} filters - Filtros de búsqueda
   * @returns {Promise<Object>} Resultados de búsqueda
   */
  static async searchOrders(restaurantId, filters = {}) {
    try {
      const {
        customer_phone = null,
        status = null,
        start_date = null,
        end_date = null,
        min_total = null,
        max_total = null,
        neighborhood = null,
        page = 1,
        limit = 20,
        sort_by = 'created_at',
        sort_order = 'DESC'
      } = filters;

      // Preparar opciones para el modelo
      const searchOptions = {
        page: parseInt(page),
        limit: parseInt(limit),
        sortBy: sort_by,
        sortOrder: sort_order.toUpperCase()
      };

      // Agregar filtros
      if (status) searchOptions.status = status;
      if (customer_phone) searchOptions.customerPhone = customer_phone;
      if (start_date) searchOptions.startDate = start_date;
      if (end_date) searchOptions.endDate = end_date;

      const results = await Order.findByRestaurant(restaurantId, searchOptions);

      // Filtros adicionales que no están en el modelo base
      if (min_total || max_total || neighborhood) {
        results.orders = results.orders.filter(order => {
          if (min_total && order.total < min_total) return false;
          if (max_total && order.total > max_total) return false;
          if (neighborhood && !order.delivery_neighborhood?.toLowerCase().includes(neighborhood.toLowerCase())) return false;
          return true;
        });

        // Recalcular paginación después del filtro
        results.pagination.total_items = results.orders.length;
        results.pagination.total_pages = Math.ceil(results.orders.length / limit);
      }

      return results;

    } catch (error) {
      logger.error('Error buscando pedidos:', error);
      throw error;
    }
  }

  /**
   * Valida si un pedido puede ser modificado
   * @param {string} orderId - ID del pedido
   * @returns {Promise<Object>} Resultado de validación
   */
  static async validateOrderModification(orderId) {
    try {
      const order = await Order.findById(orderId);
      
      if (!order) {
        return {
          canModify: false,
          reason: 'Pedido no encontrado'
        };
      }

      // No se puede modificar si ya está entregado o cancelado
      if ([ORDER_STATUS.DELIVERED, ORDER_STATUS.CANCELLED].includes(order.status)) {
        return {
          canModify: false,
          reason: `No se puede modificar un pedido ${order.status}`
        };
      }

      // No se puede modificar si ya está en camino
      if (order.status === ORDER_STATUS.OUT_FOR_DELIVERY) {
        return {
          canModify: false,
          reason: 'El pedido ya está en camino'
        };
      }

      // Verificar tiempo transcurrido
      const minutesSinceOrder = (Date.now() - new Date(order.created_at).getTime()) / (1000 * 60);
      
      if (minutesSinceOrder > 10) { // 10 minutos límite para modificaciones
        return {
          canModify: false,
          reason: 'Tiempo límite para modificaciones excedido'
        };
      }

      return {
        canModify: true,
        order
      };

    } catch (error) {
      logger.error('Error validando modificación de pedido:', error);
      return {
        canModify: false,
        reason: 'Error interno'
      };
    }
  }

  /**
   * Genera reporte de ventas
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones del reporte
   * @returns {Promise<Object>} Reporte generado
   */
  static async generateSalesReport(restaurantId, options = {}) {
    try {
      const {
        start_date = null,
        end_date = null,
        group_by = 'day', // day, week, month
        include_items = false
      } = options;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      const report = {
        restaurant_id: restaurantId,
        period: { start_date, end_date },
        generated_at: new Date().toISOString(),
        summary: await Order.getStats(restaurantId, dateRange)
      };

      if (include_items) {
        report.top_items = await Order.getTopItems(restaurantId, dateRange, 20);
      }

      // Agregar agrupación por período (esto requeriría consultas adicionales)
      report.group_by = group_by;
      report.grouped_data = []; // Placeholder para datos agrupados

      return report;

    } catch (error) {
      logger.error('Error generando reporte de ventas:', error);
      throw error;
    }
  }
}

module.exports = OrderService;


================================================
File: src/services/validationService.js
================================================
const Joi = require("joi");
const logger = require("../utils/logger");
const {
  VALIDATION_PATTERNS,
  BUSINESS_CONFIG,
  FILE_LIMITS,
  ORDER_STATUS,
  CONVERSATION_STATUS,
} = require("../utils/constants");

// ============================================
// SERVICIO DE VALIDACIÓN
// ============================================

class ValidationService {
  // ============================================
  // VALIDACIONES DE RESTAURANTE
  // ============================================

  /**
   * Valida datos de creación de restaurante
   * @param {Object} data - Datos del restaurante
   * @returns {Object} Resultado de validación
   */
  static validateRestaurantCreation(data) {
    const schema = Joi.object({
      name: Joi.string().min(2).max(100).required().messages({
        "string.empty": "El nombre del restaurante es requerido",
        "string.min": "El nombre debe tener al menos 2 caracteres",
        "string.max": "El nombre no puede exceder 100 caracteres",
      }),

      slug: Joi.string().pattern(VALIDATION_PATTERNS.SLUG).required().messages({
        "string.pattern.base":
          "El slug solo puede contener letras minúsculas, números y guiones",
        "string.empty": "El slug es requerido",
      }),

      phone: Joi.string()
        .pattern(VALIDATION_PATTERNS.PHONE_NUMBER)
        .required()
        .messages({
          "string.pattern.base": "Formato de teléfono inválido",
          "string.empty": "El teléfono es requerido",
        }),

      email: Joi.string().email().optional().allow(""),

      address: Joi.string().max(255).optional().allow(""),

      logo_url: Joi.string().uri().optional().allow(""),

      opens_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional()
        .messages({
          "string.pattern.base": "Formato de hora inválido (HH:mm:ss)",
        }),

      closes_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional()
        .messages({
          "string.pattern.base": "Formato de hora inválido (HH:mm:ss)",
        }),

      delivery_time_min: Joi.number().integer().min(5).max(120).optional(),
      delivery_time_max: Joi.number().integer().min(10).max(180).optional(),
      delivery_fee: Joi.number().min(0).max(500).optional(),
      minimum_order: Joi.number().min(0).max(10000).optional(),

      whatsapp_phone_id: Joi.string().max(50).optional().allow(""),
      twilio_phone_number: Joi.string().max(20).optional().allow(""),

      // En validateRestaurantCreation agregar:
      country_code: Joi.string()
        .valid("MX", "CO", "AR", "PE", "EC", "CL", "US")
        .optional(),
      currency: Joi.string()
        .valid("MXN", "COP", "ARS", "PEN", "USD", "CLP")
        .optional(),
      timezone: Joi.string().max(50).optional(),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida actualización de restaurante
   * @param {Object} data - Datos a actualizar
   * @returns {Object} Resultado de validación
   */
  static validateRestaurantUpdate(data) {
    const schema = Joi.object({
      name: Joi.string().min(2).max(100).optional(),
      phone: Joi.string().pattern(VALIDATION_PATTERNS.PHONE_NUMBER).optional(),
      email: Joi.string().email().optional().allow(""),
      address: Joi.string().max(255).optional().allow(""),
      logo_url: Joi.string().uri().optional().allow(""),
      is_active: Joi.boolean().optional(),
      opens_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional(),
      closes_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional(),
      delivery_time_min: Joi.number().integer().min(5).max(120).optional(),
      delivery_time_max: Joi.number().integer().min(10).max(180).optional(),
      delivery_fee: Joi.number().min(0).max(500).optional(),
      minimum_order: Joi.number().min(0).max(10000).optional(),
      whatsapp_phone_id: Joi.string().max(50).optional().allow(""),
      twilio_phone_number: Joi.string().max(20).optional().allow(""),
    }).min(1);

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // VALIDACIONES DE MENÚ
  // ============================================

  /**
   * Valida creación de categoría de menú
   * @param {Object} data - Datos de la categoría
   * @returns {Object} Resultado de validación
   */
  static validateMenuCategoryCreation(data) {
    const schema = Joi.object({
      name: Joi.string().min(1).max(50).required().messages({
        "string.empty": "El nombre de la categoría es requerido",
        "string.max": "El nombre no puede exceder 50 caracteres",
      }),

      description: Joi.string().max(255).optional().allow(""),
      display_order: Joi.number().integer().min(0).optional(),
      emoji: Joi.string().max(10).optional().allow(""),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida creación de item de menú
   * @param {Object} data - Datos del item
   * @returns {Object} Resultado de validación
   */
  static validateMenuItemCreation(data) {
    const schema = Joi.object({
      category_id: Joi.string().uuid().required().messages({
        "string.empty": "La categoría es requerida",
        "string.guid": "ID de categoría inválido",
      }),

      name: Joi.string().min(1).max(100).required().messages({
        "string.empty": "El nombre del producto es requerido",
        "string.max": "El nombre no puede exceder 100 caracteres",
      }),

      description: Joi.string().max(500).optional().allow(""),

      price: Joi.number().positive().max(10000).required().messages({
        "number.positive": "El precio debe ser mayor a 0",
        "number.base": "El precio debe ser un número válido",
        "any.required": "El precio es requerido",
      }),

      preparation_time: Joi.number().integer().min(1).max(180).optional(),
      display_order: Joi.number().integer().min(0).optional(),

      ingredients: Joi.array().items(Joi.string().max(50)).max(20).optional(),
      allergens: Joi.array().items(Joi.string().max(30)).max(10).optional(),
      calories: Joi.number().integer().min(0).max(5000).optional(),

      image_url: Joi.string().uri().optional().allow(""),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida actualización de item de menú
   * @param {Object} data - Datos a actualizar
   * @returns {Object} Resultado de validación
   */
  static validateMenuItemUpdate(data) {
    const schema = Joi.object({
      category_id: Joi.string().uuid().optional(),
      name: Joi.string().min(1).max(100).optional(),
      description: Joi.string().max(500).optional().allow(""),
      price: Joi.number().positive().max(10000).optional(),
      is_available: Joi.boolean().optional(),
      preparation_time: Joi.number().integer().min(1).max(180).optional(),
      display_order: Joi.number().integer().min(0).optional(),
      ingredients: Joi.array().items(Joi.string().max(50)).max(20).optional(),
      allergens: Joi.array().items(Joi.string().max(30)).max(10).optional(),
      calories: Joi.number().integer().min(0).max(5000).optional(),
      image_url: Joi.string().uri().optional().allow(""),
    }).min(1);

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // VALIDACIONES DE PEDIDOS
  // ============================================

  /**
   * Valida datos de dirección de entrega
   * @param {Object} address - Datos de dirección
   * @returns {Object} Resultado de validación
   */
  static validateDeliveryAddress(address) {
    const schema = Joi.object({
      street: Joi.string().min(3).max(100).required().messages({
        "string.empty": "La calle es requerida",
        "string.min": "La calle debe tener al menos 3 caracteres",
      }),

      number: Joi.string().min(1).max(20).required().messages({
        "string.empty": "El número es requerido",
      }),

      neighborhood: Joi.string().min(3).max(100).required().messages({
        "string.empty": "La colonia es requerida",
        "string.min": "La colonia debe tener al menos 3 caracteres",
      }),

      references: Joi.string().max(255).optional().allow(""),
      postal_code: Joi.string()
        .pattern(VALIDATION_PATTERNS.POSTAL_CODE)
        .optional()
        .messages({
          "string.pattern.base": "Código postal inválido",
        }),
    });

    return this.validateWithSchema(schema, address);
  }

  /**
   * Valida creación de pedido
   * @param {Object} data - Datos del pedido
   * @returns {Object} Resultado de validación
   */
  static validateOrderCreation(data) {
    const schema = Joi.object({
      restaurant_id: Joi.string().uuid().required(),
      customer_phone: Joi.string()
        .pattern(VALIDATION_PATTERNS.PHONE_NUMBER)
        .required(),
      customer_name: Joi.string().max(100).optional().allow(""),

      delivery_address: Joi.object({
        street: Joi.string().min(3).max(100).required(),
        number: Joi.string().min(1).max(20).required(),
        neighborhood: Joi.string().min(3).max(100).required(),
        references: Joi.string().max(255).optional().allow(""),
        postal_code: Joi.string()
          .pattern(VALIDATION_PATTERNS.POSTAL_CODE)
          .optional(),
      }).required(),

      items: Joi.array()
        .items(
          Joi.object({
            menu_item_id: Joi.string().uuid().required(),
            name: Joi.string().max(100).required(),
            base_price: Joi.number().positive().required(),
            quantity: Joi.number().integer().min(1).max(20).required(),
            customizations: Joi.array()
              .items(
                Joi.object({
                  type: Joi.string().max(20).required(),
                  name: Joi.string().max(50).required(),
                  extra_cost: Joi.number().min(0).required(),
                })
              )
              .optional(),
            notes: Joi.string().max(255).optional().allow(""),
          })
        )
        .min(1)
        .max(BUSINESS_CONFIG.MAX_ITEMS_PER_ORDER)
        .required(),

      subtotal: Joi.number()
        .positive()
        .max(BUSINESS_CONFIG.MAX_ORDER_AMOUNT)
        .required(),
      delivery_fee: Joi.number().min(0).optional(),
      total: Joi.number()
        .positive()
        .max(BUSINESS_CONFIG.MAX_ORDER_AMOUNT)
        .required(),
      special_instructions: Joi.string().max(500).optional().allow(""),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida actualización de estado de pedido
   * @param {Object} data - Datos de actualización
   * @returns {Object} Resultado de validación
   */
  static validateOrderStatusUpdate(data) {
    const validStatuses = Object.values(ORDER_STATUS);

    const schema = Joi.object({
      status: Joi.string()
        .valid(...validStatuses)
        .required()
        .messages({
          "any.only": `Estado debe ser uno de: ${validStatuses.join(", ")}`,
        }),

      internal_notes: Joi.string().max(500).optional().allow(""),
      estimated_delivery_time: Joi.number()
        .integer()
        .min(5)
        .max(180)
        .optional(),
    });

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // VALIDACIONES DE CONVERSACIÓN
  // ============================================

  /**
   * Valida mensaje entrante
   * @param {string} message - Mensaje a validar
   * @param {Object} conversation - Conversación actual
   * @returns {Object} Resultado de validación
   */
  static validateIncomingMessage(message, conversation) {
    try {
      // Validaciones básicas
      if (!message || typeof message !== "string") {
        return {
          isValid: false,
          error: "Mensaje inválido",
        };
      }

      // Limpiar y validar longitud
      const cleanMessage = message.trim();

      if (cleanMessage.length === 0) {
        return {
          isValid: false,
          error: "Mensaje vacío",
        };
      }

      if (cleanMessage.length > 1000) {
        return {
          isValid: false,
          error: "Mensaje demasiado largo (máximo 1000 caracteres)",
        };
      }

      // Validar caracteres problemáticos
      if (this.containsMaliciousContent(cleanMessage)) {
        return {
          isValid: false,
          error: "Contenido no permitido",
        };
      }

      // Validar estado de conversación
      if (
        conversation &&
        conversation.status === CONVERSATION_STATUS.COMPLETED
      ) {
        return {
          isValid: false,
          error: "La conversación ya ha sido completada",
        };
      }

      return {
        isValid: true,
        cleanMessage,
      };
    } catch (error) {
      logger.error("Error validando mensaje entrante:", error);
      return {
        isValid: false,
        error: "Error de validación",
      };
    }
  }

  /**
   * Valida pedido desde conversación
   * @param {Object} conversation - Conversación con pedido
   * @returns {Object} Resultado de validación
   */
  static validateOrderFromConversation(conversation) {
    try {
      if (!conversation) {
        return {
          isValid: false,
          error: "Conversación no encontrada",
        };
      }

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || "{}");
      } catch (e) {
        return {
          isValid: false,
          error: "Datos de pedido corruptos",
        };
      }

      // Validar items
      if (
        !orderData.items ||
        !Array.isArray(orderData.items) ||
        orderData.items.length === 0
      ) {
        return {
          isValid: false,
          error: "El pedido debe tener al menos un item",
        };
      }

      if (orderData.items.length > BUSINESS_CONFIG.MAX_ITEMS_PER_ORDER) {
        return {
          isValid: false,
          error: `Máximo ${BUSINESS_CONFIG.MAX_ITEMS_PER_ORDER} items por pedido`,
        };
      }

      // Validar dirección
      const address = orderData.delivery_address;
      if (
        !address ||
        !address.street ||
        !address.number ||
        !address.neighborhood
      ) {
        return {
          isValid: false,
          error: "Dirección de entrega incompleta",
        };
      }

      // Validar montos
      if (!orderData.total || orderData.total <= 0) {
        return {
          isValid: false,
          error: "Total del pedido inválido",
        };
      }

      if (orderData.total > BUSINESS_CONFIG.MAX_ORDER_AMOUNT) {
        return {
          isValid: false,
          error: `Monto máximo de pedido: $${BUSINESS_CONFIG.MAX_ORDER_AMOUNT}`,
        };
      }

      // Validar cada item
      for (const item of orderData.items) {
        if (
          !item.menu_item_id ||
          !item.name ||
          !item.base_price ||
          !item.quantity
        ) {
          return {
            isValid: false,
            error: "Item de pedido incompleto",
          };
        }

        if (item.quantity <= 0 || item.quantity > 20) {
          return {
            isValid: false,
            error: "Cantidad de item inválida",
          };
        }
      }

      return {
        isValid: true,
        orderData,
      };
    } catch (error) {
      logger.error("Error validando pedido desde conversación:", error);
      return {
        isValid: false,
        error: "Error de validación",
      };
    }
  }

  // ============================================
  // VALIDACIONES DE ARCHIVOS
  // ============================================

  /**
   * Valida archivo subido
   * @param {Object} file - Archivo a validar
   * @param {string} type - Tipo esperado ('image', 'document')
   * @returns {Object} Resultado de validación
   */
  static validateFileUpload(file, type = "image") {
    try {
      if (!file) {
        return {
          isValid: false,
          error: "Archivo no encontrado",
        };
      }

      // Validar tamaño
      if (file.size > FILE_LIMITS.MAX_FILE_SIZE) {
        return {
          isValid: false,
          error: `Archivo demasiado grande. Máximo: ${FILE_LIMITS.MAX_FILE_SIZE / 1024 / 1024}MB`,
        };
      }

      // Validar tipo MIME
      let allowedTypes = [];

      switch (type) {
        case "image":
          allowedTypes = FILE_LIMITS.ALLOWED_IMAGE_TYPES;
          break;
        case "document":
          allowedTypes = FILE_LIMITS.ALLOWED_DOCUMENT_TYPES;
          break;
        default:
          allowedTypes = [
            ...FILE_LIMITS.ALLOWED_IMAGE_TYPES,
            ...FILE_LIMITS.ALLOWED_DOCUMENT_TYPES,
          ];
      }

      if (!allowedTypes.includes(file.mimetype)) {
        return {
          isValid: false,
          error: `Tipo de archivo no permitido. Permitidos: ${allowedTypes.join(", ")}`,
        };
      }

      return {
        isValid: true,
        file,
      };
    } catch (error) {
      logger.error("Error validando archivo:", error);
      return {
        isValid: false,
        error: "Error de validación de archivo",
      };
    }
  }

  // ============================================
  // VALIDACIONES DE PARÁMETROS DE CONSULTA
  // ============================================

  /**
   * Valida parámetros de paginación
   * @param {Object} params - Parámetros de consulta
   * @returns {Object} Resultado de validación
   */
  static validatePaginationParams(params) {
    const schema = Joi.object({
      page: Joi.number().integer().min(1).max(1000).optional().default(1),
      limit: Joi.number().integer().min(1).max(100).optional().default(20),
      sort_by: Joi.string().max(50).optional().default("created_at"),
      sort_order: Joi.string()
        .valid("ASC", "DESC", "asc", "desc")
        .optional()
        .default("DESC"),
    });

    return this.validateWithSchema(schema, params);
  }

  /**
   * Valida parámetros de filtros de fecha
   * @param {Object} params - Parámetros de fecha
   * @returns {Object} Resultado de validación
   */
  static validateDateRangeParams(params) {
    const schema = Joi.object({
      start_date: Joi.date().iso().optional(),
      end_date: Joi.date().iso().min(Joi.ref("start_date")).optional(),
      period: Joi.string().valid("today", "week", "month", "year").optional(),
    });

    return this.validateWithSchema(schema, params);
  }

  // ============================================
  // VALIDACIONES DE WEBHOOK
  // ============================================

  /**
   * Valida datos de webhook de WhatsApp
   * @param {Object} data - Datos del webhook
   * @param {string} provider - Proveedor (twilio/meta)
   * @returns {Object} Resultado de validación
   */
  static validateWhatsAppWebhook(data, provider) {
    try {
      if (!data || typeof data !== "object") {
        return {
          isValid: false,
          error: "Datos de webhook inválidos",
        };
      }

      switch (provider.toLowerCase()) {
        case "twilio":
          return this.validateTwilioWebhook(data);
        case "meta":
          return this.validateMetaWebhook(data);
        default:
          return {
            isValid: false,
            error: "Proveedor no soportado",
          };
      }
    } catch (error) {
      logger.error("Error validando webhook de WhatsApp:", error);
      return {
        isValid: false,
        error: "Error de validación de webhook",
      };
    }
  }

  /**
   * Valida webhook de Twilio
   * @param {Object} data - Datos del webhook
   * @returns {Object} Resultado de validación
   */
  static validateTwilioWebhook(data) {
    const schema = Joi.object({
      MessageSid: Joi.string().required(),
      From: Joi.string().required(),
      To: Joi.string().required(),
      Body: Joi.string().allow("").optional(),
      MediaUrl0: Joi.string().uri().optional(),
      MediaContentType0: Joi.string().optional(),
    }).unknown(true); // Permitir campos adicionales

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida webhook de Meta
   * @param {Object} data - Datos del webhook
   * @returns {Object} Resultado de validación
   */
  static validateMetaWebhook(data) {
    const schema = Joi.object({
      entry: Joi.array()
        .items(
          Joi.object({
            changes: Joi.array()
              .items(
                Joi.object({
                  value: Joi.object({
                    messages: Joi.array()
                      .items(
                        Joi.object({
                          id: Joi.string().required(),
                          from: Joi.string().required(),
                          text: Joi.object({
                            body: Joi.string().required(),
                          }).optional(),
                          timestamp: Joi.string().required(),
                        }).unknown(true)
                      )
                      .optional(),
                    metadata: Joi.object({
                      phone_number_id: Joi.string().required(),
                    })
                      .unknown(true)
                      .required(),
                  })
                    .unknown(true)
                    .required(),
                }).unknown(true)
              )
              .required(),
          }).unknown(true)
        )
        .required(),
    }).unknown(true);

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // MÉTODOS AUXILIARES
  // ============================================

  /**
   * Ejecuta validación con esquema de Joi
   * @param {Object} schema - Esquema de Joi
   * @param {Object} data - Datos a validar
   * @returns {Object} Resultado de validación
   */
  static validateWithSchema(schema, data) {
    try {
      const { error, value } = schema.validate(data, {
        abortEarly: false, // Mostrar todos los errores
        stripUnknown: true, // Remover campos desconocidos
        convert: true, // Convertir tipos automáticamente
      });

      if (error) {
        const errorMessages = error.details.map((detail) => detail.message);

        return {
          isValid: false,
          error: errorMessages.join("; "),
          details: error.details,
        };
      }

      return {
        isValid: true,
        data: value,
      };
    } catch (validationError) {
      logger.error("Error en validación con esquema:", validationError);
      return {
        isValid: false,
        error: "Error interno de validación",
      };
    }
  }

  /**
   * Verifica si el contenido es malicioso
   * @param {string} content - Contenido a verificar
   * @returns {boolean} True si es malicioso
   */
  static containsMaliciousContent(content) {
    try {
      const maliciousPatterns = [
        /<script/i,
        /javascript:/i,
        /vbscript:/i,
        /onload=/i,
        /onerror=/i,
        /eval\(/i,
        /document\.cookie/i,
        /document\.write/i,
        /<iframe/i,
        /<object/i,
        /<embed/i,
      ];

      return maliciousPatterns.some((pattern) => pattern.test(content));
    } catch (error) {
      logger.error("Error verificando contenido malicioso:", error);
      return false; // En caso de error, permitir el contenido
    }
  }

  /**
   * Valida formato de teléfono mexicano
   * @param {string} phone - Número de teléfono
   * @returns {boolean} True si es válido
   */
  static isValidMexicanPhone(phone) {
    try {
      return VALIDATION_PATTERNS.MEXICAN_PHONE.test(phone);
    } catch (error) {
      return false;
    }
  }

  /**
   * Valida formato de email
   * @param {string} email - Email a validar
   * @returns {boolean} True si es válido
   */
  static isValidEmail(email) {
    try {
      return VALIDATION_PATTERNS.EMAIL.test(email);
    } catch (error) {
      return false;
    }
  }

  /**
   * Sanitiza texto de entrada
   * @param {string} text - Texto a sanitizar
   * @returns {string} Texto sanitizado
   */
  static sanitizeText(text) {
    if (!text || typeof text !== "string") {
      return "";
    }

    try {
      return text
        .trim()
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#x27;")
        .replace(/\//g, "&#x2F;");
    } catch (error) {
      logger.error("Error sanitizando texto:", error);
      return text;
    }
  }

  /**
   * Valida UUID
   * @param {string} uuid - UUID a validar
   * @returns {boolean} True si es válido
   */
  static isValidUUID(uuid) {
    const uuidPattern =
      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidPattern.test(uuid);
  }
}

module.exports = ValidationService;



================================================
File: src/services/whatsappService.js
================================================
const {
  sendWhatsAppMessage,
  processTwilioIncomingMessage,
  processMetaIncomingMessage,
  validateTwilioWebhook,
  validateMetaWebhook,
  formatPhoneNumber,
  checkWhatsAppStatus
} = require('../config/whatsapp');

const logger = require('../utils/logger');
const { DEFAULT_MESSAGES, EMOJIS } = require('../utils/constants');
const { ValidationError, ExternalServiceError } = require('../middleware/errorHandler');

// ============================================
// SERVICIO WHATSAPP
// ============================================

class WhatsAppService {

  /**
   * Envía un mensaje de WhatsApp a un cliente
   * @param {string} to - Número de teléfono destino
   * @param {string} message - Mensaje a enviar
   * @param {Object} options - Opciones adicionales
   * @returns {Promise<Object>} Resultado del envío
   */
  static async sendMessage(to, message, options = {}) {
    try {
      const formattedPhone = formatPhoneNumber(to);
      
      // Validar mensaje
      if (!message || message.trim().length === 0) {
        throw new ValidationError('Mensaje vacío');
      }

      // Procesar mensaje (agregar emojis, formatear, etc.)
      const processedMessage = this.processOutgoingMessage(message, options);

      // Enviar mensaje
      const result = await sendWhatsAppMessage(formattedPhone, processedMessage, options);

      logger.logWhatsApp('send', formattedPhone, result.provider, {
        success: result.success,
        messageId: result.messageId,
        messageLength: processedMessage.length
      });

      return result;

    } catch (error) {
      logger.error('Error enviando mensaje de WhatsApp:', error);
      throw new ExternalServiceError('WhatsApp', error.message);
    }
  }

  /**
   * Procesa un mensaje entrante de WhatsApp
   * @param {Object} webhookData - Datos del webhook
   * @param {string} provider - Proveedor (twilio/meta)
   * @returns {Object} Mensaje procesado
   */
  static processIncomingMessage(webhookData, provider) {
    try {
      let processedMessage;

      switch (provider.toLowerCase()) {
        case 'twilio':
          processedMessage = processTwilioIncomingMessage(webhookData);
          break;
        case 'meta':
          processedMessage = processMetaIncomingMessage(webhookData);
          break;
        default:
          throw new ValidationError('Proveedor de WhatsApp no soportado');
      }

      if (!processedMessage) {
        return null;
      }

      // Procesar mensaje entrante (limpiar, validar, etc.)
      processedMessage.body = this.processIncomingMessageText(processedMessage.body);

      logger.logWhatsApp('receive', processedMessage.from, provider, {
        messageId: processedMessage.messageId,
        messageLength: processedMessage.body.length,
        hasMedia: !!processedMessage.mediaUrl
      });

      return processedMessage;

    } catch (error) {
      logger.error('Error procesando mensaje entrante:', error);
      throw error;
    }
  }

  /**
   * Valida un webhook de WhatsApp
   * @param {Object} req - Request object
   * @param {string} provider - Proveedor (twilio/meta)
   * @returns {boolean|string} True/challenge si es válido, false si no
   */
  static validateWebhook(req, provider) {
    try {
      switch (provider.toLowerCase()) {
        case 'twilio':
          const signature = req.headers['x-twilio-signature'];
          const url = `${req.protocol}://${req.get('host')}${req.originalUrl}`;
          return validateTwilioWebhook(signature, url, req.body);

        case 'meta':
          const mode = req.query['hub.mode'];
          const token = req.query['hub.verify_token'];
          const challenge = req.query['hub.challenge'];
          return validateMetaWebhook(mode, token, challenge);

        default:
          return false;
      }

    } catch (error) {
      logger.error('Error validando webhook:', error);
      return false;
    }
  }

  /**
   * Procesa mensaje saliente (agregar formato, emojis, etc.)
   * @param {string} message - Mensaje original
   * @param {Object} options - Opciones de procesamiento
   * @returns {string} Mensaje procesado
   */
  static processOutgoingMessage(message, options = {}) {
    try {
      let processedMessage = message;

      // Aplicar formato básico
      if (options.addGreeting && !this.hasGreeting(message)) {
        processedMessage = `¡Hola! 👋\n\n${processedMessage}`;
      }

      // Agregar emojis contextualmente
      if (options.addEmojis !== false) {
        processedMessage = this.addContextualEmojis(processedMessage);
      }

      // Formatear listas si las hay
      processedMessage = this.formatLists(processedMessage);

      // Formatear precios
      processedMessage = this.formatPrices(processedMessage);

      // Asegurar que no sea demasiado largo
      if (processedMessage.length > 1600) {
        processedMessage = processedMessage.substring(0, 1597) + '...';
      }

      return processedMessage;

    } catch (error) {
      logger.error('Error procesando mensaje saliente:', error);
      return message; // Retornar mensaje original si hay error
    }
  }

  /**
   * Procesa mensaje entrante (limpiar texto, etc.)
   * @param {string} messageText - Texto del mensaje
   * @returns {string} Texto procesado
   */
  static processIncomingMessageText(messageText) {
    if (!messageText) return '';

    try {
      let processed = messageText;

      // Limpiar espacios extra
      processed = processed.trim().replace(/\s+/g, ' ');

      // Normalizar caracteres especiales
      processed = processed.normalize('NFD').replace(/[\u0300-\u036f]/g, '');

      // Convertir a minúscula para análisis (pero mantener original para respuesta)
      const normalized = processed.toLowerCase();

      // Expandir abreviaciones comunes
      const abbreviations = {
        'q': 'que',
        'x': 'por',
        'xq': 'porque',
        'pq': 'porque',
        'tmb': 'tambien',
        'tb': 'tambien',
        'bn': 'bien',
        'ok': 'esta bien',
        'si': 'sí'
      };

      Object.keys(abbreviations).forEach(abbrev => {
        const regex = new RegExp(`\\b${abbrev}\\b`, 'gi');
        processed = processed.replace(regex, abbreviations[abbrev]);
      });

      return processed;

    } catch (error) {
      logger.error('Error procesando texto entrante:', error);
      return messageText;
    }
  }

  /**
   * Verifica si el mensaje ya tiene saludo
   * @param {string} message - Mensaje a verificar
   * @returns {boolean} True si tiene saludo
   */
  static hasGreeting(message) {
    const greetings = ['hola', 'buenas', 'saludos', 'que tal', 'hello', 'hi'];
    const messageLower = message.toLowerCase();
    return greetings.some(greeting => messageLower.includes(greeting));
  }

  /**
   * Agrega emojis contextualmente al mensaje
   * @param {string} message - Mensaje original
   * @returns {string} Mensaje con emojis
   */
  static addContextualEmojis(message) {
    try {
      let processedMessage = message;
      const messageLower = message.toLowerCase();

      // Solo agregar si no tiene muchos emojis ya
      const emojiCount = (message.match(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]/gu) || []).length;
      
      if (emojiCount > 3) {
        return processedMessage; // Ya tiene suficientes emojis
      }

      // Emojis por contexto
      if (messageLower.includes('gracias') || messageLower.includes('thank')) {
        processedMessage = processedMessage.replace(/gracias/gi, `gracias ${EMOJIS.GENERAL.THANKS}`);
      }

      if (messageLower.includes('pedido') && messageLower.includes('listo')) {
        processedMessage += ` ${EMOJIS.STATUS.SUCCESS}`;
      }

      if (messageLower.includes('error') || messageLower.includes('problema')) {
        processedMessage += ` ${EMOJIS.STATUS.ERROR}`;
      }

      if (messageLower.includes('dinero') || messageLower.includes('total') || messageLower.includes('$')) {
        processedMessage = processedMessage.replace(/total/gi, `total ${EMOJIS.STATUS.MONEY}`);
      }

      if (messageLower.includes('tiempo') || messageLower.includes('minutos')) {
        processedMessage = processedMessage.replace(/minutos/gi, `minutos ${EMOJIS.GENERAL.TIME}`);
      }

      if (messageLower.includes('dirección') || messageLower.includes('direccion') || messageLower.includes('entrega')) {
        processedMessage = processedMessage.replace(/(dirección|direccion|entrega)/gi, `$1 ${EMOJIS.GENERAL.LOCATION}`);
      }

      return processedMessage;

    } catch (error) {
      logger.error('Error agregando emojis contextuales:', error);
      return message;
    }
  }

  /**
   * Formatea listas en el mensaje
   * @param {string} message - Mensaje con listas
   * @returns {string} Mensaje con listas formateadas
   */
  static formatLists(message) {
    try {
      let processedMessage = message;

      // Detectar y formatear listas numericas
      const listPattern = /(\d+[\.\)]?\s*[^\n]+)/g;
      const matches = message.match(listPattern);

      if (matches && matches.length > 1) {
        matches.forEach(match => {
          const formatted = match.replace(/^(\d+)[\.\)]*\s*/, '$1️⃣ ');
          processedMessage = processedMessage.replace(match, formatted);
        });
      }

      // Formatear listas con guiones
      processedMessage = processedMessage.replace(/^-\s+/gm, '• ');
      
      return processedMessage;

    } catch (error) {
      logger.error('Error formateando listas:', error);
      return message;
    }
  }

  /**
   * Formatea precios en el mensaje
   * @param {string} message - Mensaje con precios
   * @returns {string} Mensaje con precios formateados
   */
  static formatPrices(message) {
    try {
      // Formatear precios ($XX.XX o $XX)
      let processedMessage = message.replace(/\$(\d+(?:\.\d{2})?)/g, '💰$$$1');
      
      // Pero no duplicar si ya tiene emoji
      processedMessage = processedMessage.replace(/💰💰/g, '💰');
      
      return processedMessage;

    } catch (error) {
      logger.error('Error formateando precios:', error);
      return message;
    }
  }

  /**
   * Genera mensaje de confirmación de pedido
   * @param {Object} orderData - Datos del pedido
   * @param {Object} restaurant - Datos del restaurante
   * @returns {string} Mensaje de confirmación
   */
  static generateOrderConfirmation(orderData, restaurant) {
    try {
      const items = orderData.items || [];
      const deliveryTime = orderData.estimated_delivery_time || restaurant.delivery_time_max || 35;

      let message = `${EMOJIS.STATUS.SUCCESS} *PEDIDO CONFIRMADO*\n\n`;
      
      message += `*Restaurante:* ${restaurant.name}\n`;
      message += `*Pedido:*\n`;

      items.forEach((item, index) => {
        message += `${index + 1}️⃣ ${item.name} (${item.quantity}x) - $${item.item_total}\n`;
        
        if (item.customizations && item.customizations.length > 0) {
          item.customizations.forEach(custom => {
            message += `   • ${custom.name}${custom.extra_cost > 0 ? ` (+$${custom.extra_cost})` : ''}\n`;
          });
        }
        
        if (item.notes) {
          message += `   📝 ${item.notes}\n`;
        }
      });

      message += `\n*Subtotal:* $${orderData.subtotal}`;
      
      if (orderData.delivery_fee > 0) {
        message += `\n*Envío:* $${orderData.delivery_fee}`;
      }
      
      message += `\n*TOTAL:* 💰$${orderData.total}`;

      message += `\n\n*Dirección de entrega:*\n`;
      message += `${EMOJIS.GENERAL.LOCATION} ${orderData.delivery_address?.street} ${orderData.delivery_address?.number}\n`;
      message += `${orderData.delivery_address?.neighborhood}`;
      
      if (orderData.delivery_address?.references) {
        message += `\n📍 *Referencias:* ${orderData.delivery_address.references}`;
      }

      message += `\n\n${EMOJIS.GENERAL.TIME} *Tiempo estimado:* ${deliveryTime} minutos`;
      
      if (restaurant.phone) {
        message += `\n${EMOJIS.GENERAL.PHONE} *Teléfono:* ${restaurant.phone}`;
      }

      message += `\n\n¡Gracias por tu preferencia! ${EMOJIS.GENERAL.THANKS}`;

      return message;

    } catch (error) {
      logger.error('Error generando confirmación de pedido:', error);
      return DEFAULT_MESSAGES.ORDER_CONFIRMED.replace('{delivery_time}', '30-35');
    }
  }

  /**
   * Genera mensaje de menú formateado
   * @param {Array} menuCategories - Categorías del menú
   * @param {Object} restaurant - Datos del restaurante
   * @returns {string} Mensaje del menú
   */
  static generateMenuMessage(menuCategories, restaurant) {
    try {
      let message = `🍽️ *MENÚ - ${restaurant.name.toUpperCase()}*\n\n`;

      menuCategories.forEach((category, categoryIndex) => {
        if (category.items.length === 0) return;

        const emoji = category.emoji || '🍽️';
        message += `${emoji} *${category.name.toUpperCase()}*\n`;
        
        if (category.description) {
          message += `_${category.description}_\n`;
        }

        category.items.forEach((item, itemIndex) => {
          message += `${itemIndex + 1}. *${item.name}* - $${item.price}\n`;
          
          if (item.description) {
            message += `   _${item.description}_\n`;
          }
        });

        message += '\n';
      });

      // Agregar información adicional
      if (restaurant.delivery_fee > 0) {
        message += `🚚 *Costo de envío:* $${restaurant.delivery_fee}\n`;
      }

      if (restaurant.minimum_order > 0) {
        message += `📦 *Pedido mínimo:* $${restaurant.minimum_order}\n`;
      }

      message += `${EMOJIS.GENERAL.TIME} *Tiempo de entrega:* ${restaurant.delivery_time_min}-${restaurant.delivery_time_max} min\n\n`;

      message += `¿Qué te gustaría ordenar? 😊`;

      return message;

    } catch (error) {
      logger.error('Error generando mensaje de menú:', error);
      return 'Error generando menú. Por favor intenta más tarde.';
    }
  }

  /**
   * Genera mensaje de estado del pedido
   * @param {Object} order - Datos del pedido
   * @returns {string} Mensaje de estado
   */
  static generateOrderStatusMessage(order) {
    try {
      const statusEmojis = {
        'confirmed': '✅',
        'preparing': '👨‍🍳',
        'ready': '🛵',
        'out_for_delivery': '🚗',
        'delivered': '✅',
        'cancelled': '❌'
      };

      const statusNames = {
        'confirmed': 'Confirmado',
        'preparing': 'En preparación',
        'ready': 'Listo para entregar',
        'out_for_delivery': 'En camino',
        'delivered': 'Entregado',
        'cancelled': 'Cancelado'
      };

      const emoji = statusEmojis[order.status] || '📋';
      const statusName = statusNames[order.status] || order.status;

      let message = `${emoji} *ESTADO DE TU PEDIDO*\n\n`;
      message += `*Estado:* ${statusName}\n`;
      message += `*Total:* $${order.total}\n`;

      if (order.estimated_delivery_time && order.status !== 'delivered') {
        message += `*Tiempo estimado:* ${order.estimated_delivery_time} min\n`;
      }

      if (order.delivered_at) {
        const deliveredDate = new Date(order.delivered_at);
        message += `*Entregado:* ${deliveredDate.toLocaleString('es-MX')}\n`;
      }

      return message;

    } catch (error) {
      logger.error('Error generando mensaje de estado:', error);
      return 'Error obteniendo estado del pedido.';
    }
  }

  /**
   * Envía mensaje con reintentos automáticos
   * @param {string} to - Número destino
   * @param {string} message - Mensaje a enviar
   * @param {Object} options - Opciones adicionales
   * @param {number} maxRetries - Número máximo de reintentos
   * @returns {Promise<Object>} Resultado del envío
   */
  static async sendMessageWithRetry(to, message, options = {}, maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.sendMessage(to, message, options);
        
        if (result.success) {
          if (attempt > 1) {
            logger.info('Mensaje enviado exitosamente después de reintentos', {
              phone: to.substring(0, 8) + '****',
              attempt,
              maxRetries
            });
          }
          return result;
        }

      } catch (error) {
        lastError = error;
        
        logger.warn(`Intento ${attempt}/${maxRetries} fallido enviando mensaje`, {
          phone: to.substring(0, 8) + '****',
          error: error.message,
          attempt
        });

        if (attempt < maxRetries) {
          // Esperar antes del siguiente intento (backoff exponencial)
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // Si todos los intentos fallaron
    logger.error('Todos los intentos de envío fallaron', {
      phone: to.substring(0, 8) + '****',
      maxRetries,
      finalError: lastError?.message
    });

    throw lastError || new Error('Envío fallido después de todos los reintentos');
  }

  /**
   * Verifica el estado de los servicios de WhatsApp
   * @returns {Promise<Object>} Estado de los servicios
   */
  static async checkServicesStatus() {
    try {
      const status = await checkWhatsAppStatus();
      
      logger.info('Estado de servicios WhatsApp verificado', status);
      
      return {
        ...status,
        timestamp: new Date().toISOString(),
        healthy: status.activeProvider !== null
      };

    } catch (error) {
      logger.error('Error verificando estado de servicios WhatsApp:', error);
      
      return {
        twilio: false,
        meta: false,
        activeProvider: null,
        healthy: false,
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Procesa mensajes multimedia (imágenes, documentos)
   * @param {Object} messageData - Datos del mensaje
   * @returns {Promise<Object>} Información del archivo procesado
   */
  static async processMediaMessage(messageData) {
    try {
      const { mediaUrl, mediaType } = messageData;
      
      if (!mediaUrl) {
        return null;
      }

      // Por ahora solo loggear, en el futuro se podría descargar y procesar
      logger.info('Mensaje multimedia recibido', {
        mediaType,
        mediaUrl: mediaUrl.substring(0, 100) + '...',
        from: messageData.from?.substring(0, 8) + '****'
      });

      return {
        type: mediaType,
        url: mediaUrl,
        processed: false,
        message: 'Los archivos multimedia no están soportados en este momento, pero hemos recibido tu mensaje. ¿Podrías escribir tu pedido por texto? 😊'
      };

    } catch (error) {
      logger.error('Error procesando mensaje multimedia:', error);
      return {
        processed: false,
        error: error.message,
        message: 'Hubo un problema procesando tu archivo. ¿Podrías enviar tu pedido por texto? 😊'
      };
    }
  }

  /**
   * Obtiene estadísticas de mensajes
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estadísticas de mensajería
   */
  static async getMessagingStats(restaurantId, dateRange = {}) {
    try {
      // Esta función requeriría una tabla de logs de mensajes
      // Por ahora retornamos un placeholder
      return {
        total_sent: 0,
        total_received: 0,
        success_rate: 100,
        avg_response_time: 0,
        failed_messages: 0
      };

    } catch (error) {
      logger.error('Error obteniendo estadísticas de mensajería:', error);
      throw error;
    }
  }
}

module.exports = WhatsAppService;


================================================
File: src/utils/constants.js
================================================
// ============================================
// CONSTANTES DEL SISTEMA - CHATBOT CHINGÓN
// ============================================

/**
 * Estados de conversación
 */
const CONVERSATION_STATUS = {
  ACTIVE: 'active',
  COMPLETING_ORDER: 'completing_order',
  COMPLETED: 'completed',
  ABANDONED: 'abandoned'
};

/**
 * Pasos de la conversación
 */
const CONVERSATION_STEPS = {
  GREETING: 'greeting',
  ORDERING: 'ordering',
  CUSTOMIZING: 'customizing',
  REVIEWING: 'reviewing',
  ADDRESS: 'address',
  CONFIRMING: 'confirming',
  COMPLETED: 'completed'
};

/**
 * Estados de pedidos
 */
const ORDER_STATUS = {
  CONFIRMED: 'confirmed',
  PREPARING: 'preparing',
  READY: 'ready',
  OUT_FOR_DELIVERY: 'out_for_delivery',
  DELIVERED: 'delivered',
  CANCELLED: 'cancelled'
};

/**
 * Tipos de reglas de negocio
 */
const BUSINESS_RULE_TYPES = {
  SAUCE_LIMIT: 'sauce_limit',
  EXTRA_COST: 'extra_cost',
  COMBO_RULE: 'combo_rule',
  SIZE_OPTION: 'size_option',
  QUANTITY_LIMIT: 'quantity_limit',
  TIME_RESTRICTION: 'time_restriction',
  AVAILABILITY: 'availability'
};

/**
 * Tipos de customización
 */
const CUSTOMIZATION_TYPES = {
  SAUCE: 'sauce',
  EXTRA: 'extra',
  SIZE: 'size',
  PREPARATION: 'preparation',
  REMOVAL: 'removal'
};

/**
 * Proveedores de WhatsApp
 */
const WHATSAPP_PROVIDERS = {
  TWILIO: 'twilio',
  META: 'meta'
};

/**
 * Modelos de Claude AI disponibles
 */
const CLAUDE_MODELS = {
  SONNET_3_5: 'claude-3-5-sonnet-20241022',
  HAIKU_3: 'claude-3-haiku-20240307',
  OPUS_3: 'claude-3-opus-20240229'
};

/**
 * Niveles de log
 */
const LOG_LEVELS = {
  ERROR: 'error',
  WARN: 'warn',
  INFO: 'info',
  DEBUG: 'debug'
};

/**
 * Tipos de eventos de seguridad
 */
const SECURITY_EVENTS = {
  INVALID_WEBHOOK: 'invalid_webhook',
  RATE_LIMIT_EXCEEDED: 'rate_limit_exceeded',
  UNAUTHORIZED_ACCESS: 'unauthorized_access',
  SUSPICIOUS_ACTIVITY: 'suspicious_activity'
};

/**
 * Configuración de tiempo
 */
const TIME_LIMITS = {
  MAX_CONVERSATION_TIME: parseInt(process.env.MAX_CONVERSATION_TIME) || 1800, // 30 minutos
  CONVERSATION_CLEANUP_INTERVAL: parseInt(process.env.CONVERSATION_CLEANUP_INTERVAL) || 3600, // 1 hora
  DEFAULT_DELIVERY_TIME_MIN: parseInt(process.env.DEFAULT_DELIVERY_TIME_MIN) || 25,
  DEFAULT_DELIVERY_TIME_MAX: parseInt(process.env.DEFAULT_DELIVERY_TIME_MAX) || 35,
  MESSAGE_TIMEOUT: 30000, // 30 segundos
  DATABASE_QUERY_TIMEOUT: 30000, // 30 segundos
  CLAUDE_REQUEST_TIMEOUT: 60000 // 60 segundos
};

/**
 * Límites de rate limiting
 */
const RATE_LIMITS = {
  WEBHOOK_PER_MINUTE: 100,
  API_PER_MINUTE: 60,
  CLAUDE_PER_MINUTE: 30,
  WHATSAPP_PER_MINUTE: 50
};

/**
 * Configuración de archivos y uploads
 */
const FILE_LIMITS = {
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB
  ALLOWED_IMAGE_TYPES: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  ALLOWED_DOCUMENT_TYPES: ['application/pdf', 'text/plain'],
  MAX_MESSAGE_LENGTH: 4096
};

/**
 * Configuración de base de datos
 */
const DATABASE_LIMITS = {
  MAX_POOL_SIZE: parseInt(process.env.DB_POOL_MAX) || 10,
  MIN_POOL_SIZE: parseInt(process.env.DB_POOL_MIN) || 2,
  IDLE_TIMEOUT: parseInt(process.env.DB_IDLE_TIMEOUT) || 10000,
  CONNECTION_TIMEOUT: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 2000
};

/**
 * Mensajes predeterminados del sistema
 */
const DEFAULT_MESSAGES = {
  WELCOME: '¡Hola! 👋 Bienvenido a nuestro restaurante. ¿En qué puedo ayudarte hoy?',
  ERROR: 'Lo siento, tuve un problema técnico. ¿Podrías repetir tu mensaje?',
  GOODBYE: '¡Gracias por tu pedido! 🙏 Te esperamos pronto.',
  TIMEOUT: 'He notado que no has respondido en un tiempo. ¿Sigues ahí? Tu pedido sigue guardado.',
  INVALID_INPUT: 'No entendí tu mensaje. ¿Podrías ser más específico?',
  ORDER_CONFIRMED: '✅ ¡Pedido confirmado! Llegará en {delivery_time} minutos aproximadamente.',
  ORDER_CANCELLED: '❌ Pedido cancelado. ¿Hay algo más en lo que pueda ayudarte?',
  RESTAURANT_CLOSED: '😔 Lo siento, estamos cerrados en este momento. Nuestros horarios son: {hours}',
  OUT_OF_DELIVERY_ZONE: '📍 Lo siento, no hacemos entregas a esa zona. Nuestras zonas de entrega son: {zones}'
};

/**
 * Regex patterns para validación
 */
const VALIDATION_PATTERNS = {
  PHONE_NUMBER: /^\+[1-9]\d{1,14}$/,
  EMAIL: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  MEXICAN_PHONE: /^(\+52|52)?[1-9]\d{9}$/,
  POSTAL_CODE: /^\d{5}$/,
  SLUG: /^[a-z0-9]+(?:-[a-z0-9]+)*$/
};

/**
 * Configuración de Claude AI
 */
const CLAUDE_CONFIG = {
  DEFAULT_MODEL: process.env.CLAUDE_MODEL || CLAUDE_MODELS.SONNET_3_5,
  DEFAULT_MAX_TOKENS: parseInt(process.env.CLAUDE_MAX_TOKENS) || 500,
  DEFAULT_TEMPERATURE: parseFloat(process.env.CLAUDE_TEMPERATURE) || 0.7,
  MAX_CONTEXT_LENGTH: 100000, // tokens aproximados
  RETRY_ATTEMPTS: 3,
  RETRY_DELAY: 1000 // 1 segundo
};

/**
 * Configuración de negocio
 */
const BUSINESS_CONFIG = {
  MIN_ORDER_AMOUNT: 50, // Monto mínimo de pedido por defecto
  MAX_ORDER_AMOUNT: 5000, // Monto máximo de pedido
  DEFAULT_DELIVERY_FEE: 0,
  MAX_ITEMS_PER_ORDER: 20,
  MAX_CUSTOMIZATIONS_PER_ITEM: 10,
  COMMISSION_RATE: 0.08, // 8% de comisión por defecto
  TAX_RATE: 0.16 // 16% IVA en México
};

/**
 * Configuración de cache
 */
const CACHE_CONFIG = {
  MENU_TTL: 300, // 5 minutos
  RESTAURANT_TTL: 600, // 10 minutos
  BUSINESS_RULES_TTL: 300, // 5 minutos
  CONVERSATION_TTL: 1800 // 30 minutos
};

/**
 * Configuración de notificaciones
 */
const NOTIFICATION_TYPES = {
  NEW_ORDER: 'new_order',
  ORDER_UPDATE: 'order_update',
  CUSTOMER_MESSAGE: 'customer_message',
  SYSTEM_ERROR: 'system_error',
  LOW_INVENTORY: 'low_inventory'
};

/**
 * Estados de disponibilidad
 */
const AVAILABILITY_STATUS = {
  AVAILABLE: 'available',
  OUT_OF_STOCK: 'out_of_stock',
  TEMPORARILY_UNAVAILABLE: 'temporarily_unavailable',
  DISCONTINUED: 'discontinued'
};

/**
 * Tipos de descuento
 */
const DISCOUNT_TYPES = {
  PERCENTAGE: 'percentage',
  FIXED_AMOUNT: 'fixed_amount',
  FREE_ITEM: 'free_item',
  FREE_DELIVERY: 'free_delivery'
};

/**
 * Métodos de pago (para futuras implementaciones)
 */
const PAYMENT_METHODS = {
  CASH: 'cash',
  CARD: 'card',
  TRANSFER: 'transfer',
  DIGITAL_WALLET: 'digital_wallet'
};

/**
 * Días de la semana
 */
const WEEKDAYS = {
  MONDAY: 1,
  TUESDAY: 2,
  WEDNESDAY: 3,
  THURSDAY: 4,
  FRIDAY: 5,
  SATURDAY: 6,
  SUNDAY: 0
};

/**
 * Formatos de fecha y hora
 */
const DATE_FORMATS = {
  ISO: 'YYYY-MM-DDTHH:mm:ss.SSSZ',
  DATE_ONLY: 'YYYY-MM-DD',
  TIME_ONLY: 'HH:mm:ss',
  DISPLAY: 'DD/MM/YYYY HH:mm',
  SHORT_DATE: 'DD/MM/YYYY'
};

/**
 * Configuración de emojis para el chat
 */
const EMOJIS = {
  FOOD: {
    CHICKEN: '🍗',
    BURGER: '🍔',
    PIZZA: '🍕',
    TACO: '🌮',
    HOTDOG: '🌭',
    FRIES: '🍟'
  },
  DRINKS: {
    BEER: '🍺',
    SODA: '🥤',
    WATER: '💧',
    COFFEE: '☕',
    JUICE: '🧃'
  },
  STATUS: {
    SUCCESS: '✅',
    ERROR: '❌',
    WARNING: '⚠️',
    INFO: 'ℹ️',
    LOADING: '⏳',
    MONEY: '💰'
  },
  GENERAL: {
    HELLO: '👋',
    THANKS: '🙏',
    LOCATION: '📍',
    TIME: '⏰',
    PHONE: '📞',
    FIRE: '🔥'
  }
};

/**
 * Función helper para obtener emoji de comida
 * @param {string} category - Categoría del producto
 * @returns {string} Emoji correspondiente
 */
const getFoodEmoji = (category) => {
  const categoryLower = category.toLowerCase();
  
  if (categoryLower.includes('alit') || categoryLower.includes('pollo')) return EMOJIS.FOOD.CHICKEN;
  if (categoryLower.includes('hamburg')) return EMOJIS.FOOD.BURGER;
  if (categoryLower.includes('pizza')) return EMOJIS.FOOD.PIZZA;
  if (categoryLower.includes('taco')) return EMOJIS.FOOD.TACO;
  if (categoryLower.includes('hotdog') || categoryLower.includes('hot dog')) return EMOJIS.FOOD.HOTDOG;
  if (categoryLower.includes('papa') || categoryLower.includes('frita')) return EMOJIS.FOOD.FRIES;
  if (categoryLower.includes('bebida') || categoryLower.includes('refresco')) return EMOJIS.DRINKS.SODA;
  if (categoryLower.includes('cerveza') || categoryLower.includes('michela')) return EMOJIS.DRINKS.BEER;
  
  return '🍽️'; // Emoji por defecto
};

/**
 * Función helper para validar número de teléfono mexicano
 * @param {string} phone - Número de teléfono
 * @returns {boolean} True si es válido
 */
const isValidMexicanPhone = (phone) => {
  return VALIDATION_PATTERNS.MEXICAN_PHONE.test(phone);
};

/**
 * Función helper para formatear moneda mexicana
 * @param {number} amount - Cantidad
 * @returns {string} Cantidad formateada
 */
const formatMXNCurrency = (amount) => {
  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency: 'MXN'
  }).format(amount);
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Estados y tipos
  CONVERSATION_STATUS,
  CONVERSATION_STEPS,
  ORDER_STATUS,
  BUSINESS_RULE_TYPES,
  CUSTOMIZATION_TYPES,
  WHATSAPP_PROVIDERS,
  CLAUDE_MODELS,
  LOG_LEVELS,
  SECURITY_EVENTS,
  NOTIFICATION_TYPES,
  AVAILABILITY_STATUS,
  DISCOUNT_TYPES,
  PAYMENT_METHODS,
  
  // Configuración
  TIME_LIMITS,
  RATE_LIMITS,
  FILE_LIMITS,
  DATABASE_LIMITS,
  CLAUDE_CONFIG,
  BUSINESS_CONFIG,
  CACHE_CONFIG,
  
  // Mensajes y validación
  DEFAULT_MESSAGES,
  VALIDATION_PATTERNS,
  
  // Utilidades
  WEEKDAYS,
  DATE_FORMATS,
  EMOJIS,
  
  // Funciones helper
  getFoodEmoji,
  isValidMexicanPhone,
  formatMXNCurrency
};


================================================
File: src/utils/helpers.js
================================================



================================================
File: src/utils/logger.js
================================================
const winston = require('winston');
const path = require('path');

// ============================================
// CONFIGURACIÓN DEL LOGGER
// ============================================

const logLevel = process.env.LOG_LEVEL || 'info';
const logFile = process.env.LOG_FILE || 'logs/app.log';
const errorLogFile = process.env.ERROR_LOG_FILE || 'logs/error.log';

// Crear directorio de logs si no existe
const fs = require('fs');
const logDir = path.dirname(logFile);
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

// ============================================
// FORMATOS PERSONALIZADOS
// ============================================

// Formato para consola (desarrollo)
const consoleFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.colorize(),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let logMessage = `${timestamp} [${level}]: ${message}`;
    
    // Agregar metadata si existe
    if (Object.keys(meta).length > 0) {
      logMessage += ` ${JSON.stringify(meta, null, 2)}`;
    }
    
    return logMessage;
  })
);

// Formato para archivos (producción)
const fileFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// ============================================
// TRANSPORTES
// ============================================

const transports = [];

// Transporte de consola (siempre activo en desarrollo)
if (process.env.NODE_ENV !== 'production') {
  transports.push(
    new winston.transports.Console({
      level: logLevel,
      format: consoleFormat,
      handleExceptions: true,
      handleRejections: true
    })
  );
}

// Transporte de archivo general
transports.push(
  new winston.transports.File({
    filename: logFile,
    level: logLevel,
    format: fileFormat,
    maxsize: 5242880, // 5MB
    maxFiles: 5,
    handleExceptions: true
  })
);

// Transporte de archivo solo para errores
transports.push(
  new winston.transports.File({
    filename: errorLogFile,
    level: 'error',
    format: fileFormat,
    maxsize: 5242880, // 5MB
    maxFiles: 5,
    handleExceptions: true,
    handleRejections: true
  })
);

// ============================================
// CREAR LOGGER
// ============================================

const logger = winston.createLogger({
  level: logLevel,
  format: fileFormat,
  transports,
  exitOnError: false,
  
  // Manejo de excepciones no capturadas
  exceptionHandlers: [
    new winston.transports.File({ 
      filename: 'logs/exceptions.log',
      format: fileFormat
    })
  ],
  
  // Manejo de promesas rechazadas
  rejectionHandlers: [
    new winston.transports.File({ 
      filename: 'logs/rejections.log',
      format: fileFormat
    })
  ]
});

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Log específico para requests HTTP
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 * @param {number} duration - Duración en ms
 */
logger.logRequest = (req, res, duration) => {
  const logData = {
    method: req.method,
    url: req.originalUrl,
    statusCode: res.statusCode,
    duration: `${duration}ms`,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    contentLength: res.get('Content-Length') || 0
  };

  if (res.statusCode >= 400) {
    logger.warn('HTTP Request - Error', logData);
  } else {
    logger.info('HTTP Request', logData);
  }
};

/**
 * Log específico para operaciones de base de datos
 * @param {string} operation - Tipo de operación
 * @param {string} table - Tabla afectada
 * @param {number} duration - Duración en ms
 * @param {number} rowCount - Número de filas afectadas
 * @param {Object} metadata - Datos adicionales
 */
logger.logDatabase = (operation, table, duration, rowCount = 0, metadata = {}) => {
  logger.debug('Database Operation', {
    operation,
    table,
    duration: `${duration}ms`,
    rowCount,
    ...metadata
  });
};

/**
 * Log específico para interacciones con Claude AI
 * @param {string} operation - Tipo de operación
 * @param {number} duration - Duración en ms
 * @param {Object} usage - Información de tokens
 * @param {Object} metadata - Datos adicionales
 */
logger.logClaude = (operation, duration, usage = {}, metadata = {}) => {
  logger.info('Claude AI Operation', {
    operation,
    duration: `${duration}ms`,
    inputTokens: usage.input_tokens,
    outputTokens: usage.output_tokens,
    totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0),
    ...metadata
  });
};

/**
 * Log específico para WhatsApp
 * @param {string} operation - Tipo de operación (send, receive, etc.)
 * @param {string} phone - Número de teléfono
 * @param {string} provider - Proveedor (twilio, meta)
 * @param {Object} metadata - Datos adicionales
 */
logger.logWhatsApp = (operation, phone, provider, metadata = {}) => {
  logger.info('WhatsApp Operation', {
    operation,
    phone: phone ? phone.substring(0, 8) + '****' : 'unknown', // Enmascarar número
    provider,
    ...metadata
  });
};

/**
 * Log específico para errores de negocio
 * @param {string} context - Contexto del error
 * @param {Error} error - Error object
 * @param {Object} metadata - Datos adicionales
 */
logger.logBusinessError = (context, error, metadata = {}) => {
  logger.error('Business Logic Error', {
    context,
    error: error.message,
    stack: error.stack,
    ...metadata
  });
};

/**
 * Log específico para métricas de rendimiento
 * @param {string} metric - Nombre de la métrica
 * @param {number} value - Valor de la métrica
 * @param {string} unit - Unidad de medida
 * @param {Object} metadata - Datos adicionales
 */
logger.logMetric = (metric, value, unit = '', metadata = {}) => {
  logger.info('Performance Metric', {
    metric,
    value,
    unit,
    timestamp: new Date().toISOString(),
    ...metadata
  });
};

/**
 * Log específico para eventos de seguridad
 * @param {string} event - Tipo de evento
 * @param {string} severity - Severidad (low, medium, high, critical)
 * @param {Object} metadata - Datos adicionales
 */
logger.logSecurity = (event, severity = 'medium', metadata = {}) => {
  const logLevel = {
    low: 'info',
    medium: 'warn',
    high: 'error',
    critical: 'error'
  }[severity] || 'warn';

  logger[logLevel]('Security Event', {
    event,
    severity,
    timestamp: new Date().toISOString(),
    ...metadata
  });
};

// ============================================
// MIDDLEWARE PARA EXPRESS
// ============================================

/**
 * Middleware para logging automático de requests
 */
logger.requestMiddleware = () => {
  return (req, res, next) => {
    const start = Date.now();
    
    // Interceptar el final de la respuesta
    const originalSend = res.send;
    res.send = function(body) {
      const duration = Date.now() - start;
      logger.logRequest(req, res, duration);
      
      // Llamar al método original
      originalSend.call(this, body);
    };
    
    next();
  };
};

// ============================================
// FUNCIONES DE UTILIDAD ADICIONALES
// ============================================

/**
 * Crea un logger hijo con contexto específico
 * @param {Object} context - Contexto para el logger hijo
 * @returns {Object} Logger hijo
 */
logger.child = (context) => {
  return logger.child(context);
};

/**
 * Obtiene estadísticas de logs
 * @returns {Object} Estadísticas
 */
logger.getStats = () => {
  // Esta función podría expandirse para leer archivos de log
  // y proporcionar estadísticas útiles
  return {
    level: logger.level,
    transports: logger.transports.length,
    logFile,
    errorLogFile
  };
};

/**
 * Cambia el nivel de log dinámicamente
 * @param {string} newLevel - Nuevo nivel de log
 */
logger.setLevel = (newLevel) => {
  logger.level = newLevel;
  logger.transports.forEach(transport => {
    transport.level = newLevel;
  });
  logger.info(`Nivel de log cambiado a: ${newLevel}`);
};

// ============================================
// MANEJO ESPECIAL PARA DESARROLLO
// ============================================

if (process.env.NODE_ENV === 'development') {
  // En desarrollo, también logear a consola con colores
  logger.add(new winston.transports.Console({
    level: 'debug',
    format: consoleFormat
  }));
  
  logger.info('🚀 Logger configurado para desarrollo');
  logger.debug('Debug logging habilitado');
}

// ============================================
// EXPORT
// ============================================

module.exports = logger;


================================================
File: src/utils/validators.js
================================================




