Directory structure:
‚îî‚îÄ‚îÄ ChatBotChingon/
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ server.js
    ‚îú‚îÄ‚îÄ test-db.js
    ‚îú‚îÄ‚îÄ database/
    ‚îÇ   ‚îú‚îÄ‚îÄ connection.js
    ‚îÇ   ‚îú‚îÄ‚îÄ dump.db
    ‚îÇ   ‚îú‚îÄ‚îÄ migrations/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001_initial_schema.sql
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 002_users_and_roles.sql
    ‚îÇ   ‚îî‚îÄ‚îÄ queries/
    ‚îÇ       ‚îú‚îÄ‚îÄ conversations.js
    ‚îÇ       ‚îú‚îÄ‚îÄ customers.js
    ‚îÇ       ‚îú‚îÄ‚îÄ menu.js
    ‚îÇ       ‚îú‚îÄ‚îÄ orders.js
    ‚îÇ       ‚îî‚îÄ‚îÄ restaurants.js
    ‚îú‚îÄ‚îÄ docs/
    ‚îÇ   ‚îú‚îÄ‚îÄ API.md
    ‚îÇ   ‚îî‚îÄ‚îÄ SETUP.md
    ‚îú‚îÄ‚îÄ logs/
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ config/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ claude.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ whatsapp.js
    ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authController.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversationController.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ menuController.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orderController.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ restaurantController.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhookController.js
    ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rateLimiter.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tenantResolver.js
    ‚îÇ   ‚îú‚îÄ‚îÄ models/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Conversation.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Customer.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Menu.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Order.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Restaurant.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ User.js
    ‚îÇ   ‚îú‚îÄ‚îÄ routes/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ menu.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ restaurants.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook.js
    ‚îÇ   ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ claudeService.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversationService.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orderService.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validationService.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ whatsappService.js
    ‚îÇ   ‚îî‚îÄ‚îÄ utils/
    ‚îÇ       ‚îú‚îÄ‚îÄ constants.js
    ‚îÇ       ‚îú‚îÄ‚îÄ helpers.js
    ‚îÇ       ‚îú‚îÄ‚îÄ logger.js
    ‚îÇ       ‚îî‚îÄ‚îÄ validators.js
    ‚îî‚îÄ‚îÄ tests/
        ‚îú‚îÄ‚îÄ integration/
        ‚îî‚îÄ‚îÄ unit/

================================================
File: package.json
================================================
{
  "name": "chatbot-chingon",
  "version": "1.0.0",
  "description": "Sistema de chatbot inteligente para restaurantes con WhatsApp y Claude AI - Optimizado para Neon Database",
  "main": "server.js",
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "test:watch": "jest --watch",
    
    "setup": "node scripts/setup-neon.js setup",
    "setup:neon": "node scripts/setup-neon.js setup",
    "setup:clean": "node scripts/setup-neon.js clean",
    "setup:verify": "node scripts/setup-neon.js verify",
    
    "migrate": "node scripts/setup-neon.js setup",
    "migrate:verify": "node scripts/setup-neon.js verify",
    
    "db:setup": "node scripts/setup-neon.js setup",
    "db:clean": "node scripts/setup-neon.js clean",
    "db:verify": "node scripts/setup-neon.js verify",
    
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    
    "logs": "tail -f logs/app.log",
    "logs:error": "grep ERROR logs/app.log",
    
    "production": "NODE_ENV=production node server.js",
    "pm2:start": "pm2 start ecosystem.config.js",
    "pm2:stop": "pm2 stop chatbot-chingon",
    "pm2:restart": "pm2 restart chatbot-chingon",
    "pm2:logs": "pm2 logs chatbot-chingon"
  },
  "keywords": [
    "chatbot",
    "whatsapp",
    "restaurant",
    "claude-ai",
    "food-delivery",
    "nodejs",
    "neon-database",
    "postgresql"
  ],
  "author": "NexDev",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "compression": "^1.7.4",
    "dotenv": "^16.3.1",
    "pg": "^8.11.3",
    "uuid": "^9.0.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "joi": "^17.9.2",
    "axios": "^1.5.0",
    "winston": "^3.10.0",
    "express-rate-limit": "^6.10.0",
    "express-validator": "^7.0.1",
    "multer": "^1.4.5-lts.1",
    "twilio": "^4.15.0",
    "@anthropic-ai/sdk": "^0.24.3",
    "moment": "^2.29.4",
    "node-cron": "^3.0.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.4",
    "supertest": "^6.3.3",
    "eslint": "^8.47.0",
    "prettier": "^3.0.2"
  },
  "nodemonConfig": {
    "watch": [
      "src/**/*",
      "database/**/*",
      "scripts/**/*",
      "server.js"
    ],
    "ext": "js,json",
    "ignore": [
      "logs/**/*",
      "uploads/**/*",
      "node_modules/**/*"
    ],
    "env": {
      "NODE_ENV": "development"
    }
  },
  "jest": {
    "testEnvironment": "node",
    "setupFilesAfterEnv": ["<rootDir>/tests/setup.js"],
    "testMatch": [
      "**/tests/**/*.test.js"
    ],
    "collectCoverageFrom": [
      "src/**/*.js",
      "!src/config/*.js"
    ]
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/tu-usuario/chatbot-chingon.git"
  },
  "bugs": {
    "url": "https://github.com/tu-usuario/chatbot-chingon/issues"
  },
  "homepage": "https://github.com/tu-usuario/chatbot-chingon#readme"
}


================================================
File: server.js
================================================
const express = require("express");
const cors = require("cors");
const helmet = require("helmet");
const compression = require("compression");
const cron = require("node-cron");
require("dotenv").config();

// Importar configuraci√≥n y servicios
const logger = require("./src/utils/logger");
const { errorHandler } = require('./src/middleware/errorHandler');
const rateLimiter = require("./src/middleware/rateLimiter");
const { testDatabaseConnection } = require("./src/config/database");
const {
  cleanupInactiveConversations,
} = require("./src/services/conversationService");

// Importar rutas
const webhookRoutes = require("./src/routes/webhook");
const restaurantRoutes = require("./src/routes/restaurants");
const menuRoutes = require("./src/routes/menu");
const orderRoutes = require("./src/routes/orders");
const dashboardRoutes = require("./src/routes/dashboard");

const app = express();
const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || "localhost";
let server;

// ============================================
// MIDDLEWARE GLOBAL
// ============================================

// Seguridad
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
  })
);

// CORS configurado
app.use(
  cors({
    origin: process.env.FRONTEND_URL ? [process.env.FRONTEND_URL] : true,
    credentials: true,
    optionsSuccessStatus: 200,
  })
);

// Compresi√≥n
app.use(compression());

// Rate limiting
app.use("/api/", rateLimiter.apiLimiter);

// Parsing
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

// Logging de requests
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.originalUrl}`, {
    ip: req.ip,
    userAgent: req.get("User-Agent"),
    timestamp: new Date().toISOString(),
  });
  next();
});

// ============================================
// RUTAS
// ============================================

// Health check
app.get("/health", (req, res) => {
  res.status(200).json({
    status: "ok",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    version: require("./package.json").version,
  });
});

// Webhook de WhatsApp (sin rate limit para no bloquear mensajes)
app.use("/webhook", webhookRoutes);

// API Routes (con rate limit)
app.use("/api/restaurants", restaurantRoutes);
app.use("/api/menu", menuRoutes);
app.use("/api/orders", orderRoutes);
app.use("/api/dashboard", dashboardRoutes);
app.use('/api/auth', require('./src/routes/auth'));

// Ruta de prueba
app.get("/", (req, res) => {
  res.json({
    message: "ChatBot Ching√≥n API v1.0",
    status: "running",
    docs: "/api/docs",
    health: "/health",
  });
});

// ============================================
// MANEJO DE ERRORES
// ============================================

// 404 Handler
app.use("*", (req, res) => {
  logger.warn(`404 - Route not found: ${req.method} ${req.originalUrl}`);
  res.status(404).json({
    success: false,
    message: "Ruta no encontrada",
    path: req.originalUrl,
  });
});

// Global error handler
app.use(errorHandler);

// ============================================
// TAREAS PROGRAMADAS
// ============================================

// Limpiar conversaciones inactivas cada hora
cron.schedule("0 * * * *", async () => {
  try {
    logger.info("Ejecutando limpieza de conversaciones inactivas...");
    const cleanedCount = await cleanupInactiveConversations();
    logger.info(
      `Limpieza completada: ${cleanedCount} conversaciones marcadas como abandonadas`
    );
  } catch (error) {
    logger.error("Error en limpieza de conversaciones:", error);
  }
});

// ============================================
// MANEJO DE SE√ëALES DEL SISTEMA
// ============================================

// Graceful shutdown
const gracefulShutdown = (signal) => {
  logger.info(`Recibida se√±al ${signal}. Cerrando servidor...`);

  if (server) {
    server.close(() => {
      logger.info("Servidor HTTP cerrado.");

      // Cerrar conexiones de base de datos
      const { pool } = require("./src/config/database");
      pool.end(() => {
        logger.info("Pool de base de datos cerrado.");
        process.exit(0);
      });
    });
  } else {
    logger.info("Servidor no iniciado, cerrando proceso...");
    process.exit(0);
  }

  server.close(() => {
    logger.info("Servidor HTTP cerrado.");

    // Cerrar conexiones de base de datos
    const { pool } = require("./src/config/database");
    pool.end(() => {
      logger.info("Pool de base de datos cerrado.");
      process.exit(0);
    });
  });

  // Forzar cierre despu√©s de 10 segundos
  setTimeout(() => {
    logger.error("Forzando cierre del servidor...");
    process.exit(1);
  }, 10000);
};

process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));

// Manejo de errores no capturados
process.on("uncaughtException", (error) => {
  logger.error("Excepci√≥n no capturada:", error);
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  logger.error("Promise rechazada no manejada:", { reason, promise });
  process.exit(1);
});

// ============================================
// INICIALIZACI√ìN DEL SERVIDOR
// ============================================

const startServer = async () => {
  try {
    // Verificar conexi√≥n a base de datos
    logger.info("Verificando conexi√≥n a base de datos...");
    await testDatabaseConnection();
    logger.info("‚úÖ Conexi√≥n a base de datos exitosa");

    // Iniciar servidor y asignar a la variable global
    server = app.listen(PORT, HOST, () => {
      logger.info(`üöÄ Servidor ChatBot Ching√≥n iniciado`);
      logger.info(`üìç URL: http://${HOST}:${PORT}`);
      logger.info(`üåç Entorno: ${process.env.NODE_ENV}`);
      logger.info(`üìã Health Check: http://${HOST}:${PORT}/health`);

      if (process.env.NODE_ENV === "development") {
        logger.info(
          `üîó Frontend: ${process.env.FRONTEND_URL || "No configurado"}`
        );
        logger.info(`üìû WhatsApp Webhook: http://${HOST}:${PORT}/webhook`);
      }
    });

    // Configurar timeout del servidor
    server.timeout = 30000; // 30 segundos

    return server;
  } catch (error) {
    logger.error("‚ùå Error al iniciar el servidor:", error);
    process.exit(1);
  }
};

// Exportar para tests
if (require.main === module) {
  // Solo ejecutar si es llamado directamente
  startServer();
} else {
  // Para tests
  module.exports = app;
}



================================================
File: test-db.js
================================================
require('dotenv').config();
const { testConnection, query } = require('./database/connection');

const testNeonConnection = async () => {
  try {
    console.log('üîÑ Probando conexi√≥n a Neon...');
    await testConnection();
    
    console.log('üîÑ Verificando tablas...');
    const result = await query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
      ORDER BY table_name
    `);
    
    console.log('üìã Tablas encontradas:');
    result.rows.forEach(row => console.log(`  - ${row.table_name}`));
    
    console.log('‚úÖ ¬°Todo funciona correctamente!');
    process.exit(0);
    
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
};

testNeonConnection();


================================================
File: database/connection.js
================================================
const { Pool } = require('pg');
const logger = require('../src/utils/logger');

// ============================================
// CONFIGURACI√ìN DE CONEXI√ìN A POSTGRESQL
// ============================================

// Configuraci√≥n del pool de conexiones
// En database/connection.js, actualiza la configuraci√≥n del pool:

const poolConfig = {
  user: process.env.DB_USER || 'neondb_owner',
  host: process.env.DB_HOST || 'ep-dawn-waterfall-aeee70v1-pooler.c-2.us-east-2.aws.neon.tech',
  database: process.env.DB_NAME || 'neondb',
  password: process.env.DB_PASSWORD || 'npg_YkBK7W2MvSaQ',
  port: parseInt(process.env.DB_PORT) || 5432,
  
  // Configuraci√≥n espec√≠fica para Neon
  ssl: {
    require: true,
    rejectUnauthorized: false
  },
  
  // Pool optimizado para Neon
  max: parseInt(process.env.DB_POOL_MAX) || 5,
  min: parseInt(process.env.DB_POOL_MIN) || 1,
  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,
  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 5000,
  query_timeout: parseInt(process.env.DB_QUERY_TIMEOUT) || 60000,
  
  // Configuraciones espec√≠ficas para Neon
  application_name: 'ChatBot_Chingon',
  statement_timeout: 60000,
  idle_in_transaction_session_timeout: 60000
};
// Crear el pool de conexiones
const pool = new Pool(poolConfig);

// ============================================
// EVENTOS DEL POOL
// ============================================

pool.on('connect', (client) => {
  logger.debug('Nueva conexi√≥n a PostgreSQL establecida', {
    processId: client.processID,
    database: poolConfig.database
  });
});

pool.on('acquire', (client) => {
  logger.debug('Conexi√≥n adquirida del pool', {
    processId: client.processID,
    poolSize: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount
  });
});

pool.on('remove', (client) => {
  logger.debug('Conexi√≥n removida del pool', {
    processId: client.processID,
    poolSize: pool.totalCount
  });
});

pool.on('error', (err, client) => {
  logger.error('Error inesperado en cliente del pool:', {
    error: err.message,
    processId: client?.processID,
    poolSize: pool.totalCount
  });
});

// ============================================
// FUNCI√ìN PRINCIPAL DE CONSULTA
// ============================================

/**
 * Ejecuta una consulta SQL con logging y manejo de errores
 * @param {string} text - Query SQL
 * @param {Array} params - Par√°metros de la consulta
 * @param {string} operationName - Nombre de la operaci√≥n para logging
 * @returns {Promise<Object>} Resultado de la consulta
 */
const query = async (text, params = [], operationName = 'unknown') => {
  const start = Date.now();
  const client = await pool.connect();
  
  try {
    // Log de debug para desarrollo
    if (process.env.NODE_ENV === 'development' && process.env.LOG_SQL === 'true') {
      logger.debug('Ejecutando consulta SQL', {
        operation: operationName,
        query: text.replace(/\s+/g, ' ').trim(),
        params: params.length > 0 ? params : 'sin par√°metros'
      });
    }

    const result = await client.query(text, params);
    const duration = Date.now() - start;

    // Log de m√©tricas de rendimiento
    logger.logDatabase('info', operationName, duration, result.rowCount, {
      affectedRows: result.rowCount,
      command: result.command
    });

    // Alertar sobre consultas lentas
    if (duration > 5000) { // 5 segundos
      logger.warn('Consulta lenta detectada', {
        operation: operationName,
        duration: `${duration}ms`,
        rowCount: result.rowCount
      });
    }

    return result;

  } catch (error) {
    const duration = Date.now() - start;
    
    // Log detallado del error
    logger.logDatabase('error', operationName, duration, 0, {
      error: error.message,
      code: error.code,
      detail: error.detail,
      hint: error.hint,
      position: error.position,
      query: text.replace(/\s+/g, ' ').trim().substring(0, 200),
      params: params.length > 0 ? JSON.stringify(params).substring(0, 200) : null
    });

    // Re-lanzar el error para que sea manejado por los controladores
    throw error;

  } finally {
    client.release();
  }
};

// ============================================
// FUNCI√ìN DE TRANSACCI√ìN
// ============================================

/**
 * Ejecuta m√∫ltiples consultas en una transacci√≥n
 * @param {Function} callback - Funci√≥n que contiene las operaciones de la transacci√≥n
 * @returns {Promise<any>} Resultado de la transacci√≥n
 */
const transaction = async (callback) => {
  const client = await pool.connect();
  const start = Date.now();
  
  try {
    await client.query('BEGIN');
    logger.debug('Transacci√≥n iniciada');

    const result = await callback(client);
    
    await client.query('COMMIT');
    const duration = Date.now() - start;
    
    logger.info('Transacci√≥n completada exitosamente', {
      duration: `${duration}ms`
    });

    return result;

  } catch (error) {
    await client.query('ROLLBACK');
    const duration = Date.now() - start;
    
    logger.error('Transacci√≥n revertida debido a error', {
      error: error.message,
      duration: `${duration}ms`,
      code: error.code
    });

    throw error;

  } finally {
    client.release();
  }
};

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Verifica la conexi√≥n a la base de datos
 * @returns {Promise<boolean>} True si la conexi√≥n es exitosa
 */
const testConnection = async () => {
  try {
    const result = await query(
      'SELECT NOW() as current_time, version() as version', 
      [], 
      'test_connection'
    );
    
    logger.info('Conexi√≥n a base de datos verificada', {
      timestamp: result.rows[0].current_time,
      version: result.rows[0].version.split(' ')[0] + ' ' + result.rows[0].version.split(' ')[1]
    });
    
    return true;
    
  } catch (error) {
    logger.error('Error al probar conexi√≥n a base de datos:', error);
    throw error;
  }
};

/**
 * Verifica si existe una tabla
 * @param {string} tableName - Nombre de la tabla
 * @returns {Promise<boolean>} True si la tabla existe
 */
const tableExists = async (tableName) => {
  try {
    const result = await query(
      `SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )`,
      [tableName],
      `check_table_exists_${tableName}`
    );
    
    return result.rows[0].exists;
    
  } catch (error) {
    logger.error(`Error al verificar existencia de tabla ${tableName}:`, error);
    return false;
  }
};

/**
 * Ejecuta migraciones desde archivo SQL
 * @param {string} migrationPath - Ruta del archivo de migraci√≥n
 * @returns {Promise<void>}
 */
const runMigration = async (migrationPath) => {
  const fs = require('fs');
  const path = require('path');
  
  try {
    if (!fs.existsSync(migrationPath)) {
      throw new Error(`Archivo de migraci√≥n no encontrado: ${migrationPath}`);
    }
    
    const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
    
    await transaction(async (client) => {
      logger.info('Ejecutando migraci√≥n:', migrationPath);
      
      // Dividir el SQL en statements individuales (simplificado)
      const statements = migrationSQL.split(';').filter(stmt => stmt.trim());
      
      for (const statement of statements) {
        if (statement.trim()) {
          await client.query(statement.trim());
        }
      }
      
      logger.info('‚úÖ Migraci√≥n ejecutada exitosamente');
    });
    
  } catch (error) {
    logger.error('‚ùå Error al ejecutar migraci√≥n:', error);
    throw error;
  }
};

/**
 * Limpia conexiones inactivas y resetea el pool si es necesario
 * @returns {Promise<void>}
 */
const cleanupConnections = async () => {
  try {
    logger.info('Limpiando conexiones inactivas', {
      totalConnections: pool.totalCount,
      idleConnections: pool.idleCount,
      waitingClients: pool.waitingCount
    });

    // PostgreSQL autom√°ticamente maneja las conexiones idle
    // Solo loggeamos el estado actual
    
    if (pool.waitingCount > 0) {
      logger.warn('Clientes esperando conexiones disponibles', {
        waitingCount: pool.waitingCount
      });
    }

  } catch (error) {
    logger.error('Error durante limpieza de conexiones:', error);
  }
};

/**
 * Obtiene estad√≠sticas del pool de conexiones
 * @returns {Object} Estad√≠sticas del pool
 */
const getPoolStats = () => {
  return {
    totalCount: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount,
    maxConnections: poolConfig.max,
    minConnections: poolConfig.min,
    database: poolConfig.database,
    host: poolConfig.host,
    port: poolConfig.port
  };
};

/**
 * Ejecuta una consulta preparada con cache
 * @param {string} name - Nombre √∫nico para la consulta preparada
 * @param {string} text - Query SQL
 * @param {Array} params - Par√°metros
 * @returns {Promise<Object>} Resultado de la consulta
 */
const preparedQuery = async (name, text, params = []) => {
  const start = Date.now();
  const client = await pool.connect();
  
  try {
    // Preparar la consulta si no existe
    const result = await client.query({
      name: name,
      text: text,
      values: params
    });

    const duration = Date.now() - start;
    
    logger.logDatabase('info', `prepared_${name}`, duration, result.rowCount, {
      cached: true,
      affectedRows: result.rowCount
    });

    return result;

  } catch (error) {
    const duration = Date.now() - start;
    
    logger.logDatabase('error', `prepared_${name}`, duration, 0, {
      error: error.message,
      code: error.code
    });

    throw error;

  } finally {
    client.release();
  }
};

/**
 * Cierra todas las conexiones del pool de manera elegante
 * @returns {Promise<void>}
 */
const closePool = async () => {
  try {
    logger.info('Cerrando pool de conexiones...');
    await pool.end();
    logger.info('Pool de conexiones cerrado exitosamente');
  } catch (error) {
    logger.error('Error al cerrar pool de conexiones:', error);
    throw error;
  }
};

// ============================================
// MANEJO DE EVENTOS DE CIERRE
// ============================================

process.on('SIGINT', async () => {
  logger.info('Se√±al SIGINT recibida, cerrando pool de conexiones...');
  await closePool();
});

process.on('SIGTERM', async () => {
  logger.info('Se√±al SIGTERM recibida, cerrando pool de conexiones...');
  await closePool();
});

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Funciones principales
  query,
  transaction,
  
  // Utilidades
  testConnection,
  tableExists,
  runMigration,
  cleanupConnections,
  getPoolStats,
  preparedQuery,
  closePool,
  
  // Pool para acceso directo si es necesario
  pool
};


================================================
File: database/dump.db
================================================
-- ============================================
-- BASE DE DATOS: CHATBOT RESTAURANTES
-- Arquitectura Multi-tenant Optimizada
-- ============================================

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- Para b√∫squedas de texto

-- ============================================
-- TABLA: RESTAURANTES (TENANTS)
-- ============================================
CREATE TABLE restaurants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL, -- hot-wings, minguela
    phone VARCHAR(20) UNIQUE NOT NULL, -- +525512345678
    email VARCHAR(255),
    address TEXT,
    logo_url VARCHAR(500),
    
    -- Configuraci√≥n de operaci√≥n
    is_active BOOLEAN DEFAULT true,
    opens_at TIME DEFAULT '09:00:00',
    closes_at TIME DEFAULT '23:00:00',
    delivery_time_min INTEGER DEFAULT 25, -- minutos m√≠nimos
    delivery_time_max INTEGER DEFAULT 35, -- minutos m√°ximos
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    minimum_order DECIMAL(8,2) DEFAULT 0.00,
    
    -- WhatsApp API Config
    whatsapp_phone_id VARCHAR(100), -- Para Meta WhatsApp API
    whatsapp_token VARCHAR(500),
    twilio_phone_number VARCHAR(20), -- Para Twilio
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- √çndices
    CONSTRAINT restaurants_slug_format CHECK (slug ~ '^[a-z0-9-]+$')
);

-- ============================================
-- TABLA: ZONAS DE ENTREGA
-- ============================================
CREATE TABLE delivery_zones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    zone_name VARCHAR(100) NOT NULL, -- "Centro", "Zona Norte"
    postal_codes TEXT[], -- Array de c√≥digos postales
    neighborhoods TEXT[], -- Array de colonias
    extra_fee DECIMAL(8,2) DEFAULT 0.00, -- Costo extra por zona
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CATEGOR√çAS DE MEN√ö
-- ============================================
CREATE TABLE menu_categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- "Alitas", "Bebidas", "Hotdogs"
    description TEXT,
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    emoji VARCHAR(10), -- üçó, üç∫, üå≠
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(restaurant_id, name)
);

-- ============================================
-- TABLA: PRODUCTOS DEL MEN√ö
-- ============================================
CREATE TABLE menu_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES menu_categories(id) ON DELETE CASCADE,
    
    -- Informaci√≥n b√°sica
    name VARCHAR(255) NOT NULL, -- "Media orden de alitas"
    description TEXT, -- "6 piezas de alitas jugosas"
    price DECIMAL(8,2) NOT NULL,
    
    -- Configuraci√≥n de producto
    is_available BOOLEAN DEFAULT true,
    preparation_time INTEGER DEFAULT 15, -- minutos
    display_order INTEGER DEFAULT 0,
    
    -- Informaci√≥n nutricional (opcional)
    calories INTEGER,
    ingredients TEXT[],
    allergens TEXT[], -- "lacteos", "gluten"
    
    -- Imagen
    image_url VARCHAR(500),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: REGLAS DE NEGOCIO
-- ============================================
CREATE TABLE business_rules (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    menu_item_id UUID REFERENCES menu_items(id) ON DELETE CASCADE, -- NULL = regla global
    
    -- Tipo de regla
    rule_type VARCHAR(50) NOT NULL, -- "sauce_limit", "extra_cost", "combo_rule", "size_option"
    rule_name VARCHAR(100) NOT NULL, -- "Aderezos incluidos"
    
    -- Configuraci√≥n de la regla (JSON flexible)
    rule_config JSONB NOT NULL,
    /* Ejemplos:
    sauce_limit: {"max_included": 1, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri"]}
    size_option: {"sizes": [{"name": "Chica", "price": 60}, {"name": "Grande", "price": 90}]}
    combo_rule: {"required_items": 2, "discount_percent": 15}
    extra_cost: {"extras": [{"name": "Queso extra", "cost": 15}, {"name": "Tocino", "cost": 20}]}
    */
    
    -- Mensaje para la IA
    ai_message_template TEXT, -- "Este producto incluye {max_included} aderezo(s). Extra ${extra_cost} c/u"
    
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CLIENTES
-- ============================================
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    phone VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(255),
    
    -- Datos para entrega
    default_address TEXT,
    default_references TEXT,
    
    -- Stats
    total_orders INTEGER DEFAULT 0,
    total_spent DECIMAL(10,2) DEFAULT 0.00,
    
    -- Timestamps
    first_order_at TIMESTAMP,
    last_order_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONVERSACIONES ACTIVAS
-- ============================================
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_phone VARCHAR(20) NOT NULL,
    
    -- Estado de la conversaci√≥n
    status VARCHAR(20) DEFAULT 'active', -- active, completing_order, completed, abandoned
    current_step VARCHAR(50) DEFAULT 'greeting', -- greeting, ordering, address, confirming
    
    -- Datos del pedido en construcci√≥n
    order_data JSONB DEFAULT '{}',
    /* Estructura:
    {
        "items": [
            {
                "menu_item_id": "uuid",
                "name": "Media orden alitas BBQ",
                "quantity": 1,
                "base_price": 90,
                "customizations": [
                    {"type": "sauce", "name": "BBQ", "extra_cost": 0},
                    {"type": "sauce", "name": "Chimichurri", "extra_cost": 10}
                ],
                "item_total": 100,
                "notes": "Sin cebolla"
            }
        ],
        "subtotal": 100,
        "delivery_fee": 0,
        "total": 100,
        "delivery_address": {
            "street": "Calle Reforma",
            "number": "123",
            "neighborhood": "Centro",
            "references": "Entre 5 de Mayo y Hidalgo",
            "postal_code": "12345"
        }
    }
    */
    
    -- Contexto para Claude
    ai_context JSONB DEFAULT '[]', -- Historial de mensajes
    conversation_summary TEXT, -- Resumen generado por IA
    
    -- Timestamps
    last_interaction_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraint para evitar conversaciones duplicadas activas
    UNIQUE(restaurant_id, customer_phone, status) 
    DEFERRABLE INITIALLY DEFERRED -- Para permitir updates de status
);

-- ============================================
-- TABLA: PEDIDOS COMPLETADOS
-- ============================================
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_id UUID REFERENCES customers(id),
    conversation_id UUID REFERENCES conversations(id),
    
    -- Informaci√≥n del cliente
    customer_phone VARCHAR(20) NOT NULL,
    customer_name VARCHAR(255),
    
    -- Direcci√≥n de entrega
    delivery_street VARCHAR(255) NOT NULL,
    delivery_number VARCHAR(50) NOT NULL,
    delivery_neighborhood VARCHAR(255) NOT NULL,
    delivery_references TEXT,
    delivery_postal_code VARCHAR(10),
    
    -- Estado del pedido
    status VARCHAR(20) DEFAULT 'confirmed', -- confirmed, preparing, ready, delivered, cancelled
    
    -- Montos
    subtotal DECIMAL(8,2) NOT NULL,
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    total DECIMAL(8,2) NOT NULL,
    
    -- Tiempos
    estimated_delivery_time INTEGER, -- minutos
    confirmed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    delivered_at TIMESTAMP,
    
    -- Notas
    special_instructions TEXT,
    internal_notes TEXT, -- Para el restaurante
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: ITEMS DE PEDIDOS
-- ============================================
CREATE TABLE order_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    menu_item_id UUID NOT NULL REFERENCES menu_items(id),
    
    -- Informaci√≥n del producto al momento del pedido
    item_name VARCHAR(255) NOT NULL, -- Snapshot del nombre
    base_price DECIMAL(8,2) NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    
    -- Personalizaciones
    customizations JSONB DEFAULT '[]',
    /* Ejemplo:
    [
        {"type": "sauce", "name": "BBQ", "extra_cost": 0},
        {"type": "sauce", "name": "Chimichurri", "extra_cost": 10},
        {"type": "extra", "name": "Queso extra", "extra_cost": 15}
    ]
    */
    
    customizations_cost DECIMAL(8,2) DEFAULT 0.00,
    item_total DECIMAL(8,2) NOT NULL, -- (base_price + customizations_cost) * quantity
    
    special_notes TEXT, -- "Sin cebolla", "Bien cocidas"
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONFIGURACIONES DEL RESTAURANTE
-- ============================================
CREATE TABLE restaurant_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID UNIQUE NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    
    -- Configuraci√≥n de Claude
    claude_api_key VARCHAR(500),
    claude_model VARCHAR(50) DEFAULT 'claude-3-5-sonnet-20241022',
    ai_personality TEXT DEFAULT 'Amigable y servicial',
    
    -- Mensajes predefinidos
    welcome_message TEXT DEFAULT '¬°Hola! Bienvenido a nuestro restaurante üç¥',
    goodbye_message TEXT DEFAULT '¬°Gracias por tu pedido! Te esperamos pronto üòä',
    error_message TEXT DEFAULT 'Lo siento, tuve un problema. ¬øPuedes repetir tu mensaje?',
    
    -- Configuraci√≥n de negocio
    auto_confirm_orders BOOLEAN DEFAULT false,
    require_phone_validation BOOLEAN DEFAULT false,
    max_conversation_time INTEGER DEFAULT 1800, -- 30 minutos
    
    -- Notificaciones
    notification_email VARCHAR(255),
    notification_phone VARCHAR(20),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- √çNDICES PARA OPTIMIZACI√ìN
-- ============================================

-- √çndices principales para queries frecuentes
CREATE INDEX idx_restaurants_slug ON restaurants(slug);
CREATE INDEX idx_restaurants_phone ON restaurants(phone);
CREATE INDEX idx_restaurants_active ON restaurants(is_active) WHERE is_active = true;

CREATE INDEX idx_menu_items_restaurant ON menu_items(restaurant_id, is_available) WHERE is_available = true;
CREATE INDEX idx_menu_items_category ON menu_items(category_id, display_order);

CREATE INDEX idx_business_rules_item ON business_rules(menu_item_id, rule_type) WHERE is_active = true;
CREATE INDEX idx_business_rules_restaurant ON business_rules(restaurant_id, rule_type) WHERE is_active = true;

CREATE INDEX idx_conversations_active ON conversations(restaurant_id, customer_phone, status) WHERE status = 'active';
CREATE INDEX idx_conversations_last_interaction ON conversations(last_interaction_at) WHERE status = 'active';

CREATE INDEX idx_orders_restaurant_status ON orders(restaurant_id, status, created_at);
CREATE INDEX idx_orders_customer ON orders(customer_phone, created_at);
CREATE INDEX idx_orders_date ON orders(created_at);

CREATE INDEX idx_order_items_order ON order_items(order_id);

-- √çndices para b√∫squedas de texto
CREATE INDEX idx_menu_items_name_trgm ON menu_items USING gin(name gin_trgm_ops);
CREATE INDEX idx_customers_phone ON customers(phone);

-- ============================================
-- TRIGGERS PARA UPDATED_AT
-- ============================================

-- Funci√≥n para actualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers
CREATE TRIGGER update_restaurants_updated_at BEFORE UPDATE ON restaurants FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_menu_items_updated_at BEFORE UPDATE ON menu_items FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_restaurant_settings_updated_at BEFORE UPDATE ON restaurant_settings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- FUNCI√ìN: LIMPIAR CONVERSACIONES INACTIVAS
-- ============================================
CREATE OR REPLACE FUNCTION clean_inactive_conversations()
RETURNS INTEGER AS $$
DECLARE
    cleaned_count INTEGER;
BEGIN
    -- Marcar como abandonadas las conversaciones inactivas por m√°s de 2 horas
    UPDATE conversations 
    SET status = 'abandoned'
    WHERE status = 'active' 
    AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '2 hours';
    
    GET DIAGNOSTICS cleaned_count = ROW_COUNT;
    RETURN cleaned_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- COMENTARIOS DE DOCUMENTACI√ìN
-- ============================================

COMMENT ON TABLE restaurants IS 'Informaci√≥n de cada restaurante/tenant del sistema';
COMMENT ON TABLE menu_items IS 'Productos del men√∫ por restaurante';
COMMENT ON TABLE business_rules IS 'Reglas de negocio espec√≠ficas (aderezos, extras, combos)';
COMMENT ON TABLE conversations IS 'Sesiones de chat activas con estado del pedido';
COMMENT ON TABLE orders IS 'Pedidos completados';
COMMENT ON TABLE order_items IS 'Items espec√≠ficos de cada pedido con customizaciones';

COMMENT ON COLUMN business_rules.rule_config IS 'Configuraci√≥n JSON flexible para diferentes tipos de reglas';
COMMENT ON COLUMN conversations.order_data IS 'Estado actual del pedido en construcci√≥n (JSON)';
COMMENT ON COLUMN conversations.ai_context IS 'Historial de conversaci√≥n para Claude';
COMMENT ON COLUMN order_items.customizations IS 'Array JSON de personalizaciones del item';


================================================
File: database/migrations/001_initial_schema.sql
================================================
-- ============================================
-- CHATBOT CHING√ìN - MIGRACI√ìN INICIAL
-- Versi√≥n: 1.0.0
-- Fecha: 2024-12-19
-- ============================================

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- Para b√∫squedas de texto

-- ============================================
-- TABLA: RESTAURANTES (TENANTS)
-- ============================================
CREATE TABLE restaurants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL, -- hot-wings, minguela
    phone VARCHAR(20) UNIQUE NOT NULL, -- +525512345678
    email VARCHAR(255),
    address TEXT,
    logo_url VARCHAR(500),
    
    -- Configuraci√≥n de operaci√≥n
    is_active BOOLEAN DEFAULT true,
    opens_at TIME DEFAULT '09:00:00',
    closes_at TIME DEFAULT '23:00:00',
    delivery_time_min INTEGER DEFAULT 25, -- minutos m√≠nimos
    delivery_time_max INTEGER DEFAULT 35, -- minutos m√°ximos
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    minimum_order DECIMAL(8,2) DEFAULT 0.00,
    
    -- WhatsApp API Config
    whatsapp_phone_id VARCHAR(100), -- Para Meta WhatsApp API
    whatsapp_token VARCHAR(500),
    twilio_phone_number VARCHAR(20), -- Para Twilio
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CONSTRAINT restaurants_slug_format CHECK (slug ~ '^[a-z0-9-]+$')
);

-- ============================================
-- TABLA: ZONAS DE ENTREGA
-- ============================================
CREATE TABLE delivery_zones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    zone_name VARCHAR(100) NOT NULL, -- "Centro", "Zona Norte"
    postal_codes TEXT[], -- Array de c√≥digos postales
    neighborhoods TEXT[], -- Array de colonias
    extra_fee DECIMAL(8,2) DEFAULT 0.00, -- Costo extra por zona
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CATEGOR√çAS DE MEN√ö
-- ============================================
CREATE TABLE menu_categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- "Alitas", "Bebidas", "Hotdogs"
    description TEXT,
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    emoji VARCHAR(10), -- üçó, üç∫, üå≠
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(restaurant_id, name)
);

-- ============================================
-- TABLA: PRODUCTOS DEL MEN√ö
-- ============================================
CREATE TABLE menu_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES menu_categories(id) ON DELETE CASCADE,
    
    -- Informaci√≥n b√°sica
    name VARCHAR(255) NOT NULL, -- "Media orden de alitas"
    description TEXT, -- "6 piezas de alitas jugosas"
    price DECIMAL(8,2) NOT NULL,
    
    -- Configuraci√≥n de producto
    is_available BOOLEAN DEFAULT true,
    preparation_time INTEGER DEFAULT 15, -- minutos
    display_order INTEGER DEFAULT 0,
    
    -- Informaci√≥n nutricional (opcional)
    calories INTEGER,
    ingredients TEXT[],
    allergens TEXT[], -- "lacteos", "gluten"
    
    -- Imagen
    image_url VARCHAR(500),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: REGLAS DE NEGOCIO
-- ============================================
CREATE TABLE business_rules (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    menu_item_id UUID REFERENCES menu_items(id) ON DELETE CASCADE, -- NULL = regla global
    
    -- Tipo de regla
    rule_type VARCHAR(50) NOT NULL, -- "sauce_limit", "extra_cost", "combo_rule", "size_option"
    rule_name VARCHAR(100) NOT NULL, -- "Aderezos incluidos"
    
    -- Configuraci√≥n de la regla (JSON flexible)
    rule_config JSONB NOT NULL,
    /* Ejemplos:
    sauce_limit: {"max_included": 1, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri"]}
    size_option: {"sizes": [{"name": "Chica", "price": 60}, {"name": "Grande", "price": 90}]}
    combo_rule: {"required_items": 2, "discount_percent": 15}
    extra_cost: {"extras": [{"name": "Queso extra", "cost": 15}, {"name": "Tocino", "cost": 20}]}
    */
    
    -- Mensaje para la IA
    ai_message_template TEXT, -- "Este producto incluye {max_included} aderezo(s). Extra ${extra_cost} c/u"
    
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CLIENTES
-- ============================================
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    phone VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(255),
    
    -- Datos para entrega
    default_address TEXT,
    default_references TEXT,
    
    -- Stats
    total_orders INTEGER DEFAULT 0,
    total_spent DECIMAL(10,2) DEFAULT 0.00,
    
    -- Timestamps
    first_order_at TIMESTAMP,
    last_order_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONVERSACIONES ACTIVAS
-- ============================================
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_phone VARCHAR(20) NOT NULL,
    
    -- Estado de la conversaci√≥n
    status VARCHAR(20) DEFAULT 'active', -- active, completing_order, completed, abandoned
    current_step VARCHAR(50) DEFAULT 'greeting', -- greeting, ordering, address, confirming
    
    -- Datos del pedido en construcci√≥n
    order_data JSONB DEFAULT '{}',
    /* Estructura:
    {
        "items": [
            {
                "menu_item_id": "uuid",
                "name": "Media orden alitas BBQ",
                "quantity": 1,
                "base_price": 90,
                "customizations": [
                    {"type": "sauce", "name": "BBQ", "extra_cost": 0},
                    {"type": "sauce", "name": "Chimichurri", "extra_cost": 10}
                ],
                "item_total": 100,
                "notes": "Sin cebolla"
            }
        ],
        "subtotal": 100,
        "delivery_fee": 0,
        "total": 100,
        "delivery_address": {
            "street": "Calle Reforma",
            "number": "123",
            "neighborhood": "Centro",
            "references": "Entre 5 de Mayo y Hidalgo",
            "postal_code": "12345"
        }
    }
    */
    
    -- Contexto para Claude
    ai_context JSONB DEFAULT '[]', -- Historial de mensajes
    conversation_summary TEXT, -- Resumen generado por IA
    
    -- Timestamps
    last_interaction_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: PEDIDOS COMPLETADOS
-- ============================================
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    customer_id UUID REFERENCES customers(id),
    conversation_id UUID REFERENCES conversations(id),
    
    -- Informaci√≥n del cliente
    customer_phone VARCHAR(20) NOT NULL,
    customer_name VARCHAR(255),
    
    -- Direcci√≥n de entrega
    delivery_street VARCHAR(255) NOT NULL,
    delivery_number VARCHAR(50) NOT NULL,
    delivery_neighborhood VARCHAR(255) NOT NULL,
    delivery_references TEXT,
    delivery_postal_code VARCHAR(10),
    
    -- Estado del pedido
    status VARCHAR(20) DEFAULT 'confirmed', -- confirmed, preparing, ready, delivered, cancelled
    
    -- Montos
    subtotal DECIMAL(8,2) NOT NULL,
    delivery_fee DECIMAL(8,2) DEFAULT 0.00,
    total DECIMAL(8,2) NOT NULL,
    
    -- Tiempos
    estimated_delivery_time INTEGER, -- minutos
    confirmed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    delivered_at TIMESTAMP,
    
    -- Notas
    special_instructions TEXT,
    internal_notes TEXT, -- Para el restaurante
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: ITEMS DE PEDIDOS
-- ============================================
CREATE TABLE order_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    menu_item_id UUID NOT NULL REFERENCES menu_items(id),
    
    -- Informaci√≥n del producto al momento del pedido
    item_name VARCHAR(255) NOT NULL, -- Snapshot del nombre
    base_price DECIMAL(8,2) NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    
    -- Personalizaciones
    customizations JSONB DEFAULT '[]',
    /* Ejemplo:
    [
        {"type": "sauce", "name": "BBQ", "extra_cost": 0},
        {"type": "sauce", "name": "Chimichurri", "extra_cost": 10},
        {"type": "extra", "name": "Queso extra", "extra_cost": 15}
    ]
    */
    
    customizations_cost DECIMAL(8,2) DEFAULT 0.00,
    item_total DECIMAL(8,2) NOT NULL, -- (base_price + customizations_cost) * quantity
    
    special_notes TEXT, -- "Sin cebolla", "Bien cocidas"
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: CONFIGURACIONES DEL RESTAURANTE
-- ============================================
CREATE TABLE restaurant_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    restaurant_id UUID UNIQUE NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
    
    -- Configuraci√≥n de Claude
    claude_api_key VARCHAR(500),
    claude_model VARCHAR(50) DEFAULT 'claude-3-5-sonnet-20241022',
    ai_personality TEXT DEFAULT 'Amigable y servicial',
    
    -- Mensajes predefinidos
    welcome_message TEXT DEFAULT '¬°Hola! Bienvenido a nuestro restaurante üç¥',
    goodbye_message TEXT DEFAULT '¬°Gracias por tu pedido! Te esperamos pronto üòä',
    error_message TEXT DEFAULT 'Lo siento, tuve un problema. ¬øPuedes repetir tu mensaje?',
    
    -- Configuraci√≥n de negocio
    auto_confirm_orders BOOLEAN DEFAULT false,
    require_phone_validation BOOLEAN DEFAULT false,
    max_conversation_time INTEGER DEFAULT 1800, -- 30 minutos
    
    -- Notificaciones
    notification_email VARCHAR(255),
    notification_phone VARCHAR(20),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- √çNDICES PARA OPTIMIZACI√ìN
-- ============================================

-- √çndices principales para queries frecuentes
CREATE INDEX idx_restaurants_slug ON restaurants(slug);
CREATE INDEX idx_restaurants_phone ON restaurants(phone);
CREATE INDEX idx_restaurants_active ON restaurants(is_active) WHERE is_active = true;

CREATE INDEX idx_menu_items_restaurant ON menu_items(restaurant_id, is_available) WHERE is_available = true;
CREATE INDEX idx_menu_items_category ON menu_items(category_id, display_order);

CREATE INDEX idx_business_rules_item ON business_rules(menu_item_id, rule_type) WHERE is_active = true;
CREATE INDEX idx_business_rules_restaurant ON business_rules(restaurant_id, rule_type) WHERE is_active = true;

CREATE INDEX idx_conversations_active ON conversations(restaurant_id, customer_phone, status) WHERE status = 'active';
CREATE INDEX idx_conversations_last_interaction ON conversations(last_interaction_at) WHERE status = 'active';

CREATE INDEX idx_orders_restaurant_status ON orders(restaurant_id, status, created_at);
CREATE INDEX idx_orders_customer ON orders(customer_phone, created_at);
CREATE INDEX idx_orders_date ON orders(created_at);

CREATE INDEX idx_order_items_order ON order_items(order_id);

-- √çndices para b√∫squedas de texto
CREATE INDEX idx_menu_items_name_trgm ON menu_items USING gin(name gin_trgm_ops);
CREATE INDEX idx_customers_phone ON customers(phone);

-- ============================================
-- TRIGGERS PARA UPDATED_AT
-- ============================================

-- Funci√≥n para actualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers
CREATE TRIGGER update_restaurants_updated_at BEFORE UPDATE ON restaurants FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_menu_items_updated_at BEFORE UPDATE ON menu_items FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_restaurant_settings_updated_at BEFORE UPDATE ON restaurant_settings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- FUNCI√ìN: LIMPIAR CONVERSACIONES INACTIVAS
-- ============================================
CREATE OR REPLACE FUNCTION clean_inactive_conversations()
RETURNS INTEGER AS $$
DECLARE
    cleaned_count INTEGER;
BEGIN
    -- Marcar como abandonadas las conversaciones inactivas por m√°s de 2 horas
    UPDATE conversations 
    SET status = 'abandoned'
    WHERE status = 'active' 
    AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '2 hours';
    
    GET DIAGNOSTICS cleaned_count = ROW_COUNT;
    RETURN cleaned_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- COMENTARIOS DE DOCUMENTACI√ìN
-- ============================================

COMMENT ON TABLE restaurants IS 'Informaci√≥n de cada restaurante/tenant del sistema';
COMMENT ON TABLE menu_items IS 'Productos del men√∫ por restaurante';
COMMENT ON TABLE business_rules IS 'Reglas de negocio espec√≠ficas (aderezos, extras, combos)';
COMMENT ON TABLE conversations IS 'Sesiones de chat activas con estado del pedido';
COMMENT ON TABLE orders IS 'Pedidos completados';
COMMENT ON TABLE order_items IS 'Items espec√≠ficos de cada pedido con customizaciones';

COMMENT ON COLUMN business_rules.rule_config IS 'Configuraci√≥n JSON flexible para diferentes tipos de reglas';
COMMENT ON COLUMN conversations.order_data IS 'Estado actual del pedido en construcci√≥n (JSON)';
COMMENT ON COLUMN conversations.ai_context IS 'Historial de conversaci√≥n para Claude';
COMMENT ON COLUMN order_items.customizations IS 'Array JSON de personalizaciones del item';

-- ============================================
-- DATOS DE EJEMPLO PARA DESARROLLO
-- ============================================

-- Insertar restaurante de ejemplo
INSERT INTO restaurants (
    id, name, slug, phone, email, address,
    opens_at, closes_at, delivery_time_min, delivery_time_max
) VALUES (
    '550e8400-e29b-41d4-a716-446655440000',
    'Hot Wings Express',
    'hot-wings-express',
    '+525512345678',
    'info@hotwings.com',
    'Av. Insurgentes Sur 123, Col. Roma Norte, CDMX',
    '10:00:00',
    '23:00:00',
    25,
    35
);

-- Insertar configuraci√≥n del restaurante de ejemplo
INSERT INTO restaurant_settings (
    id, restaurant_id, ai_personality, welcome_message, goodbye_message
) VALUES (
    '660e8400-e29b-41d4-a716-446655440000',
    '550e8400-e29b-41d4-a716-446655440000',
    'Amigable, r√°pido y conocedor de alitas',
    '¬°Hola! üëã Bienvenido a Hot Wings Express. ¬øListo para unas alitas deliciosas?',
    '¬°Gracias por tu pedido! üçó Tu comida llegar√° pronto. ¬°Disfr√∫tala!'
);

-- Insertar categor√≠as de ejemplo
INSERT INTO menu_categories (
    id, restaurant_id, name, description, display_order, emoji
) VALUES 
    ('770e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440000', 'Alitas', 'Nuestras deliciosas alitas en diferentes sabores', 1, 'üçó'),
    ('770e8400-e29b-41d4-a716-446655440001', '550e8400-e29b-41d4-a716-446655440000', 'Bebidas', 'Refrescantes bebidas para acompa√±ar', 2, 'ü•§'),
    ('770e8400-e29b-41d4-a716-446655440002', '550e8400-e29b-41d4-a716-446655440000', 'Hotdogs', 'Hotdogs gourmet', 3, 'üå≠');

-- Insertar items de men√∫ de ejemplo
INSERT INTO menu_items (
    id, restaurant_id, category_id, name, description, price, preparation_time
) VALUES 
    ('880e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440000', 'Media Orden de Alitas', '6 piezas de alitas jugosas', 85.00, 15),
    ('880e8400-e29b-41d4-a716-446655440001', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440000', 'Orden Completa de Alitas', '12 piezas de alitas jugosas', 130.00, 18),
    ('880e8400-e29b-41d4-a716-446655440002', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440001', 'Refresco Grande', 'Coca Cola, Sprite o Fanta', 25.00, 2),
    ('880e8400-e29b-41d4-a716-446655440003', '550e8400-e29b-41d4-a716-446655440000', '770e8400-e29b-41d4-a716-446655440002', 'Hotdog Cl√°sico', 'Con mostaza, catsup y mayonesa', 45.00, 8);

-- Insertar reglas de negocio de ejemplo
INSERT INTO business_rules (
    id, restaurant_id, menu_item_id, rule_type, rule_name, rule_config, ai_message_template
) VALUES 
    ('990e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440000', '880e8400-e29b-41d4-a716-446655440000', 'sauce_limit', 'Aderezos Media Orden', '{"max_included": 1, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri", "Mango Habanero"]}', 'La media orden incluye 1 aderezo gratis. Aderezos extra $10 c/u'),
    ('990e8400-e29b-41d4-a716-446655440001', '550e8400-e29b-41d4-a716-446655440000', '880e8400-e29b-41d4-a716-446655440001', 'sauce_limit', 'Aderezos Orden Completa', '{"max_included": 2, "extra_cost": 10, "available_sauces": ["BBQ", "Buffalo", "Chimichurri", "Mango Habanero"]}', 'La orden completa incluye 2 aderezos gratis. Aderezos extra $10 c/u');

-- ============================================
-- VERIFICACI√ìN DE INSTALACI√ìN
-- ============================================

-- Funci√≥n para verificar que todo se instal√≥ correctamente
CREATE OR REPLACE FUNCTION verify_installation()
RETURNS TEXT AS $$
DECLARE
    table_count INTEGER;
    index_count INTEGER;
    function_count INTEGER;
BEGIN
    -- Contar tablas creadas
    SELECT COUNT(*) INTO table_count
    FROM information_schema.tables 
    WHERE table_schema = 'public' 
    AND table_name IN ('restaurants', 'delivery_zones', 'menu_categories', 'menu_items', 'business_rules', 'customers', 'conversations', 'orders', 'order_items', 'restaurant_settings');
    
    -- Contar √≠ndices creados
    SELECT COUNT(*) INTO index_count
    FROM pg_indexes 
    WHERE schemaname = 'public'
    AND indexname LIKE 'idx_%';
    
    -- Contar funciones creadas
    SELECT COUNT(*) INTO function_count
    FROM information_schema.routines
    WHERE routine_schema = 'public'
    AND routine_name IN ('update_updated_at_column', 'clean_inactive_conversations', 'verify_installation');
    
    RETURN FORMAT('‚úÖ Instalaci√≥n completada: %s tablas, %s √≠ndices, %s funciones creadas', table_count, index_count, function_count);
END;
$$ LANGUAGE plpgsql;

-- Ejecutar verificaci√≥n
SELECT verify_installation();


================================================
File: database/migrations/002_users_and_roles.sql
================================================
-- ============================================
-- MIGRACI√ìN: SISTEMA DE USUARIOS Y ROLES
-- Archivo: database/migrations/002_users_and_roles.sql
-- ============================================

-- Extensi√≥n para UUID si no existe
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- TABLA: ROLES
-- ============================================
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) UNIQUE NOT NULL, -- 'super_admin', 'admin', 'manager', 'staff'
    display_name VARCHAR(100) NOT NULL, -- 'Super Administrador', 'Administrador', etc.
    description TEXT,
    permissions JSONB DEFAULT '[]', -- Array de permisos espec√≠ficos
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: USUARIOS
-- ============================================
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    
    -- Relaciones
    role_id UUID NOT NULL REFERENCES roles(id),
    restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE, -- NULL para super_admin
    
    -- Estado del usuario
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    last_login_at TIMESTAMP,
    
    -- Tokens y seguridad
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,
    email_verification_token VARCHAR(255),
    
    -- Metadatos
    created_by UUID REFERENCES users(id), -- Quien cre√≥ este usuario
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: PERFILES DE USUARIO
-- ============================================
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Informaci√≥n personal
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(20),
    avatar_url VARCHAR(500),
    
    -- Configuraciones
    language VARCHAR(5) DEFAULT 'es',
    timezone VARCHAR(50) DEFAULT 'America/Mexico_City',
    notifications_enabled BOOLEAN DEFAULT true,
    
    -- Metadatos
    last_profile_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- TABLA: SESIONES DE USUARIO (Opcional - para tracking)
-- ============================================
CREATE TABLE user_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Informaci√≥n de sesi√≥n
    token_id VARCHAR(255) NOT NULL, -- ID del JWT token
    ip_address INET,
    user_agent TEXT,
    
    -- Estado
    is_active BOOLEAN DEFAULT true,
    expires_at TIMESTAMP NOT NULL,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- √çNDICES PARA OPTIMIZACI√ìN
-- ============================================

-- Usuarios
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role_id);
CREATE INDEX idx_users_restaurant ON users(restaurant_id) WHERE restaurant_id IS NOT NULL;
CREATE INDEX idx_users_active ON users(is_active) WHERE is_active = true;

-- Perfiles
CREATE INDEX idx_profiles_user ON user_profiles(user_id);
CREATE INDEX idx_profiles_names ON user_profiles(first_name, last_name);

-- Sesiones
CREATE INDEX idx_sessions_user ON user_sessions(user_id);
CREATE INDEX idx_sessions_token ON user_sessions(token_id);
CREATE INDEX idx_sessions_active ON user_sessions(is_active, expires_at) WHERE is_active = true;

-- ============================================
-- TRIGGERS PARA UPDATED_AT
-- ============================================

CREATE TRIGGER update_roles_updated_at
    BEFORE UPDATE ON roles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_profiles_updated_at
    BEFORE UPDATE ON user_profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- INSERTAR ROLES PREDETERMINADOS
-- ============================================

INSERT INTO roles (id, name, display_name, description, permissions) VALUES
(
    '11111111-1111-1111-1111-111111111111',
    'super_admin',
    'Super Administrador',
    'Acceso completo al sistema. Puede gestionar todos los restaurantes y usuarios.',
    '["all"]'
),
(
    '22222222-2222-2222-2222-222222222222',
    'admin',
    'Administrador de Restaurante',
    'Administrador completo de un restaurante espec√≠fico. Puede gestionar men√∫s, pedidos, usuarios del restaurante.',
    '["restaurant.manage", "menu.manage", "orders.manage", "users.manage_restaurant", "reports.view"]'
),
(
    '33333333-3333-3333-3333-333333333333',
    'manager',
    'Gerente',
    'Gerente de restaurante. Puede gestionar operaciones diarias, men√∫s y empleados.',
    '["menu.manage", "orders.manage", "users.manage_staff", "reports.view"]'
),
(
    '44444444-4444-4444-4444-444444444444',
    'staff',
    'Empleado',
    'Personal del restaurante. Puede ver y actualizar pedidos, cambiar disponibilidad de productos.',
    '["orders.view", "orders.update_status", "menu.update_availability"]'
);

-- ============================================
-- CREAR SUPER USUARIO INICIAL
-- ============================================

-- Insertar super usuario (cambiar email y contrase√±a)
INSERT INTO users (
    id, 
    email, 
    password_hash, 
    role_id, 
    restaurant_id, 
    is_active, 
    email_verified
) VALUES (
    '00000000-0000-0000-0000-000000000000',
    'admin@chatbot-chingon.com', -- CAMBIAR POR TU EMAIL
    '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', -- password123 - CAMBIAR
    '11111111-1111-1111-1111-111111111111', -- super_admin role
    NULL, -- Sin restaurante espec√≠fico
    true,
    true
);

-- Insertar perfil del super usuario
INSERT INTO user_profiles (
    user_id,
    first_name,
    last_name,
    phone
) VALUES (
    '00000000-0000-0000-0000-000000000000',
    'Super',
    'Administrador',
    '+52XXXXXXXXXX' -- CAMBIAR POR TU TEL√âFONO
);

-- ============================================
-- FUNCIONES DE UTILIDAD
-- ============================================

-- Funci√≥n para limpiar sesiones expiradas
CREATE OR REPLACE FUNCTION clean_expired_sessions()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM user_sessions 
    WHERE expires_at < CURRENT_TIMESTAMP 
    OR is_active = false;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Funci√≥n para verificar permisos de usuario
CREATE OR REPLACE FUNCTION user_has_permission(user_uuid UUID, required_permission TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    user_permissions JSONB;
    has_permission BOOLEAN := false;
BEGIN
    -- Obtener permisos del usuario
    SELECT r.permissions INTO user_permissions
    FROM users u
    JOIN roles r ON u.role_id = r.id
    WHERE u.id = user_uuid AND u.is_active = true;
    
    -- Si no se encuentra el usuario
    IF user_permissions IS NULL THEN
        RETURN false;
    END IF;
    
    -- Si tiene permiso "all" (super admin)
    IF user_permissions ? 'all' THEN
        RETURN true;
    END IF;
    
    -- Verificar permiso espec√≠fico
    IF user_permissions ? required_permission THEN
        RETURN true;
    END IF;
    
    RETURN false;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- VERIFICACI√ìN DE INSTALACI√ìN
-- ============================================

-- Funci√≥n para verificar la instalaci√≥n de usuarios
CREATE OR REPLACE FUNCTION verify_users_installation()
RETURNS TEXT AS $$
DECLARE
    roles_count INTEGER;
    users_count INTEGER;
    profiles_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO roles_count FROM roles;
    SELECT COUNT(*) INTO users_count FROM users;
    SELECT COUNT(*) INTO profiles_count FROM user_profiles;
    
    RETURN FORMAT('‚úÖ Sistema de usuarios instalado: %s roles, %s usuarios, %s perfiles', 
                  roles_count, users_count, profiles_count);
END;
$$ LANGUAGE plpgsql;

-- Ejecutar verificaci√≥n
SELECT verify_users_installation();


================================================
File: database/queries/conversations.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { CONVERSATION_STATUS, CONVERSATION_STEPS } = require('../../src/utils/constants');

// ============================================
// CONSULTAS OPTIMIZADAS PARA CONVERSACIONES
// ============================================

/**
 * Obtiene conversaci√≥n activa por restaurante y tel√©fono
 * @param {string} restaurantId - ID del restaurante
 * @param {string} customerPhone - Tel√©fono del cliente
 * @returns {Promise<Object|null>} Conversaci√≥n activa
 */
const getActiveConversation = async (restaurantId, customerPhone) => {
  try {
    const result = await query(
      `SELECT 
        c.*,
        EXTRACT(EPOCH FROM (NOW() - c.last_interaction_at)) as seconds_since_last_interaction
      FROM conversations c 
      WHERE c.restaurant_id = $1 
        AND c.customer_phone = $2 
        AND c.status = $3
        AND c.last_interaction_at > NOW() - INTERVAL '30 minutes'
      ORDER BY c.last_interaction_at DESC
      LIMIT 1`,
      [restaurantId, customerPhone, CONVERSATION_STATUS.ACTIVE],
      'get_active_conversation'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error obteniendo conversaci√≥n activa:', error);
    throw error;
  }
};

/**
 * Crea nueva conversaci√≥n
 * @param {Object} conversationData - Datos de la conversaci√≥n
 * @returns {Promise<Object>} Conversaci√≥n creada
 */
const createConversation = async (conversationData) => {
  const {
    restaurantId,
    customerPhone,
    status = CONVERSATION_STATUS.ACTIVE,
    currentStep = CONVERSATION_STEPS.GREETING,
    orderData = {},
    aiContext = []
  } = conversationData;

  try {
    const result = await query(
      `INSERT INTO conversations (
        restaurant_id, customer_phone, status, current_step, 
        order_data, ai_context, created_at, last_interaction_at
      ) VALUES ($1, $2, $3, $4, $5::jsonb, $6::jsonb, NOW(), NOW())
      RETURNING *`,
      [
        restaurantId,
        customerPhone,
        status,
        currentStep,
        JSON.stringify(orderData),
        JSON.stringify(aiContext)
      ],
      'create_conversation'
    );

    logger.info('Nueva conversaci√≥n creada', {
      conversationId: result.rows[0].id,
      restaurantId,
      customerPhone: customerPhone.substring(0, 8) + '****'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando conversaci√≥n:', error);
    throw error;
  }
};

/**
 * Actualiza conversaci√≥n existente
 * @param {string} conversationId - ID de la conversaci√≥n
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Conversaci√≥n actualizada
 */
const updateConversation = async (conversationId, updateData) => {
  const allowedFields = [
    'status', 'current_step', 'order_data', 'ai_context', 
    'conversation_summary', 'last_interaction_at'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      let value = updateData[key];
      
      // Serializar objetos/arrays a JSON
      if (['order_data', 'ai_context'].includes(key)) {
        value = JSON.stringify(value);
        fields.push(`${key} = $${paramCount}::jsonb`);
      } else if (key === 'last_interaction_at') {
        fields.push(`${key} = NOW()`);
        return; // No agregar a values ya que usamos NOW()
      } else {
        fields.push(`${key} = $${paramCount}`);
      }
      
      values.push(value);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos v√°lidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE conversations 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, conversationId],
      'update_conversation'
    );

    if (result.rows.length === 0) {
      throw new Error('Conversaci√≥n no encontrada');
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando conversaci√≥n:', error);
    throw error;
  }
};

/**
 * Agrega mensaje al contexto de IA
 * @param {string} conversationId - ID de la conversaci√≥n
 * @param {string} role - Rol del mensaje (user, assistant, system)
 * @param {string} content - Contenido del mensaje
 * @returns {Promise<Object>} Conversaci√≥n actualizada
 */
const addToAiContext = async (conversationId, role, content) => {
  try {
    const result = await query(
      `UPDATE conversations 
       SET ai_context = COALESCE(ai_context, '[]'::jsonb) || $1::jsonb,
           last_interaction_at = NOW(),
           updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [
        JSON.stringify([{ role, content, timestamp: new Date().toISOString() }]),
        conversationId
      ],
      'add_to_ai_context'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error agregando al contexto de IA:', error);
    throw error;
  }
};

/**
 * Obtiene conversaciones con paginaci√≥n y filtros
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Object>} Lista paginada de conversaciones
 */
const getConversationsPaginated = async (restaurantId, options = {}) => {
  const {
    page = 1,
    limit = 20,
    status = null,
    step = null,
    customerPhone = null,
    sortBy = 'last_interaction_at',
    sortOrder = 'DESC',
    dateFrom = null,
    dateTo = null
  } = options;

  const offset = (page - 1) * limit;
  const conditions = ['c.restaurant_id = $1'];
  const values = [restaurantId];
  let paramCount = 2;

  // Agregar filtros
  if (status) {
    conditions.push(`c.status = $${paramCount}`);
    values.push(status);
    paramCount++;
  }

  if (step) {
    conditions.push(`c.current_step = $${paramCount}`);
    values.push(step);
    paramCount++;
  }

  if (customerPhone) {
    conditions.push(`c.customer_phone = $${paramCount}`);
    values.push(customerPhone);
    paramCount++;
  }

  if (dateFrom) {
    conditions.push(`c.created_at >= $${paramCount}`);
    values.push(dateFrom);
    paramCount++;
  }

  if (dateTo) {
    conditions.push(`c.created_at <= $${paramCount}`);
    values.push(dateTo);
    paramCount++;
  }

  const whereClause = conditions.join(' AND ');
  const orderBy = `ORDER BY c.${sortBy} ${sortOrder}`;

  try {
    // Consulta principal
    const conversationsResult = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.order_data::text != '{}' THEN 
            (c.order_data->>'total')::numeric 
          ELSE 0 
        END as order_total,
        EXTRACT(EPOCH FROM (NOW() - c.last_interaction_at))/60 as minutes_since_last_interaction,
        jsonb_array_length(COALESCE(c.ai_context, '[]'::jsonb)) as message_count
      FROM conversations c 
      WHERE ${whereClause}
      ${orderBy}
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_conversations_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM conversations c WHERE ${whereClause}`,
      values.slice(0, -2), // Remover limit y offset
      'count_conversations'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      conversations: conversationsResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo conversaciones paginadas:', error);
    throw error;
  }
};

/**
 * Obtiene estad√≠sticas de conversaciones para un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} Estad√≠sticas
 */
const getConversationStats = async (restaurantId, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = ['restaurant_id = $1'];
  const values = [restaurantId];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $2 AND $3');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.join(' AND ');

  try {
    const result = await query(
      `SELECT 
        COUNT(*) as total_conversations,
        COUNT(CASE WHEN status = '${CONVERSATION_STATUS.ACTIVE}' THEN 1 END) as active_conversations,
        COUNT(CASE WHEN status = '${CONVERSATION_STATUS.COMPLETED}' THEN 1 END) as completed_conversations,
        COUNT(CASE WHEN status = '${CONVERSATION_STATUS.ABANDONED}' THEN 1 END) as abandoned_conversations,
        
        -- Por pasos
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.GREETING}' THEN 1 END) as greeting_step,
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.ORDERING}' THEN 1 END) as ordering_step,
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.ADDRESS}' THEN 1 END) as address_step,
        COUNT(CASE WHEN current_step = '${CONVERSATION_STEPS.CONFIRMING}' THEN 1 END) as confirming_step,
        
        -- M√©tricas de tiempo
        AVG(EXTRACT(EPOCH FROM (
          COALESCE(updated_at, NOW()) - created_at
        ))/60) as avg_duration_minutes,
        
        -- Conversiones
        ROUND(
          (COUNT(CASE WHEN status = '${CONVERSATION_STATUS.COMPLETED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as conversion_rate,
        
        -- Abandono
        ROUND(
          (COUNT(CASE WHEN status = '${CONVERSATION_STATUS.ABANDONED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as abandonment_rate
        
      FROM conversations 
      WHERE ${whereClause}`,
      values,
      'get_conversation_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estad√≠sticas de conversaciones:', error);
    throw error;
  }
};

/**
 * Limpia conversaciones inactivas
 * @param {number} hoursInactive - Horas de inactividad para considerar abandono
 * @returns {Promise<number>} N√∫mero de conversaciones limpiadas
 */
const cleanInactiveConversations = async (hoursInactive = 2) => {
  try {
    const result = await query(
      `UPDATE conversations 
       SET status = $1, 
           conversation_summary = 'Conversaci√≥n abandonada por inactividad',
           updated_at = NOW()
       WHERE status = $2 
         AND last_interaction_at < NOW() - INTERVAL '${hoursInactive} hours'
       RETURNING id`,
      [CONVERSATION_STATUS.ABANDONED, CONVERSATION_STATUS.ACTIVE],
      'clean_inactive_conversations'
    );

    const cleanedCount = result.rows.length;
    
    if (cleanedCount > 0) {
      logger.info(`Conversaciones inactivas limpiadas: ${cleanedCount}`);
    }

    return cleanedCount;
  } catch (error) {
    logger.error('Error limpiando conversaciones inactivas:', error);
    throw error;
  }
};

/**
 * Busca conversaciones por texto
 * @param {string} restaurantId - ID del restaurante
 * @param {string} searchTerm - T√©rmino de b√∫squeda
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Conversaciones encontradas
 */
const searchConversations = async (restaurantId, searchTerm, options = {}) => {
  const { limit = 50 } = options;

  try {
    const result = await query(
      `SELECT 
        c.*,
        ts_rank(
          to_tsvector('spanish', 
            COALESCE(c.conversation_summary, '') || ' ' ||
            COALESCE(c.ai_context::text, '')
          ),
          plainto_tsquery('spanish', $2)
        ) as relevance
      FROM conversations c
      WHERE c.restaurant_id = $1
        AND (
          c.customer_phone ILIKE $3
          OR c.conversation_summary ILIKE $3
          OR c.ai_context::text ILIKE $3
        )
      ORDER BY relevance DESC, c.last_interaction_at DESC
      LIMIT $4`,
      [
        restaurantId,
        searchTerm,
        `%${searchTerm}%`,
        limit
      ],
      'search_conversations'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando conversaciones:', error);
    throw error;
  }
};

/**
 * Obtiene conversaciones por cliente
 * @param {string} customerPhone - Tel√©fono del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Historial del cliente
 */
const getCustomerConversationHistory = async (customerPhone, restaurantId = null, options = {}) => {
  const { limit = 10, includeActive = true } = options;
  
  const conditions = ['customer_phone = $1'];
  const values = [customerPhone];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  if (!includeActive) {
    conditions.push(`status != $${paramCount}`);
    values.push(CONVERSATION_STATUS.ACTIVE);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        c.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        CASE 
          WHEN c.order_data::text != '{}' THEN 
            (c.order_data->>'total')::numeric 
          ELSE 0 
        END as order_total
      FROM conversations c
      JOIN restaurants r ON c.restaurant_id = r.id
      WHERE ${conditions.join(' AND ')}
      ORDER BY c.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_conversation_history'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo historial de conversaciones del cliente:', error);
    throw error;
  }
};

module.exports = {
  getActiveConversation,
  createConversation,
  updateConversation,
  addToAiContext,
  getConversationsPaginated,
  getConversationStats,
  cleanInactiveConversations,
  searchConversations,
  getCustomerConversationHistory
};


================================================
File: database/queries/customers.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');

// ============================================
// CONSULTAS OPTIMIZADAS PARA CLIENTES
// ============================================

/**
 * Busca cliente por tel√©fono
 * @param {string} phone - N√∫mero de tel√©fono
 * @returns {Promise<Object|null>} Cliente encontrado
 */
const findByPhone = async (phone) => {
  try {
    const result = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN c.total_spent / c.total_orders 
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))
          ELSE NULL
        END as days_since_last_order
      FROM customers c 
      WHERE c.phone = $1`,
      [phone],
      'find_customer_by_phone'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando cliente por tel√©fono:', error);
    throw error;
  }
};

/**
 * Crea un nuevo cliente
 * @param {Object} customerData - Datos del cliente
 * @returns {Promise<Object>} Cliente creado
 */
const createCustomer = async (customerData) => {
  const {
    phone,
    name = null,
    defaultAddress = null,
    defaultReferences = null
  } = customerData;

  try {
    const result = await query(
      `INSERT INTO customers (
        id, phone, name, default_address, default_references, created_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())
      RETURNING *`,
      [
        uuidv4(),
        phone,
        name,
        defaultAddress,
        defaultReferences
      ],
      'create_customer'
    );

    logger.info('Nuevo cliente creado', {
      customerId: result.rows[0].id,
      phone: phone.substring(0, 8) + '****'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando cliente:', error);
    throw error;
  }
};

/**
 * Encuentra cliente existente o crea uno nuevo
 * @param {string} phone - N√∫mero de tel√©fono
 * @param {Object} additionalData - Datos adicionales si se crea
 * @returns {Promise<Object>} Cliente existente o nuevo
 */
const findOrCreate = async (phone, additionalData = {}) => {
  try {
    // Primero buscar cliente existente
    let customer = await findByPhone(phone);
    
    if (customer) {
      return customer;
    }

    // Si no existe, crear uno nuevo
    return await createCustomer({ phone, ...additionalData });
  } catch (error) {
    logger.error('Error en findOrCreate cliente:', error);
    throw error;
  }
};

/**
 * Actualiza datos del cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateCustomer = async (customerId, updateData) => {
  const allowedFields = [
    'name', 'default_address', 'default_references'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      fields.push(`${key} = $${paramCount}`);
      values.push(updateData[key]);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos v√°lidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE customers 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, customerId],
      'update_customer'
    );

    if (result.rows.length === 0) {
      throw new Error('Cliente no encontrado');
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando cliente:', error);
    throw error;
  }
};

/**
 * Actualiza estad√≠sticas del cliente tras un pedido
 * @param {string} customerId - ID del cliente
 * @param {number} orderTotal - Total del pedido
 * @param {boolean} isFirstOrder - Si es el primer pedido
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateOrderStats = async (customerId, orderTotal, isFirstOrder = false) => {
  try {
    const result = await query(
      `UPDATE customers 
       SET total_orders = total_orders + 1,
           total_spent = total_spent + $2,
           last_order_at = NOW(),
           first_order_at = CASE 
             WHEN $3 THEN NOW() 
             ELSE first_order_at 
           END
       WHERE id = $1
       RETURNING *`,
      [customerId, orderTotal, isFirstOrder],
      'update_customer_order_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estad√≠sticas del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene lista de clientes con paginaci√≥n
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Object>} Lista paginada de clientes
 */
const getCustomersPaginated = async (options = {}) => {
  const {
    page = 1,
    limit = 20,
    search = '',
    sortBy = 'last_order_at',
    sortOrder = 'DESC',
    minOrders = null,
    minSpent = null
  } = options;

  const offset = (page - 1) * limit;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  // Filtro de b√∫squeda
  if (search) {
    conditions.push(`(c.phone ILIKE $${paramCount} OR c.name ILIKE $${paramCount})`);
    values.push(`%${search}%`);
    paramCount++;
  }

  // Filtro por n√∫mero m√≠nimo de pedidos
  if (minOrders !== null) {
    conditions.push(`c.total_orders >= $${paramCount}`);
    values.push(minOrders);
    paramCount++;
  }

  // Filtro por gasto m√≠nimo
  if (minSpent !== null) {
    conditions.push(`c.total_spent >= $${paramCount}`);
    values.push(minSpent);
    paramCount++;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    // Consulta principal con m√©tricas calculadas
    const customersResult = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order,
        CASE
          WHEN c.first_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.first_order_at))::integer
          ELSE NULL
        END as customer_lifetime_days,
        -- Clasificaci√≥n del cliente
        CASE
          WHEN c.total_orders = 0 THEN 'new'
          WHEN c.total_orders = 1 THEN 'first_time'
          WHEN c.total_orders BETWEEN 2 AND 5 THEN 'occasional'
          WHEN c.total_orders BETWEEN 6 AND 15 THEN 'regular'
          ELSE 'loyal'
        END as customer_segment
      FROM customers c 
      ${whereClause}
      ORDER BY c.${sortBy} ${sortOrder} NULLS LAST
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_customers_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM customers c ${whereClause}`,
      values,
      'count_customers'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      customers: customersResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo clientes paginados:', error);
    throw error;
  }
};

/**
 * Obtiene estad√≠sticas generales de clientes
 * @param {Object} dateRange - Rango de fechas opcional
 * @returns {Promise<Object>} Estad√≠sticas de clientes
 */
const getCustomerStats = async (dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $1 AND $2');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders = 0 THEN 1 END) as new_customers,
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as first_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 5 THEN 1 END) as occasional_customers,
        COUNT(CASE WHEN total_orders BETWEEN 6 AND 15 THEN 1 END) as regular_customers,
        COUNT(CASE WHEN total_orders > 15 THEN 1 END) as loyal_customers,
        
        -- M√©tricas de valor
        COALESCE(AVG(total_spent), 0) as avg_customer_value,
        COALESCE(AVG(CASE WHEN total_orders > 0 THEN total_spent / total_orders END), 0) as avg_order_value,
        COALESCE(AVG(total_orders), 0) as avg_orders_per_customer,
        
        -- M√©tricas de tiempo
        COALESCE(AVG(CASE 
          WHEN last_order_at IS NOT NULL THEN 
            EXTRACT(DAYS FROM (NOW() - last_order_at))
        END), 0) as avg_days_since_last_order,
        
        -- Distribuci√≥n geogr√°fica b√°sica (por c√≥digos de √°rea)
        jsonb_object_agg(
          phone_area,
          area_count
        ) as phone_area_distribution
        
      FROM customers c
      LEFT JOIN (
        SELECT 
          SUBSTRING(phone FROM 1 FOR 5) as phone_area,
          COUNT(*) as area_count
        FROM customers
        ${whereClause}
        GROUP BY SUBSTRING(phone FROM 1 FOR 5)
      ) areas ON true
      ${whereClause}`,
      values,
      'get_customer_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estad√≠sticas de clientes:', error);
    throw error;
  }
};

/**
 * Obtiene clientes top por valor gastado
 * @param {number} limit - Cantidad de clientes top a obtener
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @returns {Promise<Array>} Lista de clientes top
 */
const getTopCustomersByValue = async (limit = 10, restaurantId = null) => {
  try {
    let query_text = `
      SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order
      FROM customers c`;

    const values = [limit];

    if (restaurantId) {
      query_text += `
        WHERE c.id IN (
          SELECT DISTINCT o.customer_id 
          FROM orders o 
          WHERE o.restaurant_id = $2 AND o.customer_id IS NOT NULL
        )`;
      values.push(restaurantId);
    }

    query_text += `
      ORDER BY c.total_spent DESC, c.total_orders DESC
      LIMIT $1`;

    const result = await query(query_text, values, 'get_top_customers_by_value');

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo clientes top por valor:', error);
    throw error;
  }
};

/**
 * Obtiene historial de pedidos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Array>} Historial de pedidos
 */
const getCustomerOrderHistory = async (customerId, options = {}) => {
  const { limit = 20, restaurantId = null } = options;
  
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        COUNT(oi.id) as items_count
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${conditions.join(' AND ')}
      GROUP BY o.id, r.name, r.slug
      ORDER BY o.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_order_history'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo historial de pedidos del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene items favoritos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {number} limit - L√≠mite de resultados
 * @returns {Promise<Array>} Items favoritos
 */
const getCustomerFavoriteItems = async (customerId, restaurantId = null, limit = 10) => {
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        mi.id, mi.name, mi.description, mi.price, mi.image_url,
        mc.name as category_name,
        COUNT(oi.id) as order_count,
        SUM(oi.quantity) as total_quantity,
        ROUND(AVG(oi.item_total), 2) as avg_item_total,
        MAX(o.created_at) as last_ordered_at
      FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      JOIN menu_items mi ON oi.menu_item_id = mi.id
      JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE ${conditions.join(' AND ')}
        AND o.status NOT IN ('cancelled')
      GROUP BY mi.id, mi.name, mi.description, mi.price, mi.image_url, mc.name
      ORDER BY order_count DESC, total_quantity DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_favorite_items'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo items favoritos del cliente:', error);
    throw error;
  }
};

/**
 * Busca clientes similares basado en patrones de pedidos
 * @param {string} customerId - ID del cliente base
 * @param {string} restaurantId - ID del restaurante
 * @param {number} limit - L√≠mite de resultados
 * @returns {Promise<Array>} Clientes similares
 */
const findSimilarCustomers = async (customerId, restaurantId, limit = 5) => {
  try {
    const result = await query(
      `WITH customer_items AS (
        SELECT DISTINCT oi.menu_item_id
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        WHERE o.customer_id = $1 AND o.restaurant_id = $2
      ),
      similar_customers AS (
        SELECT 
          o2.customer_id,
          COUNT(DISTINCT oi2.menu_item_id) as common_items,
          AVG(o2.total) as avg_order_value
        FROM orders o2
        JOIN order_items oi2 ON o2.id = oi2.order_id
        WHERE o2.restaurant_id = $2
          AND o2.customer_id != $1
          AND o2.customer_id IS NOT NULL
          AND oi2.menu_item_id IN (SELECT menu_item_id FROM customer_items)
        GROUP BY o2.customer_id
        HAVING COUNT(DISTINCT oi2.menu_item_id) > 0
      )
      SELECT 
        c.*,
        sc.common_items,
        sc.avg_order_value as similar_avg_order_value
      FROM similar_customers sc
      JOIN customers c ON sc.customer_id = c.id
      ORDER BY sc.common_items DESC, ABS(sc.avg_order_value - (
        SELECT AVG(total) FROM orders WHERE customer_id = $1 AND restaurant_id = $2
      )) ASC
      LIMIT $3`,
      [customerId, restaurantId, limit],
      'find_similar_customers'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando clientes similares:', error);
    throw error;
  }
};

/**
 * Obtiene m√©tricas de retenci√≥n de clientes
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} M√©tricas de retenci√≥n
 */
const getRetentionMetrics = async (restaurantId = null, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  if (startDate && endDate) {
    conditions.push(`o.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`);
    values.push(startDate, endDate);
    paramCount += 2;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `WITH customer_metrics AS (
        SELECT 
          o.customer_id,
          COUNT(*) as total_orders,
          MIN(o.created_at) as first_order,
          MAX(o.created_at) as last_order,
          EXTRACT(DAYS FROM (MAX(o.created_at) - MIN(o.created_at))) as customer_lifespan_days
        FROM orders o
        ${whereClause}
        AND o.customer_id IS NOT NULL
        AND o.status NOT IN ('cancelled')
        GROUP BY o.customer_id
      )
      SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders > 1 THEN 1 END) as returning_customers,
        ROUND(
          (COUNT(CASE WHEN total_orders > 1 THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as retention_rate,
        
        ROUND(AVG(total_orders), 2) as avg_orders_per_customer,
        ROUND(AVG(customer_lifespan_days), 1) as avg_customer_lifespan_days,
        
        -- Distribuci√≥n por frecuencia
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as one_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 3 THEN 1 END) as low_frequency,
        COUNT(CASE WHEN total_orders BETWEEN 4 AND 8 THEN 1 END) as medium_frequency,
        COUNT(CASE WHEN total_orders > 8 THEN 1 END) as high_frequency
        
      FROM customer_metrics`,
      values,
      'get_retention_metrics'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo m√©tricas de retenci√≥n:', error);
    throw error;
  }
};

module.exports = {
  findByPhone,
  createCustomer,
  findOrCreate,
  updateCustomer,
  updateOrderStats,
  getCustomersPaginated,
  getCustomerStats,
  getTopCustomersByValue,
  getCustomerOrderHistory,
  getCustomerFavoriteItems,
  findSimilarCustomers,
  getRetentionMetrics
};


================================================
File: database/queries/menu.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');

// ============================================
// CONSULTAS OPTIMIZADAS PARA CLIENTES
// ============================================

/**
 * Busca cliente por tel√©fono
 * @param {string} phone - N√∫mero de tel√©fono
 * @returns {Promise<Object|null>} Cliente encontrado
 */
const findByPhone = async (phone) => {
  try {
    const result = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN c.total_spent / c.total_orders 
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))
          ELSE NULL
        END as days_since_last_order
      FROM customers c 
      WHERE c.phone = $1`,
      [phone],
      'find_customer_by_phone'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando cliente por tel√©fono:', error);
    throw error;
  }
};

/**
 * Crea un nuevo cliente
 * @param {Object} customerData - Datos del cliente
 * @returns {Promise<Object>} Cliente creado
 */
const createCustomer = async (customerData) => {
  const {
    phone,
    name = null,
    defaultAddress = null,
    defaultReferences = null
  } = customerData;

  try {
    const result = await query(
      `INSERT INTO customers (
        id, phone, name, default_address, default_references, created_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())
      RETURNING *`,
      [
        uuidv4(),
        phone,
        name,
        defaultAddress,
        defaultReferences
      ],
      'create_customer'
    );

    logger.info('Nuevo cliente creado', {
      customerId: result.rows[0].id,
      phone: phone.substring(0, 8) + '****'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando cliente:', error);
    throw error;
  }
};

/**
 * Encuentra cliente existente o crea uno nuevo
 * @param {string} phone - N√∫mero de tel√©fono
 * @param {Object} additionalData - Datos adicionales si se crea
 * @returns {Promise<Object>} Cliente existente o nuevo
 */
const findOrCreate = async (phone, additionalData = {}) => {
  try {
    // Primero buscar cliente existente
    let customer = await findByPhone(phone);
    
    if (customer) {
      return customer;
    }

    // Si no existe, crear uno nuevo
    return await createCustomer({ phone, ...additionalData });
  } catch (error) {
    logger.error('Error en findOrCreate cliente:', error);
    throw error;
  }
};

/**
 * Actualiza datos del cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateCustomer = async (customerId, updateData) => {
  const allowedFields = [
    'name', 'default_address', 'default_references'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      fields.push(`${key} = $${paramCount}`);
      values.push(updateData[key]);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos v√°lidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE customers 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, customerId],
      'update_customer'
    );

    if (result.rows.length === 0) {
      throw new Error('Cliente no encontrado');
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando cliente:', error);
    throw error;
  }
};

/**
 * Actualiza estad√≠sticas del cliente tras un pedido
 * @param {string} customerId - ID del cliente
 * @param {number} orderTotal - Total del pedido
 * @param {boolean} isFirstOrder - Si es el primer pedido
 * @returns {Promise<Object>} Cliente actualizado
 */
const updateOrderStats = async (customerId, orderTotal, isFirstOrder = false) => {
  try {
    const result = await query(
      `UPDATE customers 
       SET total_orders = total_orders + 1,
           total_spent = total_spent + $2,
           last_order_at = NOW(),
           first_order_at = CASE 
             WHEN $3 THEN NOW() 
             ELSE first_order_at 
           END
       WHERE id = $1
       RETURNING *`,
      [customerId, orderTotal, isFirstOrder],
      'update_customer_order_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estad√≠sticas del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene lista de clientes con paginaci√≥n
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Object>} Lista paginada de clientes
 */
const getCustomersPaginated = async (options = {}) => {
  const {
    page = 1,
    limit = 20,
    search = '',
    sortBy = 'last_order_at',
    sortOrder = 'DESC',
    minOrders = null,
    minSpent = null
  } = options;

  const offset = (page - 1) * limit;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  // Filtro de b√∫squeda
  if (search) {
    conditions.push(`(c.phone ILIKE $${paramCount} OR c.name ILIKE $${paramCount})`);
    values.push(`%${search}%`);
    paramCount++;
  }

  // Filtro por n√∫mero m√≠nimo de pedidos
  if (minOrders !== null) {
    conditions.push(`c.total_orders >= $${paramCount}`);
    values.push(minOrders);
    paramCount++;
  }

  // Filtro por gasto m√≠nimo
  if (minSpent !== null) {
    conditions.push(`c.total_spent >= $${paramCount}`);
    values.push(minSpent);
    paramCount++;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    // Consulta principal con m√©tricas calculadas
    const customersResult = await query(
      `SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order,
        CASE
          WHEN c.first_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.first_order_at))::integer
          ELSE NULL
        END as customer_lifetime_days,
        -- Clasificaci√≥n del cliente
        CASE
          WHEN c.total_orders = 0 THEN 'new'
          WHEN c.total_orders = 1 THEN 'first_time'
          WHEN c.total_orders BETWEEN 2 AND 5 THEN 'occasional'
          WHEN c.total_orders BETWEEN 6 AND 15 THEN 'regular'
          ELSE 'loyal'
        END as customer_segment
      FROM customers c 
      ${whereClause}
      ORDER BY c.${sortBy} ${sortOrder} NULLS LAST
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_customers_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM customers c ${whereClause}`,
      values,
      'count_customers'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      customers: customersResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo clientes paginados:', error);
    throw error;
  }
};

/**
 * Obtiene estad√≠sticas generales de clientes
 * @param {Object} dateRange - Rango de fechas opcional
 * @returns {Promise<Object>} Estad√≠sticas de clientes
 */
const getCustomerStats = async (dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $1 AND $2');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders = 0 THEN 1 END) as new_customers,
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as first_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 5 THEN 1 END) as occasional_customers,
        COUNT(CASE WHEN total_orders BETWEEN 6 AND 15 THEN 1 END) as regular_customers,
        COUNT(CASE WHEN total_orders > 15 THEN 1 END) as loyal_customers,
        
        -- M√©tricas de valor
        COALESCE(AVG(total_spent), 0) as avg_customer_value,
        COALESCE(AVG(CASE WHEN total_orders > 0 THEN total_spent / total_orders END), 0) as avg_order_value,
        COALESCE(AVG(total_orders), 0) as avg_orders_per_customer,
        
        -- M√©tricas de tiempo
        COALESCE(AVG(CASE 
          WHEN last_order_at IS NOT NULL THEN 
            EXTRACT(DAYS FROM (NOW() - last_order_at))
        END), 0) as avg_days_since_last_order,
        
        -- Distribuci√≥n geogr√°fica b√°sica (por c√≥digos de √°rea)
        jsonb_object_agg(
          phone_area,
          area_count
        ) as phone_area_distribution
        
      FROM customers c
      LEFT JOIN (
        SELECT 
          SUBSTRING(phone FROM 1 FOR 5) as phone_area,
          COUNT(*) as area_count
        FROM customers
        ${whereClause}
        GROUP BY SUBSTRING(phone FROM 1 FOR 5)
      ) areas ON true
      ${whereClause}`,
      values,
      'get_customer_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estad√≠sticas de clientes:', error);
    throw error;
  }
};

/**
 * Obtiene clientes top por valor gastado
 * @param {number} limit - Cantidad de clientes top a obtener
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @returns {Promise<Array>} Lista de clientes top
 */
const getTopCustomersByValue = async (limit = 10, restaurantId = null) => {
  try {
    let query_text = `
      SELECT 
        c.*,
        CASE 
          WHEN c.total_orders > 0 THEN ROUND(c.total_spent / c.total_orders, 2)
          ELSE 0 
        END as avg_order_value,
        CASE
          WHEN c.last_order_at IS NOT NULL THEN
            EXTRACT(DAYS FROM (NOW() - c.last_order_at))::integer
          ELSE NULL
        END as days_since_last_order
      FROM customers c`;

    const values = [limit];

    if (restaurantId) {
      query_text += `
        WHERE c.id IN (
          SELECT DISTINCT o.customer_id 
          FROM orders o 
          WHERE o.restaurant_id = $2 AND o.customer_id IS NOT NULL
        )`;
      values.push(restaurantId);
    }

    query_text += `
      ORDER BY c.total_spent DESC, c.total_orders DESC
      LIMIT $1`;

    const result = await query(query_text, values, 'get_top_customers_by_value');

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo clientes top por valor:', error);
    throw error;
  }
};

/**
 * Obtiene historial de pedidos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Array>} Historial de pedidos
 */
const getCustomerOrderHistory = async (customerId, options = {}) => {
  const { limit = 20, restaurantId = null } = options;
  
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        COUNT(oi.id) as items_count
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${conditions.join(' AND ')}
      GROUP BY o.id, r.name, r.slug
      ORDER BY o.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_order_history'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo historial de pedidos del cliente:', error);
    throw error;
  }
};

/**
 * Obtiene items favoritos de un cliente
 * @param {string} customerId - ID del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {number} limit - L√≠mite de resultados
 * @returns {Promise<Array>} Items favoritos
 */
const getCustomerFavoriteItems = async (customerId, restaurantId = null, limit = 10) => {
  const conditions = ['o.customer_id = $1'];
  const values = [customerId];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const result = await query(
      `SELECT 
        mi.id, mi.name, mi.description, mi.price, mi.image_url,
        mc.name as category_name,
        COUNT(oi.id) as order_count,
        SUM(oi.quantity) as total_quantity,
        ROUND(AVG(oi.item_total), 2) as avg_item_total,
        MAX(o.created_at) as last_ordered_at
      FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      JOIN menu_items mi ON oi.menu_item_id = mi.id
      JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE ${conditions.join(' AND ')}
        AND o.status NOT IN ('cancelled')
      GROUP BY mi.id, mi.name, mi.description, mi.price, mi.image_url, mc.name
      ORDER BY order_count DESC, total_quantity DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_favorite_items'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo items favoritos del cliente:', error);
    throw error;
  }
};

/**
 * Busca clientes similares basado en patrones de pedidos
 * @param {string} customerId - ID del cliente base
 * @param {string} restaurantId - ID del restaurante
 * @param {number} limit - L√≠mite de resultados
 * @returns {Promise<Array>} Clientes similares
 */
const findSimilarCustomers = async (customerId, restaurantId, limit = 5) => {
  try {
    const result = await query(
      `WITH customer_items AS (
        SELECT DISTINCT oi.menu_item_id
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        WHERE o.customer_id = $1 AND o.restaurant_id = $2
      ),
      similar_customers AS (
        SELECT 
          o2.customer_id,
          COUNT(DISTINCT oi2.menu_item_id) as common_items,
          AVG(o2.total) as avg_order_value
        FROM orders o2
        JOIN order_items oi2 ON o2.id = oi2.order_id
        WHERE o2.restaurant_id = $2
          AND o2.customer_id != $1
          AND o2.customer_id IS NOT NULL
          AND oi2.menu_item_id IN (SELECT menu_item_id FROM customer_items)
        GROUP BY o2.customer_id
        HAVING COUNT(DISTINCT oi2.menu_item_id) > 0
      )
      SELECT 
        c.*,
        sc.common_items,
        sc.avg_order_value as similar_avg_order_value
      FROM similar_customers sc
      JOIN customers c ON sc.customer_id = c.id
      ORDER BY sc.common_items DESC, ABS(sc.avg_order_value - (
        SELECT AVG(total) FROM orders WHERE customer_id = $1 AND restaurant_id = $2
      )) ASC
      LIMIT $3`,
      [customerId, restaurantId, limit],
      'find_similar_customers'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando clientes similares:', error);
    throw error;
  }
};

/**
 * Obtiene m√©tricas de retenci√≥n de clientes
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} M√©tricas de retenci√≥n
 */
const getRetentionMetrics = async (restaurantId = null, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  if (restaurantId) {
    conditions.push(`o.restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  if (startDate && endDate) {
    conditions.push(`o.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`);
    values.push(startDate, endDate);
    paramCount += 2;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    const result = await query(
      `WITH customer_metrics AS (
        SELECT 
          o.customer_id,
          COUNT(*) as total_orders,
          MIN(o.created_at) as first_order,
          MAX(o.created_at) as last_order,
          EXTRACT(DAYS FROM (MAX(o.created_at) - MIN(o.created_at))) as customer_lifespan_days
        FROM orders o
        ${whereClause}
        AND o.customer_id IS NOT NULL
        AND o.status NOT IN ('cancelled')
        GROUP BY o.customer_id
      )
      SELECT 
        COUNT(*) as total_customers,
        COUNT(CASE WHEN total_orders > 1 THEN 1 END) as returning_customers,
        ROUND(
          (COUNT(CASE WHEN total_orders > 1 THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as retention_rate,
        
        ROUND(AVG(total_orders), 2) as avg_orders_per_customer,
        ROUND(AVG(customer_lifespan_days), 1) as avg_customer_lifespan_days,
        
        -- Distribuci√≥n por frecuencia
        COUNT(CASE WHEN total_orders = 1 THEN 1 END) as one_time_customers,
        COUNT(CASE WHEN total_orders BETWEEN 2 AND 3 THEN 1 END) as low_frequency,
        COUNT(CASE WHEN total_orders BETWEEN 4 AND 8 THEN 1 END) as medium_frequency,
        COUNT(CASE WHEN total_orders > 8 THEN 1 END) as high_frequency
        
      FROM customer_metrics`,
      values,
      'get_retention_metrics'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo m√©tricas de retenci√≥n:', error);
    throw error;
  }
};

module.exports = {
  findByPhone,
  createCustomer,
  findOrCreate,
  updateCustomer,
  updateOrderStats,
  getCustomersPaginated,
  getCustomerStats,
  getTopCustomersByValue,
  getCustomerOrderHistory,
  getCustomerFavoriteItems,
  findSimilarCustomers,
  getRetentionMetrics
};


================================================
File: database/queries/orders.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ORDER_STATUS } = require('../../src/utils/constants');

// ============================================
// CONSULTAS OPTIMIZADAS PARA PEDIDOS
// ============================================

/**
 * Crea un nuevo pedido desde una conversaci√≥n
 * @param {Object} orderData - Datos del pedido
 * @returns {Promise<Object>} Pedido creado con items
 */
const createOrder = async (orderData) => {
  const {
    restaurantId,
    customerPhone,
    customerId = null,
    items,
    deliveryAddress,
    orderNotes = null,
    paymentMethod = 'cash',
    deliveryFee = 0,
    subtotal,
    total
  } = orderData;

  try {
    return await transaction(async (client) => {
      // Crear el pedido principal
      const orderResult = await client.query(
        `INSERT INTO orders (
          id, restaurant_id, customer_phone, customer_id,
          delivery_address, order_notes, payment_method,
          delivery_fee, subtotal, total, status, created_at
        ) VALUES ($1, $2, $3, $4, $5::jsonb, $6, $7, $8, $9, $10, $11, NOW())
        RETURNING *`,
        [
          uuidv4(),
          restaurantId,
          customerPhone,
          customerId,
          JSON.stringify(deliveryAddress),
          orderNotes,
          paymentMethod,
          deliveryFee,
          subtotal,
          total,
          ORDER_STATUS.CONFIRMED
        ]
      );

      const order = orderResult.rows[0];

      // Crear los items del pedido
      const orderItemsPromises = items.map(item => 
        client.query(
          `INSERT INTO order_items (
            id, order_id, menu_item_id, menu_item_name,
            quantity, base_price, customizations, customizations_cost,
            item_total, notes
          ) VALUES ($1, $2, $3, $4, $5, $6, $7::jsonb, $8, $9, $10)
          RETURNING *`,
          [
            uuidv4(),
            order.id,
            item.menu_item_id,
            item.name,
            item.quantity,
            item.base_price,
            JSON.stringify(item.customizations || []),
            item.customizations_cost || 0,
            item.item_total,
            item.notes || null
          ]
        )
      );

      const orderItemsResults = await Promise.all(orderItemsPromises);
      order.items = orderItemsResults.map(result => result.rows[0]);

      logger.info('Pedido creado exitosamente', {
        orderId: order.id,
        restaurantId,
        customerPhone: customerPhone.substring(0, 8) + '****',
        total,
        itemsCount: items.length
      });

      return order;
    });
  } catch (error) {
    logger.error('Error creando pedido:', error);
    throw error;
  }
};

/**
 * Obtiene un pedido por ID con todos sus detalles
 * @param {string} orderId - ID del pedido
 * @param {string} restaurantId - ID del restaurante (opcional para validaci√≥n)
 * @returns {Promise<Object|null>} Pedido completo
 */
const findById = async (orderId, restaurantId = null) => {
  try {
    let whereClause = 'WHERE o.id = $1';
    const values = [orderId];

    if (restaurantId) {
      whereClause += ' AND o.restaurant_id = $2';
      values.push(restaurantId);
    }

    // Obtener datos del pedido
    const orderResult = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.phone as restaurant_phone,
        r.slug as restaurant_slug,
        c.name as customer_name,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN customers c ON o.customer_id = c.id
      ${whereClause}`,
      values,
      'find_order_by_id'
    );

    if (orderResult.rows.length === 0) {
      return null;
    }

    const order = orderResult.rows[0];

    // Obtener items del pedido
    const itemsResult = await query(
      `SELECT 
        oi.*,
        mi.image_url as menu_item_image
      FROM order_items oi
      LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
      WHERE oi.order_id = $1
      ORDER BY oi.created_at`,
      [orderId],
      'get_order_items'
    );

    order.items = itemsResult.rows;

    return order;
  } catch (error) {
    logger.error('Error obteniendo pedido por ID:', error);
    throw error;
  }
};

/**
 * Obtiene pedidos con filtros y paginaci√≥n
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} filters - Filtros de b√∫squeda
 * @returns {Promise<Object>} Lista paginada de pedidos
 */
const getOrdersPaginated = async (restaurantId, filters = {}) => {
  const {
    page = 1,
    limit = 20,
    status = null,
    customerPhone = null,
    paymentMethod = null,
    dateFrom = null,
    dateTo = null,
    minTotal = null,
    maxTotal = null,
    sortBy = 'created_at',
    sortOrder = 'DESC'
  } = filters;

  const offset = (page - 1) * limit;
  const conditions = ['o.restaurant_id = $1'];
  const values = [restaurantId];
  let paramCount = 2;

  // Agregar filtros
  if (status) {
    if (Array.isArray(status)) {
      conditions.push(`o.status = ANY($${paramCount}::text[])`);
      values.push(status);
    } else {
      conditions.push(`o.status = $${paramCount}`);
      values.push(status);
    }
    paramCount++;
  }

  if (customerPhone) {
    conditions.push(`o.customer_phone = $${paramCount}`);
    values.push(customerPhone);
    paramCount++;
  }

  if (paymentMethod) {
    conditions.push(`o.payment_method = $${paramCount}`);
    values.push(paymentMethod);
    paramCount++;
  }

  if (dateFrom) {
    conditions.push(`o.created_at >= $${paramCount}`);
    values.push(dateFrom);
    paramCount++;
  }

  if (dateTo) {
    conditions.push(`o.created_at <= $${paramCount}`);
    values.push(dateTo);
    paramCount++;
  }

  if (minTotal !== null) {
    conditions.push(`o.total >= $${paramCount}`);
    values.push(minTotal);
    paramCount++;
  }

  if (maxTotal !== null) {
    conditions.push(`o.total <= $${paramCount}`);
    values.push(maxTotal);
    paramCount++;
  }

  const whereClause = conditions.join(' AND ');

  try {
    // Consulta principal
    const ordersResult = await query(
      `SELECT 
        o.*,
        c.name as customer_name,
        COUNT(oi.id) as items_count,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created,
        CASE 
          WHEN o.status = '${ORDER_STATUS.CONFIRMED}' THEN 'Confirmado'
          WHEN o.status = '${ORDER_STATUS.PREPARING}' THEN 'Preparando'
          WHEN o.status = '${ORDER_STATUS.READY}' THEN 'Listo'
          WHEN o.status = '${ORDER_STATUS.OUT_FOR_DELIVERY}' THEN 'En camino'
          WHEN o.status = '${ORDER_STATUS.DELIVERED}' THEN 'Entregado'
          WHEN o.status = '${ORDER_STATUS.CANCELLED}' THEN 'Cancelado'
          ELSE o.status
        END as status_display
      FROM orders o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${whereClause}
      GROUP BY o.id, c.name
      ORDER BY o.${sortBy} ${sortOrder}
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_orders_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM orders o WHERE ${whereClause}`,
      values.slice(0, -2), // Remover limit y offset
      'count_orders'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      orders: ordersResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo pedidos paginados:', error);
    throw error;
  }
};

/**
 * Obtiene pedidos activos (no entregados ni cancelados)
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Lista de pedidos activos
 */
const getActiveOrders = async (restaurantId, options = {}) => {
  const { limit = 50 } = options;

  try {
    const result = await query(
      `SELECT 
        o.*,
        c.name as customer_name,
        COUNT(oi.id) as items_count,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created,
        CASE 
          WHEN o.status = '${ORDER_STATUS.CONFIRMED}' THEN 1
          WHEN o.status = '${ORDER_STATUS.PREPARING}' THEN 2  
          WHEN o.status = '${ORDER_STATUS.READY}' THEN 3
          WHEN o.status = '${ORDER_STATUS.OUT_FOR_DELIVERY}' THEN 4
          ELSE 5
        END as status_priority
      FROM orders o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.restaurant_id = $1
        AND o.status NOT IN ('${ORDER_STATUS.DELIVERED}', '${ORDER_STATUS.CANCELLED}')
      GROUP BY o.id, c.name
      ORDER BY status_priority, o.created_at ASC
      LIMIT $2`,
      [restaurantId, limit],
      'get_active_orders'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo pedidos activos:', error);
    throw error;
  }
};

/**
 * Actualiza el estado de un pedido
 * @param {string} orderId - ID del pedido
 * @param {string} newStatus - Nuevo estado
 * @param {Object} additionalData - Datos adicionales
 * @returns {Promise<Object>} Pedido actualizado
 */
const updateOrderStatus = async (orderId, newStatus, additionalData = {}) => {
  const { statusNotes = null, updatedBy = null } = additionalData;

  try {
    const timestampField = getTimestampFieldForStatus(newStatus);
    let updateQuery = `
      UPDATE orders 
      SET status = $1, 
          status_notes = COALESCE($2, status_notes),
          updated_at = NOW()`;

    const values = [newStatus, statusNotes];
    let paramCount = 3;

    // Agregar timestamp espec√≠fico seg√∫n el estado
    if (timestampField) {
      updateQuery += `, ${timestampField} = NOW()`;
    }

    updateQuery += ` WHERE id = $${paramCount} RETURNING *`;
    values.push(orderId);

    const result = await query(updateQuery, values, 'update_order_status');

    if (result.rows.length === 0) {
      throw new Error('Pedido no encontrado');
    }

    logger.info('Estado de pedido actualizado', {
      orderId,
      newStatus,
      updatedBy: updatedBy || 'system'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estado del pedido:', error);
    throw error;
  }
};

/**
 * Obtiene estad√≠sticas de pedidos
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} dateRange - Rango de fechas
 * @returns {Promise<Object>} Estad√≠sticas de pedidos
 */
const getOrderStats = async (restaurantId, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  const conditions = ['restaurant_id = $1'];
  const values = [restaurantId];
  
  if (startDate && endDate) {
    conditions.push('created_at BETWEEN $2 AND $3');
    values.push(startDate, endDate);
  }

  const whereClause = conditions.join(' AND ');

  try {
    const result = await query(
      `SELECT 
        -- Conteos generales
        COUNT(*) as total_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.CONFIRMED}' THEN 1 END) as confirmed_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.PREPARING}' THEN 1 END) as preparing_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.READY}' THEN 1 END) as ready_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.OUT_FOR_DELIVERY}' THEN 1 END) as out_for_delivery_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.CANCELLED}' THEN 1 END) as cancelled_orders,
        
        -- M√©tricas financieras
        COALESCE(SUM(total), 0) as total_revenue,
        COALESCE(SUM(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN total END), 0) as delivered_revenue,
        COALESCE(AVG(total), 0) as avg_order_value,
        COALESCE(SUM(delivery_fee), 0) as total_delivery_fees,
        
        -- M√©tricas de tiempo
        COALESCE(AVG(EXTRACT(EPOCH FROM (delivered_at - created_at))/60), 0) as avg_delivery_time_minutes,
        COALESCE(AVG(EXTRACT(EPOCH FROM (ready_at - created_at))/60), 0) as avg_preparation_time_minutes,
        
        -- M√©tricas por m√©todo de pago
        COUNT(CASE WHEN payment_method = 'cash' THEN 1 END) as cash_orders,
        COUNT(CASE WHEN payment_method = 'card' THEN 1 END) as card_orders,
        COUNT(CASE WHEN payment_method = 'transfer' THEN 1 END) as transfer_orders,
        
        -- Clientes √∫nicos
        COUNT(DISTINCT customer_phone) as unique_customers,
        
        -- Tasas
        ROUND(
          (COUNT(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as delivery_rate,
        
        ROUND(
          (COUNT(CASE WHEN status = '${ORDER_STATUS.CANCELLED}' THEN 1 END)::numeric / 
           NULLIF(COUNT(*), 0)) * 100, 2
        ) as cancellation_rate
        
      FROM orders 
      WHERE ${whereClause}`,
      values,
      'get_order_stats'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error obteniendo estad√≠sticas de pedidos:', error);
    throw error;
  }
};

/**
 * Obtiene pedidos por cliente
 * @param {string} customerPhone - Tel√©fono del cliente
 * @param {string} restaurantId - ID del restaurante (opcional)
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Historial de pedidos del cliente
 */
const getCustomerOrders = async (customerPhone, restaurantId = null, options = {}) => {
  const { limit = 20, includeItems = false } = options;
  
  const conditions = ['customer_phone = $1'];
  const values = [customerPhone];
  let paramCount = 2;

  if (restaurantId) {
    conditions.push(`restaurant_id = $${paramCount}`);
    values.push(restaurantId);
    paramCount++;
  }

  try {
    const ordersResult = await query(
      `SELECT 
        o.*,
        r.name as restaurant_name,
        r.slug as restaurant_slug,
        COUNT(oi.id) as items_count
      FROM orders o
      JOIN restaurants r ON o.restaurant_id = r.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE ${conditions.join(' AND ')}
      GROUP BY o.id, r.name, r.slug
      ORDER BY o.created_at DESC
      LIMIT $${paramCount}`,
      [...values, limit],
      'get_customer_orders'
    );

    const orders = ordersResult.rows;

    // Si se solicitan los items, obtenerlos por separado
    if (includeItems && orders.length > 0) {
      const orderIds = orders.map(order => order.id);
      
      const itemsResult = await query(
        `SELECT 
          oi.*,
          mi.image_url as menu_item_image
        FROM order_items oi
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE oi.order_id = ANY($1::uuid[])
        ORDER BY oi.order_id, oi.created_at`,
        [orderIds],
        'get_multiple_order_items'
      );

      // Agrupar items por pedido
      const itemsByOrder = {};
      itemsResult.rows.forEach(item => {
        if (!itemsByOrder[item.order_id]) {
          itemsByOrder[item.order_id] = [];
        }
        itemsByOrder[item.order_id].push(item);
      });

      // Agregar items a cada pedido
      orders.forEach(order => {
        order.items = itemsByOrder[order.id] || [];
      });
    }

    return orders;
  } catch (error) {
    logger.error('Error obteniendo pedidos del cliente:', error);
    throw error;
  }
};

/**
 * Busca pedidos por texto
 * @param {string} restaurantId - ID del restaurante
 * @param {string} searchTerm - T√©rmino de b√∫squeda
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Array>} Pedidos encontrados
 */
const searchOrders = async (restaurantId, searchTerm, options = {}) => {
  const { limit = 50 } = options;

  try {
    const result = await query(
      `SELECT DISTINCT
        o.*,
        c.name as customer_name,
        COUNT(oi.id) as items_count,
        EXTRACT(EPOCH FROM (NOW() - o.created_at))/60 as minutes_since_created
      FROM orders o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.restaurant_id = $1
        AND (
          o.customer_phone ILIKE $2
          OR c.name ILIKE $2
          OR o.order_notes ILIKE $2
          OR o.status_notes ILIKE $2
          OR oi.menu_item_name ILIKE $2
          OR oi.notes ILIKE $2
          OR o.id::text ILIKE $2
        )
      GROUP BY o.id, c.name
      ORDER BY o.created_at DESC
      LIMIT $3`,
      [restaurantId, `%${searchTerm}%`, limit],
      'search_orders'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error buscando pedidos:', error);
    throw error;
  }
};

/**
 * Genera reporte de ventas
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} params - Par√°metros del reporte
 * @returns {Promise<Object>} Reporte de ventas
 */
const generateSalesReport = async (restaurantId, params = {}) => {
  const {
    startDate,
    endDate,
    groupBy = 'day' // day, week, month
  } = params;

  try {
    let dateFormat;
    switch (groupBy) {
      case 'week':
        dateFormat = 'YYYY-"W"WW';
        break;
      case 'month':
        dateFormat = 'YYYY-MM';
        break;
      default:
        dateFormat = 'YYYY-MM-DD';
    }

    const result = await query(
      `SELECT 
        TO_CHAR(created_at, '${dateFormat}') as period,
        COUNT(*) as total_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN status = '${ORDER_STATUS.CANCELLED}' THEN 1 END) as cancelled_orders,
        COALESCE(SUM(total), 0) as total_revenue,
        COALESCE(SUM(CASE WHEN status = '${ORDER_STATUS.DELIVERED}' THEN total END), 0) as delivered_revenue,
        COALESCE(AVG(total), 0) as avg_order_value,
        COUNT(DISTINCT customer_phone) as unique_customers
      FROM orders
      WHERE restaurant_id = $1
        AND created_at BETWEEN $2 AND $3
        AND status != '${ORDER_STATUS.CANCELLED}'
      GROUP BY TO_CHAR(created_at, '${dateFormat}')
      ORDER BY period`,
      [restaurantId, startDate, endDate],
      'generate_sales_report'
    );

    return {
      period_type: groupBy,
      date_range: { startDate, endDate },
      data: result.rows,
      generated_at: new Date().toISOString()
    };
  } catch (error) {
    logger.error('Error generando reporte de ventas:', error);
    throw error;
  }
};

/**
 * Obtiene items m√°s vendidos
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} options - Opciones de consulta
 * @returns {Promise<Array>} Items m√°s vendidos
 */
const getTopSellingItems = async (restaurantId, options = {}) => {
  const { limit = 20, days = 30 } = options;

  try {
    const result = await query(
      `SELECT 
        oi.menu_item_id,
        oi.menu_item_name,
        mi.image_url,
        mc.name as category_name,
        SUM(oi.quantity) as total_quantity,
        COUNT(DISTINCT oi.order_id) as order_count,
        ROUND(AVG(oi.item_total / oi.quantity), 2) as avg_unit_price,
        SUM(oi.item_total) as total_revenue
      FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
      LEFT JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE o.restaurant_id = $1
        AND o.status NOT IN ('${ORDER_STATUS.CANCELLED}')
        AND o.created_at > NOW() - INTERVAL '$2 days'
      GROUP BY oi.menu_item_id, oi.menu_item_name, mi.image_url, mc.name
      ORDER BY total_quantity DESC, order_count DESC
      LIMIT $3`,
      [restaurantId, days, limit],
      'get_top_selling_items'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo items m√°s vendidos:', error);
    throw error;
  }
};

/**
 * Cancela un pedido
 * @param {string} orderId - ID del pedido
 * @param {Object} cancellationData - Datos de la cancelaci√≥n
 * @returns {Promise<Object>} Pedido cancelado
 */
const cancelOrder = async (orderId, cancellationData = {}) => {
  const { reason = 'Cancelado por el sistema', cancelledBy = null } = cancellationData;

  try {
    const result = await query(
      `UPDATE orders 
       SET status = $1,
           status_notes = $2,
           cancelled_at = NOW(),
           updated_at = NOW()
       WHERE id = $3 AND status NOT IN ('${ORDER_STATUS.DELIVERED}', '${ORDER_STATUS.CANCELLED}')
       RETURNING *`,
      [ORDER_STATUS.CANCELLED, reason, orderId],
      'cancel_order'
    );

    if (result.rows.length === 0) {
      throw new Error('Pedido no encontrado o no se puede cancelar');
    }

    logger.info('Pedido cancelado', {
      orderId,
      reason,
      cancelledBy: cancelledBy || 'system'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error cancelando pedido:', error);
    throw error;
  }
};

// ============================================
// FUNCIONES AUXILIARES
// ============================================

/**
 * Obtiene el campo de timestamp correspondiente al estado
 * @param {string} status - Estado del pedido
 * @returns {string|null} Nombre del campo timestamp
 */
const getTimestampFieldForStatus = (status) => {
  const statusTimestamps = {
    [ORDER_STATUS.CONFIRMED]: 'confirmed_at',
    [ORDER_STATUS.PREPARING]: 'preparing_at',
    [ORDER_STATUS.READY]: 'ready_at',
    [ORDER_STATUS.OUT_FOR_DELIVERY]: 'out_for_delivery_at',
    [ORDER_STATUS.DELIVERED]: 'delivered_at',
    [ORDER_STATUS.CANCELLED]: 'cancelled_at'
  };

  return statusTimestamps[status] || null;
};

module.exports = {
  createOrder,
  findById,
  getOrdersPaginated,
  getActiveOrders,
  updateOrderStatus,
  getOrderStats,
  getCustomerOrders,
  searchOrders,
  generateSalesReport,
  getTopSellingItems,
  cancelOrder
};


================================================
File: database/queries/restaurants.js
================================================
const { query, transaction } = require('../connection');
const logger = require('../../src/utils/logger');
const { v4: uuidv4 } = require('uuid');

// ============================================
// CONSULTAS OPTIMIZADAS PARA RESTAURANTES
// ============================================

/**
 * Busca restaurante por slug
 * @param {string} slug - Slug del restaurante
 * @returns {Promise<Object|null>} Restaurante encontrado
 */
const findBySlug = async (slug) => {
  try {
    const result = await query(
      `SELECT 
        r.*,
        -- Estad√≠sticas b√°sicas
        (SELECT COUNT(*) FROM orders WHERE restaurant_id = r.id) as total_orders,
        (SELECT COUNT(*) FROM menu_items WHERE restaurant_id = r.id AND is_available = true) as available_items,
        (SELECT COUNT(*) FROM conversations WHERE restaurant_id = r.id AND status = 'active') as active_conversations,
        -- Estado operacional
        CASE 
          WHEN r.is_active = false THEN 'closed'
          WHEN CURRENT_TIME BETWEEN r.opens_at AND r.closes_at THEN 'open'
          ELSE 'closed'
        END as current_status
      FROM restaurants r 
      WHERE r.slug = $1`,
      [slug],
      'find_restaurant_by_slug'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando restaurante por slug:', error);
    throw error;
  }
};

/**
 * Busca restaurante por ID
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Object|null>} Restaurante encontrado
 */
const findById = async (restaurantId) => {
  try {
    const result = await query(
      `SELECT 
        r.*,
        -- Estad√≠sticas detalladas
        (SELECT COUNT(*) FROM orders WHERE restaurant_id = r.id) as total_orders,
        (SELECT COUNT(*) FROM orders WHERE restaurant_id = r.id AND status = 'delivered') as delivered_orders,
        (SELECT COALESCE(SUM(total), 0) FROM orders WHERE restaurant_id = r.id AND status = 'delivered') as total_revenue,
        (SELECT COUNT(*) FROM customers WHERE id IN (SELECT DISTINCT customer_id FROM orders WHERE restaurant_id = r.id)) as total_customers,
        (SELECT COUNT(*) FROM menu_categories WHERE restaurant_id = r.id AND is_active = true) as active_categories,
        (SELECT COUNT(*) FROM menu_items WHERE restaurant_id = r.id AND is_available = true) as available_items,
        (SELECT COUNT(*) FROM conversations WHERE restaurant_id = r.id AND status = 'active') as active_conversations,
        -- Estado operacional
        CASE 
          WHEN r.is_active = false THEN 'closed'
          WHEN CURRENT_TIME BETWEEN r.opens_at AND r.closes_at THEN 'open'
          ELSE 'closed'
        END as current_status
      FROM restaurants r 
      WHERE r.id = $1`,
      [restaurantId],
      'find_restaurant_by_id'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando restaurante por ID:', error);
    throw error;
  }
};

/**
 * Crea un nuevo restaurante
 * @param {Object} restaurantData - Datos del restaurante
 * @returns {Promise<Object>} Restaurante creado
 */
const createRestaurant = async (restaurantData) => {
  const {
    name,
    slug,
    phone,
    email = null,
    address = null,
    logoUrl = null,
    opensAt = '09:00:00',
    closesAt = '23:00:00',
    deliveryTimeMin = 25,
    deliveryTimeMax = 35,
    deliveryFee = 0.00,
    minimumOrder = 0.00,
    whatsappPhoneId = null,
    whatsappToken = null,
    twilioPhoneNumber = null
  } = restaurantData;

  try {
    const result = await query(
      `INSERT INTO restaurants (
        id, name, slug, phone, email, address, logo_url,
        opens_at, closes_at, delivery_time_min, delivery_time_max,
        delivery_fee, minimum_order, whatsapp_phone_id, 
        whatsapp_token, twilio_phone_number, is_active, created_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 
        $12, $13, $14, $15, $16, true, NOW()
      )
      RETURNING *`,
      [
        uuidv4(),
        name,
        slug,
        phone,
        email,
        address,
        logoUrl,
        opensAt,
        closesAt,
        deliveryTimeMin,
        deliveryTimeMax,
        deliveryFee,
        minimumOrder,
        whatsappPhoneId,
        whatsappToken,
        twilioPhoneNumber
      ],
      'create_restaurant'
    );

    logger.info('Nuevo restaurante creado', {
      restaurantId: result.rows[0].id,
      name,
      slug
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando restaurante:', error);
    throw error;
  }
};

/**
 * Actualiza un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Restaurante actualizado
 */
const updateRestaurant = async (restaurantId, updateData) => {
  const allowedFields = [
    'name', 'slug', 'phone', 'email', 'address', 'logo_url',
    'opens_at', 'closes_at', 'delivery_time_min', 'delivery_time_max',
    'delivery_fee', 'minimum_order', 'is_active', 'whatsapp_phone_id',
    'whatsapp_token', 'twilio_phone_number'
  ];

  const fields = [];
  const values = [];
  let paramCount = 1;

  Object.keys(updateData).forEach(key => {
    if (allowedFields.includes(key) && updateData[key] !== undefined) {
      fields.push(`${key} = $${paramCount}`);
      values.push(updateData[key]);
      paramCount++;
    }
  });

  if (fields.length === 0) {
    throw new Error('No hay campos v√°lidos para actualizar');
  }

  try {
    const result = await query(
      `UPDATE restaurants 
       SET ${fields.join(', ')}, updated_at = NOW()
       WHERE id = $${paramCount}
       RETURNING *`,
      [...values, restaurantId],
      'update_restaurant'
    );

    if (result.rows.length === 0) {
      throw new Error('Restaurante no encontrado');
    }

    logger.info('Restaurante actualizado', {
      restaurantId,
      fieldsUpdated: Object.keys(updateData)
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando restaurante:', error);
    throw error;
  }
};

/**
 * Obtiene lista de restaurantes con paginaci√≥n
 * @param {Object} filters - Filtros de b√∫squeda
 * @returns {Promise<Object>} Lista paginada de restaurantes
 */
const getRestaurantsPaginated = async (filters = {}) => {
  const {
    page = 1,
    limit = 20,
    search = '',
    isActive = null,
    sortBy = 'created_at',
    sortOrder = 'DESC'
  } = filters;

  const offset = (page - 1) * limit;
  const conditions = [];
  const values = [];
  let paramCount = 1;

  // Filtro de b√∫squeda
  if (search) {
    conditions.push(`(r.name ILIKE $${paramCount} OR r.slug ILIKE $${paramCount} OR r.phone ILIKE $${paramCount})`);
    values.push(`%${search}%`);
    paramCount++;
  }

  // Filtro por estado activo
  if (isActive !== null) {
    conditions.push(`r.is_active = $${paramCount}`);
    values.push(isActive);
    paramCount++;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  try {
    // Consulta principal con m√©tricas
    const restaurantsResult = await query(
      `SELECT 
        r.*,
        -- Estad√≠sticas operacionales
        COALESCE(stats.total_orders, 0) as total_orders,
        COALESCE(stats.delivered_orders, 0) as delivered_orders,
        COALESCE(stats.total_revenue, 0) as total_revenue,
        COALESCE(stats.total_customers, 0) as total_customers,
        COALESCE(stats.active_conversations, 0) as active_conversations,
        COALESCE(menu_stats.total_categories, 0) as total_categories,
        COALESCE(menu_stats.total_items, 0) as total_items,
        COALESCE(menu_stats.available_items, 0) as available_items,
        -- Estado actual
        CASE 
          WHEN r.is_active = false THEN 'inactive'
          WHEN CURRENT_TIME BETWEEN r.opens_at AND r.closes_at THEN 'open'
          ELSE 'closed'
        END as current_status,
        -- √öltima actividad
        COALESCE(activity.last_order_at, r.created_at) as last_activity
      FROM restaurants r
      LEFT JOIN (
        SELECT 
          restaurant_id,
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as delivered_orders,
          SUM(CASE WHEN status = 'delivered' THEN total ELSE 0 END) as total_revenue,
          COUNT(DISTINCT customer_id) as total_customers
        FROM orders
        GROUP BY restaurant_id
      ) stats ON r.id = stats.restaurant_id
      LEFT JOIN (
        SELECT 
          restaurant_id,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_conversations
        FROM conversations
        GROUP BY restaurant_id
      ) conv_stats ON r.id = conv_stats.restaurant_id
      LEFT JOIN (
        SELECT 
          mc.restaurant_id,
          COUNT(DISTINCT mc.id) as total_categories,
          COUNT(mi.id) as total_items,
          COUNT(CASE WHEN mi.is_available THEN 1 END) as available_items
        FROM menu_categories mc
        LEFT JOIN menu_items mi ON mc.id = mi.category_id
        GROUP BY mc.restaurant_id
      ) menu_stats ON r.id = menu_stats.restaurant_id
      LEFT JOIN (
        SELECT 
          restaurant_id,
          MAX(created_at) as last_order_at
        FROM orders
        GROUP BY restaurant_id
      ) activity ON r.id = activity.restaurant_id
      ${whereClause}
      ORDER BY r.${sortBy} ${sortOrder}
      LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
      [...values, limit, offset],
      'get_restaurants_paginated'
    );

    // Contar total
    const countResult = await query(
      `SELECT COUNT(*) as total FROM restaurants r ${whereClause}`,
      values,
      'count_restaurants'
    );

    const total = parseInt(countResult.rows[0].total);
    const totalPages = Math.ceil(total / limit);

    return {
      restaurants: restaurantsResult.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    };
  } catch (error) {
    logger.error('Error obteniendo restaurantes paginados:', error);
    throw error;
  }
};

/**
 * Verifica si un slug est√° disponible
 * @param {string} slug - Slug a verificar
 * @param {string} excludeId - ID a excluir (para updates)
 * @returns {Promise<boolean>} True si est√° disponible
 */
const isSlugAvailable = async (slug, excludeId = null) => {
  try {
    let queryText = 'SELECT id FROM restaurants WHERE slug = $1';
    const values = [slug];

    if (excludeId) {
      queryText += ' AND id != $2';
      values.push(excludeId);
    }

    const result = await query(queryText, values, 'check_slug_availability');
    return result.rows.length === 0;
  } catch (error) {
    logger.error('Error verificando disponibilidad de slug:', error);
    throw error;
  }
};

/**
 * Obtiene estad√≠sticas detalladas de un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} dateRange - Rango de fechas opcional
 * @returns {Promise<Object>} Estad√≠sticas completas
 */
const getRestaurantStats = async (restaurantId, dateRange = {}) => {
  const { startDate, endDate } = dateRange;
  
  let dateFilter = '';
  const baseValues = [restaurantId];
  let paramCount = 2;

  if (startDate && endDate) {
    dateFilter = `AND created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
    baseValues.push(startDate, endDate);
    paramCount += 2;
  }

  try {
    return await transaction(async (client) => {
      // Estad√≠sticas de pedidos
      const orderStatsResult = await client.query(
        `SELECT 
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as delivered_orders,
          COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_orders,
          COALESCE(SUM(total), 0) as total_revenue,
          COALESCE(SUM(CASE WHEN status = 'delivered' THEN total END), 0) as delivered_revenue,
          COALESCE(AVG(total), 0) as avg_order_value,
          COUNT(DISTINCT customer_phone) as unique_customers,
          COALESCE(AVG(EXTRACT(EPOCH FROM (delivered_at - created_at))/60), 0) as avg_delivery_time,
          
          -- Por m√©todo de pago
          COUNT(CASE WHEN payment_method = 'cash' THEN 1 END) as cash_orders,
          COUNT(CASE WHEN payment_method = 'card' THEN 1 END) as card_orders,
          COUNT(CASE WHEN payment_method = 'transfer' THEN 1 END) as transfer_orders
          
        FROM orders 
        WHERE restaurant_id = $1 ${dateFilter}`,
        baseValues
      );

      // Estad√≠sticas de conversaciones
      const conversationStatsResult = await client.query(
        `SELECT 
          COUNT(*) as total_conversations,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_conversations,
          COUNT(CASE WHEN status = 'abandoned' THEN 1 END) as abandoned_conversations,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_conversations,
          COALESCE(AVG(EXTRACT(EPOCH FROM (COALESCE(updated_at, NOW()) - created_at))/60), 0) as avg_conversation_duration
        FROM conversations 
        WHERE restaurant_id = $1 ${dateFilter}`,
        baseValues
      );

      // Estad√≠sticas del men√∫
      const menuStatsResult = await client.query(
        `SELECT 
          COUNT(DISTINCT mc.id) as total_categories,
          COUNT(mi.id) as total_menu_items,
          COUNT(CASE WHEN mi.is_available THEN 1 END) as available_items,
          COUNT(CASE WHEN mi.image_url IS NOT NULL THEN 1 END) as items_with_images,
          COALESCE(AVG(mi.current_price), 0) as avg_item_price
        FROM menu_categories mc
        LEFT JOIN menu_items mi ON mc.id = mi.category_id
        WHERE mc.restaurant_id = $1`,
        [restaurantId]
      );

      // Items m√°s vendidos (√∫ltimos 30 d√≠as)
      const topItemsResult = await client.query(
        `SELECT 
          oi.menu_item_name,
          SUM(oi.quantity) as total_sold,
          COUNT(DISTINCT oi.order_id) as order_count
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        WHERE o.restaurant_id = $1 
          AND o.status != 'cancelled'
          AND o.created_at > NOW() - INTERVAL '30 days'
        GROUP BY oi.menu_item_name
        ORDER BY total_sold DESC
        LIMIT 5`,
        [restaurantId]
      );

      // Horarios de mayor actividad
      const hourlyStatsResult = await client.query(
        `SELECT 
          EXTRACT(HOUR FROM created_at) as hour,
          COUNT(*) as order_count
        FROM orders
        WHERE restaurant_id = $1 
          AND status != 'cancelled'
          ${dateFilter}
        GROUP BY EXTRACT(HOUR FROM created_at)
        ORDER BY hour`,
        baseValues
      );

      const stats = {
        ...orderStatsResult.rows[0],
        ...conversationStatsResult.rows[0],
        ...menuStatsResult.rows[0],
        top_items: topItemsResult.rows,
        hourly_distribution: hourlyStatsResult.rows,
        generated_at: new Date().toISOString()
      };

      // Calcular tasas
      const totalOrders = parseInt(stats.total_orders);
      const totalConversations = parseInt(stats.total_conversations);

      stats.delivery_rate = totalOrders > 0 
        ? ((parseInt(stats.delivered_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.cancellation_rate = totalOrders > 0
        ? ((parseInt(stats.cancelled_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.conversion_rate = totalConversations > 0
        ? ((parseInt(stats.completed_conversations) / totalConversations) * 100).toFixed(2)
        : 0;

      return stats;
    });
  } catch (error) {
    logger.error('Error obteniendo estad√≠sticas del restaurante:', error);
    throw error;
  }
};

/**
 * Obtiene zonas de entrega de un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Array>} Zonas de entrega
 */
const getDeliveryZones = async (restaurantId) => {
  try {
    const result = await query(
      `SELECT * FROM delivery_zones 
       WHERE restaurant_id = $1 AND is_active = true
       ORDER BY zone_name`,
      [restaurantId],
      'get_delivery_zones'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo zonas de entrega:', error);
    throw error;
  }
};

/**
 * Crea una zona de entrega
 * @param {Object} zoneData - Datos de la zona
 * @returns {Promise<Object>} Zona creada
 */
const createDeliveryZone = async (zoneData) => {
  const {
    restaurantId,
    zoneName,
    postalCodes = [],
    neighborhoods = [],
    extraFee = 0.00
  } = zoneData;

  try {
    const result = await query(
      `INSERT INTO delivery_zones (
        id, restaurant_id, zone_name, postal_codes, 
        neighborhoods, extra_fee, is_active, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, true, NOW())
      RETURNING *`,
      [
        uuidv4(),
        restaurantId,
        zoneName,
        postalCodes,
        neighborhoods,
        extraFee
      ],
      'create_delivery_zone'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error creando zona de entrega:', error);
    throw error;
  }
};

/**
 * Verifica si una direcci√≥n est√° en zona de entrega
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} address - Direcci√≥n a verificar
 * @returns {Promise<Object|null>} Zona encontrada o null
 */
const findDeliveryZoneForAddress = async (restaurantId, address) => {
  const { postalCode, neighborhood } = address;

  try {
    const result = await query(
      `SELECT * FROM delivery_zones
       WHERE restaurant_id = $1 
         AND is_active = true
         AND (
           $2 = ANY(postal_codes) 
           OR $3 ILIKE ANY(
             SELECT '%' || unnest(neighborhoods) || '%'
           )
         )
       ORDER BY extra_fee ASC
       LIMIT 1`,
      [restaurantId, postalCode, neighborhood],
      'find_delivery_zone'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error buscando zona de entrega:', error);
    throw error;
  }
};

/**
 * Obtiene configuraci√≥n de WhatsApp de un restaurante
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Object|null>} Configuraci√≥n de WhatsApp
 */
const getWhatsAppConfig = async (restaurantId) => {
  try {
    const result = await query(
      `SELECT 
        whatsapp_phone_id,
        whatsapp_token,
        twilio_phone_number,
        CASE 
          WHEN whatsapp_phone_id IS NOT NULL AND whatsapp_token IS NOT NULL THEN 'meta'
          WHEN twilio_phone_number IS NOT NULL THEN 'twilio'
          ELSE null
        END as provider
      FROM restaurants 
      WHERE id = $1`,
      [restaurantId],
      'get_whatsapp_config'
    );

    return result.rows[0] || null;
  } catch (error) {
    logger.error('Error obteniendo configuraci√≥n de WhatsApp:', error);
    throw error;
  }
};

/**
 * Actualiza configuraci√≥n de WhatsApp
 * @param {string} restaurantId - ID del restaurante
 * @param {Object} config - Nueva configuraci√≥n
 * @returns {Promise<Object>} Restaurante actualizado
 */
const updateWhatsAppConfig = async (restaurantId, config) => {
  const {
    whatsappPhoneId = null,
    whatsappToken = null,
    twilioPhoneNumber = null
  } = config;

  try {
    const result = await query(
      `UPDATE restaurants 
       SET whatsapp_phone_id = $1,
           whatsapp_token = $2,
           twilio_phone_number = $3,
           updated_at = NOW()
       WHERE id = $4
       RETURNING *`,
      [whatsappPhoneId, whatsappToken, twilioPhoneNumber, restaurantId],
      'update_whatsapp_config'
    );

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando configuraci√≥n de WhatsApp:', error);
    throw error;
  }
};

/**
 * Obtiene restaurantes activos con sus configuraciones b√°sicas
 * @returns {Promise<Array>} Lista de restaurantes activos
 */
const getActiveRestaurants = async () => {
  try {
    const result = await query(
      `SELECT 
        id, name, slug, phone, 
        opens_at, closes_at, is_active,
        whatsapp_phone_id, twilio_phone_number,
        CASE 
          WHEN is_active = false THEN 'inactive'
          WHEN CURRENT_TIME BETWEEN opens_at AND closes_at THEN 'open'
          ELSE 'closed'
        END as current_status
      FROM restaurants 
      WHERE is_active = true
      ORDER BY name`,
      [],
      'get_active_restaurants'
    );

    return result.rows;
  } catch (error) {
    logger.error('Error obteniendo restaurantes activos:', error);
    throw error;
  }
};

/**
 * Marca un restaurante como activo/inactivo
 * @param {string} restaurantId - ID del restaurante
 * @param {boolean} isActive - Nuevo estado
 * @returns {Promise<Object>} Restaurante actualizado
 */
const toggleRestaurantStatus = async (restaurantId, isActive) => {
  try {
    const result = await query(
      `UPDATE restaurants 
       SET is_active = $1, updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [isActive, restaurantId],
      'toggle_restaurant_status'
    );

    logger.info('Estado de restaurante actualizado', {
      restaurantId,
      newStatus: isActive ? 'active' : 'inactive'
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error actualizando estado del restaurante:', error);
    throw error;
  }
};

module.exports = {
  findBySlug,
  findById,
  createRestaurant,
  updateRestaurant,
  getRestaurantsPaginated,
  isSlugAvailable,
  getRestaurantStats,
  getDeliveryZones,
  createDeliveryZone,
  findDeliveryZoneForAddress,
  getWhatsAppConfig,
  updateWhatsAppConfig,
  getActiveRestaurants,
  toggleRestaurantStatus
};


================================================
File: docs/API.md
================================================



================================================
File: docs/SETUP.md
================================================




================================================
File: src/config/claude.js
================================================
const Anthropic = require('@anthropic-ai/sdk');
const logger = require('../utils/logger');

// ============================================
// CONFIGURACI√ìN DE CLAUDE
// ============================================

const claudeConfig = {
  apiKey: process.env.CLAUDE_API_KEY,
  model: process.env.CLAUDE_MODEL || 'claude-3-5-sonnet-20241022',
  maxTokens: parseInt(process.env.CLAUDE_MAX_TOKENS) || 500,
  temperature: parseFloat(process.env.CLAUDE_TEMPERATURE) || 0.7,
};

// Validar configuraci√≥n
if (!claudeConfig.apiKey) {
  logger.error('‚ùå CLAUDE_API_KEY no est√° configurada en las variables de entorno');
  process.exit(1);
}

// Inicializar cliente de Anthropic
const anthropic = new Anthropic({
  apiKey: claudeConfig.apiKey,
});

// ============================================
// PROMPTS BASE DEL SISTEMA
// ============================================

const SYSTEM_PROMPTS = {
  BASE: `Eres un asistente virtual profesional y amigable de un restaurante. Tu objetivo es ayudar a los clientes a realizar pedidos de comida de manera eficiente y natural.

CARACTER√çSTICAS DE TU PERSONALIDAD:
- Amigable, paciente y servicial
- Usas emojis moderadamente para hacer la conversaci√≥n m√°s c√°lida
- Eres claro y conciso en tus respuestas
- Siempre confirmas los detalles importantes
- Ofreces sugerencias √∫tiles sin ser invasivo

REGLAS IMPORTANTES:
1. SIEMPRE valida las restricciones de productos (aderezos, extras, etc.)
2. Confirma cada modificaci√≥n al pedido antes de aplicarla
3. Calcula correctamente los totales incluyendo extras
4. Al final, solicita direcci√≥n completa: calle, n√∫mero, colonia, referencias
5. Mant√©n el contexto de toda la conversaci√≥n
6. Si no entiendes algo, pide aclaraci√≥n amablemente
7. Ofrece alternativas cuando algo no est√© disponible`,

  GREETING: `Saluda al cliente de manera c√°lida y presenta el men√∫ disponible de forma organizada por categor√≠as.`,
  
  ORDERING: `Ayuda al cliente a construir su pedido paso a paso, validando restricciones y calculando totales correctamente.`,
  
  CONFIRMING: `Confirma todos los detalles del pedido y solicita la direcci√≥n de entrega completa.`,
  
  ERROR_HANDLING: `Si ocurre un error o no entiendes algo, pide amablemente al cliente que repita o aclare su solicitud.`
};

// ============================================
// FUNCIONES PRINCIPALES
// ============================================

/**
 * Construye el contexto completo para Claude
 * @param {Object} restaurant - Datos del restaurante
 * @param {Object} orderState - Estado actual del pedido
 * @param {Array} conversationHistory - Historial de la conversaci√≥n
 * @param {string} currentStep - Paso actual de la conversaci√≥n
 * @returns {string} Contexto formateado para Claude
 */
const buildContext = (restaurant, orderState = null, conversationHistory = [], currentStep = 'greeting') => {
  const context = `${SYSTEM_PROMPTS.BASE}

INFORMACI√ìN DEL RESTAURANTE:
Nombre: ${restaurant.name}
Horarios: ${restaurant.opens_at} - ${restaurant.closes_at}
Tiempo de entrega: ${restaurant.delivery_time_min}-${restaurant.delivery_time_max} minutos
${restaurant.delivery_fee > 0 ? `Costo de env√≠o: $${restaurant.delivery_fee}` : 'Env√≠o gratuito'}
${restaurant.minimum_order > 0 ? `Pedido m√≠nimo: $${restaurant.minimum_order}` : ''}

MEN√ö DISPONIBLE:
${formatMenu(restaurant.menu || [])}

${restaurant.business_rules && restaurant.business_rules.length > 0 ? 
`REGLAS IMPORTANTES:
${formatBusinessRules(restaurant.business_rules)}` : ''}

ESTADO ACTUAL DEL PEDIDO:
${orderState ? formatOrderState(orderState) : 'Carrito vac√≠o - El cliente a√∫n no ha pedido nada'}

${conversationHistory.length > 0 ? 
`HISTORIAL DE CONVERSACI√ìN RECIENTE:
${formatConversationHistory(conversationHistory)}` : ''}

PASO ACTUAL: ${currentStep.toUpperCase()}
${SYSTEM_PROMPTS[currentStep.toUpperCase()] || SYSTEM_PROMPTS.BASE}

INSTRUCCIONES FINALES:
- Responde en espa√±ol mexicano
- M√°ximo 3 p√°rrafos por respuesta
- Usa emojis con moderaci√≥n (1-2 por mensaje)
- Siempre incluye el total actualizado cuando hay cambios en el pedido
- Si el pedido est√° completo, solicita: calle, n√∫mero, colonia y referencias`;

  return context;
};

/**
 * Formatea el men√∫ para el contexto de Claude
 * @param {Array} menuItems - Items del men√∫
 * @returns {string} Men√∫ formateado
 */
const formatMenu = (menuItems) => {
  if (!menuItems || menuItems.length === 0) {
    return 'No hay productos disponibles en este momento.';
  }

  const categorizedMenu = {};
  
  menuItems.forEach(item => {
    const category = item.category_name || 'Otros';
    if (!categorizedMenu[category]) {
      categorizedMenu[category] = [];
    }
    categorizedMenu[category].push(item);
  });

  let formattedMenu = '';
  
  Object.keys(categorizedMenu).forEach(category => {
    formattedMenu += `\n${category.toUpperCase()}:\n`;
    categorizedMenu[category].forEach(item => {
      formattedMenu += `‚Ä¢ ${item.name} - $${item.price}`;
      if (item.description) {
        formattedMenu += ` (${item.description})`;
      }
      formattedMenu += '\n';
    });
  });

  return formattedMenu;
};

/**
 * Formatea las reglas de negocio para el contexto
 * @param {Array} businessRules - Reglas de negocio
 * @returns {string} Reglas formateadas
 */
const formatBusinessRules = (businessRules) => {
  if (!businessRules || businessRules.length === 0) {
    return '';
  }

  return businessRules.map(rule => {
    return `‚Ä¢ ${rule.rule_name}: ${rule.ai_message_template || JSON.stringify(rule.rule_config)}`;
  }).join('\n');
};

/**
 * Formatea el estado actual del pedido
 * @param {Object} orderState - Estado del pedido
 * @returns {string} Estado formateado
 */
const formatOrderState = (orderState) => {
  if (!orderState || !orderState.items || orderState.items.length === 0) {
    return 'Carrito vac√≠o';
  }

  let formatted = 'Pedido actual:\n';
  
  orderState.items.forEach((item, index) => {
    formatted += `${index + 1}. ${item.name} (${item.quantity}x) - $${item.item_total}\n`;
    
    if (item.customizations && item.customizations.length > 0) {
      item.customizations.forEach(custom => {
        formatted += `   - ${custom.name}${custom.extra_cost > 0 ? ` (+$${custom.extra_cost})` : ''}\n`;
      });
    }
    
    if (item.notes) {
      formatted += `   Notas: ${item.notes}\n`;
    }
  });
  
  formatted += `\nSubtotal: $${orderState.subtotal || 0}`;
  if (orderState.delivery_fee > 0) {
    formatted += `\nEnv√≠o: $${orderState.delivery_fee}`;
  }
  formatted += `\nTOTAL: $${orderState.total || 0}`;
  
  return formatted;
};

/**
 * Formatea el historial de conversaci√≥n
 * @param {Array} history - Historial de mensajes
 * @returns {string} Historial formateado
 */
const formatConversationHistory = (history) => {
  return history.slice(-6).map(msg => {
    return `${msg.role === 'user' ? 'Cliente' : 'Asistente'}: ${msg.content}`;
  }).join('\n');
};

// ============================================
// FUNCI√ìN PRINCIPAL PARA LLAMAR A CLAUDE
// ============================================

/**
 * Obtiene respuesta de Claude AI
 * @param {Object} contextData - Datos para construir el contexto
 * @param {string} userMessage - Mensaje del usuario
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<string>} Respuesta de Claude
 */
const getClaude3Response = async (contextData, userMessage, options = {}) => {
  const startTime = Date.now();
  
  try {
    const {
      restaurant,
      orderState,
      conversationHistory,
      currentStep = 'greeting'
    } = contextData;

    // Construir contexto
    const systemContext = buildContext(restaurant, orderState, conversationHistory, currentStep);
    
    // Preparar mensajes
    const messages = [
      {
        role: 'user',
        content: userMessage
      }
    ];

    // Configuraci√≥n de la llamada
    const requestConfig = {
      model: options.model || claudeConfig.model,
      max_tokens: options.maxTokens || claudeConfig.maxTokens,
      temperature: options.temperature || claudeConfig.temperature,
      system: systemContext,
      messages: messages
    };

    logger.debug('Llamando a Claude API', {
      model: requestConfig.model,
      maxTokens: requestConfig.max_tokens,
      temperature: requestConfig.temperature,
      userMessageLength: userMessage.length,
      contextLength: systemContext.length
    });

    // Llamar a Claude
    const response = await anthropic.messages.create(requestConfig);
    
    const duration = Date.now() - startTime;
    const responseText = response.content[0].text;

    logger.info('Respuesta de Claude recibida', {
      duration: `${duration}ms`,
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens,
      totalTokens: response.usage.input_tokens + response.usage.output_tokens,
      responseLength: responseText.length
    });

    return {
      response: responseText,
      usage: response.usage,
      model: response.model,
      duration
    };

  } catch (error) {
    const duration = Date.now() - startTime;
    
    logger.error('Error al llamar a Claude API', {
      duration: `${duration}ms`,
      error: error.message,
      userMessage: userMessage.substring(0, 100),
      errorType: error.constructor.name
    });

    // Retornar respuesta de fallback
    return {
      response: getFallbackResponse(userMessage),
      usage: null,
      model: 'fallback',
      duration,
      error: error.message
    };
  }
};

/**
 * Respuesta de fallback cuando Claude no est√° disponible
 * @param {string} userMessage - Mensaje del usuario
 * @returns {string} Respuesta de fallback
 */
const getFallbackResponse = (userMessage) => {
  const fallbackResponses = [
    'Disculpa, estoy teniendo problemas t√©cnicos en este momento. ¬øPodr√≠as repetir tu mensaje?',
    'Lo siento, no pude procesar tu solicitud. ¬øPuedes intentar de nuevo?',
    'Estoy experimentando dificultades t√©cnicas. Por favor, intenta nuevamente en unos momentos.',
    'Disculpa la inconveniencia. ¬øPodr√≠as volver a enviar tu mensaje?'
  ];
  
  return fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
};

/**
 * Verifica si Claude est√° disponible
 * @returns {Promise<boolean>} True si Claude responde
 */
const testClaudeConnection = async () => {
  try {
    const response = await anthropic.messages.create({
      model: claudeConfig.model,
      max_tokens: 50,
      temperature: 0,
      system: 'Responde solo con "OK" para confirmar que funciona.',
      messages: [{ role: 'user', content: 'Test' }]
    });

    const isWorking = response.content[0].text.trim().toUpperCase() === 'OK';
    
    logger.info('Test de Claude completado', { 
      isWorking,
      model: response.model,
      usage: response.usage
    });
    
    return isWorking;
    
  } catch (error) {
    logger.error('Error en test de Claude:', error);
    return false;
  }
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  anthropic,
  claudeConfig,
  getClaude3Response,
  buildContext,
  testClaudeConnection,
  SYSTEM_PROMPTS
};


================================================
File: src/config/database.js
================================================
const { Pool } = require('pg');
const logger = require('../utils/logger');

// ============================================
// CONFIGURACI√ìN DEL POOL DE CONEXIONES
// ============================================

const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT) || 5432,
  database: process.env.DB_NAME || 'ChatBotProject',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD,
  
  // Configuraci√≥n del pool
  min: parseInt(process.env.DB_POOL_MIN) || 2,
  max: parseInt(process.env.DB_POOL_MAX) || 10,
  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT) || 10000,
  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 2000,
  
  // SSL configuraci√≥n
  ssl: process.env.DB_SSL === 'true' ? {
    rejectUnauthorized: false
  } : false,
  
  // Configuraci√≥n adicional
  statement_timeout: 30000, // 30 segundos
  query_timeout: 30000,
  application_name: 'ChatBot_Chingon',
};

// Crear pool de conexiones
const pool = new Pool(dbConfig);

// ============================================
// EVENTOS DEL POOL
// ============================================

pool.on('connect', (client) => {
  logger.debug('Nueva conexi√≥n establecida con la base de datos');
});

pool.on('acquire', (client) => {
  logger.debug('Cliente adquirido del pool');
});

pool.on('remove', (client) => {
  logger.debug('Cliente removido del pool');
});

pool.on('error', (err, client) => {
  logger.error('Error inesperado en cliente del pool:', err);
});

// ============================================
// FUNCI√ìN PARA EJECUTAR QUERIES
// ============================================

/**
 * Ejecuta una query SQL con par√°metros
 * @param {string} text - Query SQL
 * @param {Array} params - Par√°metros de la query
 * @param {string} description - Descripci√≥n para logging
 * @returns {Promise<Object>} Resultado de la query
 */
const query = async (text, params = [], description = '') => {
  const start = Date.now();
  
  try {
    logger.debug('Ejecutando query', { 
      description, 
      query: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
      paramsCount: params.length 
    });
    
    const result = await pool.query(text, params);
    const duration = Date.now() - start;
    
    logger.debug('Query ejecutada exitosamente', {
      description,
      duration: `${duration}ms`,
      rowCount: result.rowCount
    });
    
    return result;
    
  } catch (error) {
    const duration = Date.now() - start;
    
    logger.error('Error en query SQL', {
      description,
      duration: `${duration}ms`,
      error: error.message,
      query: text,
      params: params
    });
    
    throw error;
  }
};

// ============================================
// TRANSACCIONES
// ============================================

/**
 * Ejecuta m√∫ltiples queries en una transacci√≥n
 * @param {Function} callback - Funci√≥n que recibe el cliente y ejecuta queries
 * @returns {Promise<any>} Resultado de la transacci√≥n
 */
const transaction = async (callback) => {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    logger.debug('Transacci√≥n iniciada');
    
    const result = await callback(client);
    
    await client.query('COMMIT');
    logger.debug('Transacci√≥n completada exitosamente');
    
    return result;
    
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error('Transacci√≥n revertida debido a error:', error);
    throw error;
    
  } finally {
    client.release();
  }
};

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Obtiene informaci√≥n del estado del pool
 * @returns {Object} Estad√≠sticas del pool
 */
const getPoolInfo = () => {
  return {
    totalCount: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount,
    config: {
      max: pool.options.max,
      min: pool.options.min,
      idleTimeoutMillis: pool.options.idleTimeoutMillis
    }
  };
};

/**
 * Prueba la conexi√≥n a la base de datos
 * @returns {Promise<boolean>} True si la conexi√≥n es exitosa
 */
const testConnection = async () => {
  try {
    const result = await query('SELECT NOW() as current_time, version() as version', [], 'test_connection');
    
    logger.info('Conexi√≥n a base de datos verificada', {
      timestamp: result.rows[0].current_time,
      version: result.rows[0].version.split(' ')[0] + ' ' + result.rows[0].version.split(' ')[1]
    });
    
    return true;
    
  } catch (error) {
    logger.error('Error al probar conexi√≥n a base de datos:', error);
    throw error;
  }
};

/**
 * Verifica si existe una tabla
 * @param {string} tableName - Nombre de la tabla
 * @returns {Promise<boolean>} True si la tabla existe
 */
const tableExists = async (tableName) => {
  try {
    const result = await query(
      `SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )`,
      [tableName],
      `check_table_exists_${tableName}`
    );
    
    return result.rows[0].exists;
    
  } catch (error) {
    logger.error(`Error al verificar existencia de tabla ${tableName}:`, error);
    return false;
  }
};

/**
 * Ejecuta el script de migraci√≥n inicial
 * @returns {Promise<void>}
 */
const runMigrations = async () => {
  const fs = require('fs');
  const path = require('path');
  
  try {
    const migrationFile = path.join(__dirname, '../../database/migrations/001_initial_schema.sql');
    
    if (!fs.existsSync(migrationFile)) {
      logger.warn('Archivo de migraci√≥n no encontrado:', migrationFile);
      return;
    }
    
    const migrationSQL = fs.readFileSync(migrationFile, 'utf8');
    
    await transaction(async (client) => {
      logger.info('Ejecutando migraciones...');
      await client.query(migrationSQL);
      logger.info('‚úÖ Migraciones ejecutadas exitosamente');
    });
    
  } catch (error) {
    logger.error('‚ùå Error al ejecutar migraciones:', error);
    throw error;
  }
};

/**
 * Funci√≥n para limpiar conversaciones inactivas
 * @returns {Promise<number>} N√∫mero de conversaciones limpiadas
 */
const cleanInactiveConversations = async () => {
  try {
    const result = await query(
      `UPDATE conversations 
       SET status = 'abandoned',
           updated_at = CURRENT_TIMESTAMP
       WHERE status = 'active' 
       AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '2 hours'`,
      [],
      'clean_inactive_conversations'
    );
    
    return result.rowCount;
    
  } catch (error) {
    logger.error('Error al limpiar conversaciones inactivas:', error);
    throw error;
  }
};

/**
 * Cierra todas las conexiones del pool
 * @returns {Promise<void>}
 */
const closePool = async () => {
  try {
    await pool.end();
    logger.info('Pool de conexiones cerrado exitosamente');
  } catch (error) {
    logger.error('Error al cerrar pool de conexiones:', error);
    throw error;
  }
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  pool,
  query,
  transaction,
  getPoolInfo,
  testDatabaseConnection: testConnection,
  tableExists,
  runMigrations,
  cleanInactiveConversations,
  closePool
};


================================================
File: src/config/whatsapp.js
================================================
const twilio = require('twilio');
const axios = require('axios');
const logger = require('../utils/logger');

// ============================================
// CONFIGURACI√ìN DE TWILIO WHATSAPP
// ============================================

const twilioConfig = {
  accountSid: process.env.TWILIO_ACCOUNT_SID,
  authToken: process.env.TWILIO_AUTH_TOKEN,
  phoneNumber: process.env.TWILIO_PHONE_NUMBER,
};

// Configuraci√≥n de Meta WhatsApp Business API
const metaConfig = {
  accessToken: process.env.META_WHATSAPP_TOKEN,
  phoneNumberId: process.env.META_WHATSAPP_PHONE_NUMBER_ID,
  verifyToken: process.env.META_WEBHOOK_VERIFY_TOKEN,
  apiVersion: 'v18.0',
  baseUrl: 'https://graph.facebook.com'
};

// Inicializar cliente de Twilio si est√° configurado
let twilioClient = null;

if (twilioConfig.accountSid && twilioConfig.authToken) {
  twilioClient = twilio(twilioConfig.accountSid, twilioConfig.authToken);
  logger.info('‚úÖ Cliente Twilio inicializado');
}

// ============================================
// UTILIDADES DE FORMATEO
// ============================================

/**
 * Formatea un n√∫mero de tel√©fono a formato internacional
 * @param {string} phoneNumber - N√∫mero de tel√©fono
 * @returns {string} N√∫mero formateado
 */
const formatPhoneNumber = (phoneNumber) => {
  // Remover espacios, guiones y par√©ntesis
  let cleaned = phoneNumber.replace(/[\s\-\(\)]/g, '');
  
  // Si no empieza con +, agregar c√≥digo de pa√≠s de M√©xico
  if (!cleaned.startsWith('+')) {
    if (cleaned.startsWith('52')) {
      cleaned = '+' + cleaned;
    } else if (cleaned.length === 10) {
      cleaned = '+52' + cleaned;
    } else {
      cleaned = '+' + cleaned;
    }
  }
  
  return cleaned;
};

/**
 * Valida si un n√∫mero de WhatsApp es v√°lido
 * @param {string} phoneNumber - N√∫mero a validar
 * @returns {boolean} True si es v√°lido
 */
const isValidWhatsAppNumber = (phoneNumber) => {
  const formatted = formatPhoneNumber(phoneNumber);
  const whatsappRegex = /^\+[1-9]\d{1,14}$/;
  return whatsappRegex.test(formatted);
};

// ============================================
// FUNCIONES DE TWILIO WHATSAPP
// ============================================

/**
 * Env√≠a un mensaje via Twilio WhatsApp
 * @param {string} to - N√∫mero de tel√©fono destino
 * @param {string} message - Mensaje a enviar
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Object>} Resultado del env√≠o
 */
const sendTwilioMessage = async (to, message, options = {}) => {
  if (!twilioClient) {
    throw new Error('Cliente Twilio no est√° configurado');
  }

  try {
    const toFormatted = formatPhoneNumber(to);
    const fromFormatted = `whatsapp:${twilioConfig.phoneNumber}`;
    const toWhatsApp = `whatsapp:${toFormatted}`;

    logger.debug('Enviando mensaje via Twilio', {
      to: toFormatted,
      messageLength: message.length,
      mediaUrl: options.mediaUrl ? 'included' : 'none'
    });

    const messageData = {
      body: message,
      from: fromFormatted,
      to: toWhatsApp,
    };

    // Agregar media si est√° presente
    if (options.mediaUrl) {
      messageData.mediaUrl = [options.mediaUrl];
    }

    const result = await twilioClient.messages.create(messageData);

    logger.info('Mensaje enviado exitosamente via Twilio', {
      sid: result.sid,
      to: toFormatted,
      status: result.status,
      direction: result.direction
    });

    return {
      success: true,
      messageId: result.sid,
      status: result.status,
      provider: 'twilio'
    };

  } catch (error) {
    logger.error('Error enviando mensaje via Twilio', {
      to,
      error: error.message,
      code: error.code,
      moreInfo: error.moreInfo
    });

    throw error;
  }
};

// ============================================
// FUNCIONES DE META WHATSAPP BUSINESS API
// ============================================

/**
 * Env√≠a un mensaje via Meta WhatsApp Business API
 * @param {string} to - N√∫mero de tel√©fono destino
 * @param {string} message - Mensaje a enviar
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Object>} Resultado del env√≠o
 */
const sendMetaMessage = async (to, message, options = {}) => {
  if (!metaConfig.accessToken || !metaConfig.phoneNumberId) {
    throw new Error('Meta WhatsApp API no est√° configurada');
  }

  try {
    const toFormatted = formatPhoneNumber(to).replace('+', '');
    const url = `${metaConfig.baseUrl}/${metaConfig.apiVersion}/${metaConfig.phoneNumberId}/messages`;

    const messageData = {
      messaging_product: 'whatsapp',
      to: toFormatted,
      type: 'text',
      text: {
        body: message
      }
    };

    // Para mensajes con media
    if (options.mediaUrl) {
      messageData.type = 'image';
      messageData.image = {
        link: options.mediaUrl
      };
      delete messageData.text;
    }

    logger.debug('Enviando mensaje via Meta WhatsApp', {
      to: toFormatted,
      messageLength: message.length,
      type: messageData.type
    });

    const response = await axios.post(url, messageData, {
      headers: {
        'Authorization': `Bearer ${metaConfig.accessToken}`,
        'Content-Type': 'application/json'
      }
    });

    logger.info('Mensaje enviado exitosamente via Meta WhatsApp', {
      messageId: response.data.messages[0].id,
      to: toFormatted,
      status: 'sent'
    });

    return {
      success: true,
      messageId: response.data.messages[0].id,
      status: 'sent',
      provider: 'meta'
    };

  } catch (error) {
    logger.error('Error enviando mensaje via Meta WhatsApp', {
      to,
      error: error.message,
      status: error.response?.status,
      data: error.response?.data
    });

    throw error;
  }
};

// ============================================
// FUNCI√ìN PRINCIPAL DE ENV√çO
// ============================================

/**
 * Env√≠a un mensaje de WhatsApp usando el proveedor disponible
 * @param {string} to - N√∫mero de tel√©fono destino
 * @param {string} message - Mensaje a enviar
 * @param {Object} options - Opciones adicionales
 * @returns {Promise<Object>} Resultado del env√≠o
 */
const sendWhatsAppMessage = async (to, message, options = {}) => {
  if (!isValidWhatsAppNumber(to)) {
    throw new Error('N√∫mero de WhatsApp inv√°lido');
  }

  // Truncar mensaje si es muy largo
  const maxLength = 4096;
  const truncatedMessage = message.length > maxLength 
    ? message.substring(0, maxLength - 3) + '...'
    : message;

  try {
    // Intentar con Meta WhatsApp primero, luego Twilio
    if (metaConfig.accessToken && metaConfig.phoneNumberId) {
      return await sendMetaMessage(to, truncatedMessage, options);
    } else if (twilioClient) {
      return await sendTwilioMessage(to, truncatedMessage, options);
    } else {
      throw new Error('Ning√∫n proveedor de WhatsApp est√° configurado');
    }

  } catch (error) {
    logger.error('Error enviando mensaje de WhatsApp', {
      to,
      provider: metaConfig.accessToken ? 'meta' : 'twilio',
      error: error.message
    });

    throw error;
  }
};

// ============================================
// VALIDACI√ìN DE WEBHOOKS
// ============================================

/**
 * Valida webhook de Twilio
 * @param {string} signature - Firma del webhook
 * @param {string} url - URL del webhook
 * @param {Object} params - Par√°metros del webhook
 * @returns {boolean} True si es v√°lido
 */
const validateTwilioWebhook = (signature, url, params) => {
  if (!twilioClient) {
    return false;
  }

  try {
    return twilio.validateRequest(
      twilioConfig.authToken,
      signature,
      url,
      params
    );
  } catch (error) {
    logger.error('Error validando webhook de Twilio:', error);
    return false;
  }
};

/**
 * Valida webhook de Meta WhatsApp
 * @param {string} mode - Modo de verificaci√≥n
 * @param {string} token - Token de verificaci√≥n
 * @param {string} challenge - Challenge de verificaci√≥n
 * @returns {string|boolean} Challenge si es v√°lido, false si no
 */
const validateMetaWebhook = (mode, token, challenge) => {
  if (mode === 'subscribe' && token === metaConfig.verifyToken) {
    logger.info('Webhook de Meta WhatsApp verificado exitosamente');
    return challenge;
  }
  
  logger.warn('Intento de verificaci√≥n de webhook inv√°lido', { mode, token });
  return false;
};

// ============================================
// PROCESAMIENTO DE MENSAJES ENTRANTES
// ============================================

/**
 * Procesa mensaje entrante de Twilio
 * @param {Object} webhookData - Datos del webhook
 * @returns {Object} Mensaje procesado
 */
const processTwilioIncomingMessage = (webhookData) => {
  return {
    messageId: webhookData.MessageSid,
    from: webhookData.From.replace('whatsapp:', ''),
    to: webhookData.To.replace('whatsapp:', ''),
    body: webhookData.Body || '',
    timestamp: new Date(),
    provider: 'twilio',
    mediaUrl: webhookData.MediaUrl0 || null,
    mediaType: webhookData.MediaContentType0 || null
  };
};

/**
 * Procesa mensaje entrante de Meta WhatsApp
 * @param {Object} webhookData - Datos del webhook
 * @returns {Object} Mensaje procesado
 */
const processMetaIncomingMessage = (webhookData) => {
  const entry = webhookData.entry[0];
  const changes = entry.changes[0];
  const value = changes.value;
  
  if (!value.messages || value.messages.length === 0) {
    return null;
  }

  const message = value.messages[0];
  
  return {
    messageId: message.id,
    from: '+' + message.from,
    to: '+' + value.metadata.phone_number_id,
    body: message.text?.body || '',
    timestamp: new Date(parseInt(message.timestamp) * 1000),
    provider: 'meta',
    mediaUrl: message.image?.id || null,
    mediaType: message.type
  };
};

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Verifica el estado de los servicios de WhatsApp
 * @returns {Promise<Object>} Estado de los servicios
 */
const checkWhatsAppStatus = async () => {
  const status = {
    twilio: false,
    meta: false,
    activeProvider: null
  };

  // Verificar Twilio
  if (twilioClient) {
    try {
      await twilioClient.api.accounts(twilioConfig.accountSid).fetch();
      status.twilio = true;
    } catch (error) {
      logger.error('Error verificando estado de Twilio:', error);
    }
  }

  // Verificar Meta
  if (metaConfig.accessToken) {
    try {
      const url = `${metaConfig.baseUrl}/${metaConfig.apiVersion}/${metaConfig.phoneNumberId}`;
      await axios.get(url, {
        headers: { 'Authorization': `Bearer ${metaConfig.accessToken}` }
      });
      status.meta = true;
    } catch (error) {
      logger.error('Error verificando estado de Meta WhatsApp:', error);
    }
  }

  // Determinar proveedor activo
  status.activeProvider = status.meta ? 'meta' : (status.twilio ? 'twilio' : null);

  return status;
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Configuraci√≥n
  twilioConfig,
  metaConfig,
  twilioClient,
  
  // Funciones principales
  sendWhatsAppMessage,
  sendTwilioMessage,
  sendMetaMessage,
  
  // Validaci√≥n
  validateTwilioWebhook,
  validateMetaWebhook,
  isValidWhatsAppNumber,
  
  // Procesamiento
  processTwilioIncomingMessage,
  processMetaIncomingMessage,
  
  // Utilidades
  formatPhoneNumber,
  checkWhatsAppStatus
};


================================================
File: src/controllers/authController.js
================================================
const User = require('../models/User');
const AuthMiddleware = require('../middleware/auth');
const logger = require('../utils/logger');
const { AuthenticationError, ValidationError } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE AUTENTICACI√ìN
// ============================================

class AuthController {
  /**
   * Login de usuario
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static async login(req, res, next) {
    try {
      const { email, password } = req.body;

      // Validaci√≥n b√°sica
      if (!email || !password) {
        throw new ValidationError('Email y contrase√±a son requeridos');
      }

      // Validar formato de email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        throw new ValidationError('Formato de email inv√°lido');
      }

      // Buscar usuario
      const user = await User.findByEmailWithProfile(email.toLowerCase().trim());
      
      if (!user) {
        logger.warn('Intento de login con email inexistente', { 
          email: email.substring(0, 5) + '****',
          ip: req.ip 
        });
        throw new AuthenticationError('Credenciales inv√°lidas');
      }

      // Verificar si el usuario est√° activo
      if (!user.is_active) {
        logger.warn('Intento de login con usuario inactivo', { 
          userId: user.id,
          ip: req.ip 
        });
        throw new AuthenticationError('Cuenta desactivada');
      }

      // Verificar contrase√±a
      const isPasswordValid = await User.verifyPassword(password, user.password_hash);
      
      if (!isPasswordValid) {
        logger.warn('Intento de login con contrase√±a incorrecta', { 
          userId: user.id,
          ip: req.ip 
        });
        throw new AuthenticationError('Credenciales inv√°lidas');
      }

      // Generar tokens
      const tokenPayload = {
        sub: user.id,
        email: user.email,
        role: user.profile.role.name,
        restaurantId: user.profile.restaurant_id,
        permissions: user.profile.role.permissions || []
      };

      const tokens = AuthMiddleware.generateTokenPair(tokenPayload);

      // Actualizar √∫ltimo login
      await User.updateLastLogin(user.id);

      // Respuesta exitosa
      const responseData = {
        user: {
          id: user.id,
          email: user.email,
          first_name: user.first_name,
          last_name: user.last_name,
          profile: {
            role: user.profile.role.name,
            role_display_name: user.profile.role.display_name,
            permissions: user.profile.role.permissions,
            restaurant: user.profile.restaurant,
            phone: user.profile.phone,
            avatar_url: user.profile.avatar_url
          }
        },
        tokens
      };

      logger.info('Login exitoso', { 
        userId: user.id,
        role: user.profile.role.name,
        restaurant: user.profile.restaurant?.name || 'Sistema',
        ip: req.ip 
      });

      res.json({
        success: true,
        message: 'Login exitoso',
        data: responseData
      });

    } catch (error) {
      next(error);
    }
  }

  /**
   * Refresh token
   * @param {Object} req - Request object  
   * @param {Object} res - Response object
   */
  static async refreshToken(req, res, next) {
    try {
      // El middleware ya proces√≥ el refresh token y gener√≥ uno nuevo
      const newTokens = {
        access_token: req.newToken,
        refresh_token: req.body.refresh_token, // Mantener el mismo refresh token
        token_type: 'Bearer',
        expires_in: 3600
      };

      logger.info('Token refrescado exitosamente', { 
        userId: req.user.id 
      });

      res.json({
        success: true,
        message: 'Token refrescado exitosamente',
        data: { tokens: newTokens }
      });

    } catch (error) {
      next(error);
    }
  }

  /**
   * Obtiene informaci√≥n del usuario actual
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static async getCurrentUser(req, res, next) {
    try {
      const user = await User.findByEmailWithProfile(req.user.email);
      
      if (!user) {
        throw new AuthenticationError('Usuario no encontrado');
      }

      const userData = {
        id: user.id,
        email: user.email,
        first_name: user.first_name,
        last_name: user.last_name,
        profile: {
          role: user.profile.role.name,
          role_display_name: user.profile.role.display_name,
          permissions: user.profile.role.permissions,
          restaurant: user.profile.restaurant,
          phone: user.profile.phone,
          avatar_url: user.profile.avatar_url,
          settings: user.profile.settings
        }
      };

      res.json({
        success: true,
        data: { user: userData }
      });

    } catch (error) {
      next(error);
    }
  }
}

module.exports = AuthController;


================================================
File: src/controllers/conversationController.js
================================================
const Conversation = require('../models/Conversation');
const ConversationService = require('../services/conversationService');
const ValidationService = require('../services/validationService');
const WhatsAppService = require('../services/whatsappService');
const logger = require('../utils/logger');
const { CONVERSATION_STATUS, CONVERSATION_STEPS } = require('../utils/constants');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE CONVERSACIONES
// ============================================

class ConversationController {

  /**
   * Obtiene conversaciones de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversations = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inv√°lido'
        });
      }

      // Validar par√°metros de paginaci√≥n
      const paginationValidation = ValidationService.validatePaginationParams(req.query);
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error
        });
      }

      const { page, limit } = paginationValidation.data;

      const options = {
        page,
        limit,
        status: req.query.status,
        customerPhone: req.query.customer_phone
      };

      // Obtener conversaciones
      const result = await Conversation.getRecent(restaurantId, options);

      logger.info('Conversaciones obtenidas', {
        restaurantId,
        page,
        limit,
        totalItems: result.pagination.total_items
      });

      res.json({
        success: true,
        data: result.conversations,
        pagination: result.pagination
      });

    } catch (error) {
      logger.error('Error obteniendo conversaciones:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo conversaciones'
      });
    }
  });

  /**
   * Obtiene una conversaci√≥n espec√≠fica por ID
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversationById = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversaci√≥n inv√°lido'
        });
      }

      const conversation = await Conversation.findById(conversationId);

      if (!conversation) {
        return res.status(404).json({
          success: false,
          error: 'Conversaci√≥n no encontrada'
        });
      }

      // Verificar que la conversaci√≥n pertenece al restaurante si est√° especificado
      if (req.restaurant && conversation.restaurant_id !== req.restaurant.id) {
        return res.status(404).json({
          success: false,
          error: 'Conversaci√≥n no encontrada'
        });
      }

      // Parsear datos JSON para la respuesta
      let orderData = {};
      let aiContext = [];

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversaci√≥n:', e);
      }

      const response = {
        ...conversation,
        order_data: orderData,
        ai_context: aiContext
      };

      logger.info('Conversaci√≥n obtenida por ID', {
        conversationId,
        status: conversation.status,
        customerPhone: conversation.customer_phone?.substring(0, 8) + '****'
      });

      res.json({
        success: true,
        data: response
      });

    } catch (error) {
      logger.error('Error obteniendo conversaci√≥n por ID:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo conversaci√≥n'
      });
    }
  });

  /**
   * Obtiene conversaci√≥n activa de un cliente
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getActiveConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id || req.params.restaurantId;

      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Tel√©fono del cliente requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de tel√©fono inv√°lido'
        });
      }

      const conversation = await Conversation.getActive(restaurantId, customerPhone);

      if (!conversation) {
        return res.status(404).json({
          success: false,
          error: 'No hay conversaci√≥n activa'
        });
      }

      // Parsear datos JSON
      let orderData = {};
      let aiContext = [];

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversaci√≥n activa:', e);
      }

      const response = {
        ...conversation,
        order_data: orderData,
        ai_context: aiContext
      };

      res.json({
        success: true,
        data: response
      });

    } catch (error) {
      logger.error('Error obteniendo conversaci√≥n activa:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo conversaci√≥n activa'
      });
    }
  });

  /**
   * Obtiene el estado de una conversaci√≥n
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversationStatus = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id || req.params.restaurantId;

      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de tel√©fono inv√°lido'
        });
      }

      const status = await ConversationService.getConversationStatus(restaurantId, customerPhone);

      if (!status) {
        return res.status(404).json({
          success: false,
          error: 'No hay conversaci√≥n activa'
        });
      }

      res.json({
        success: true,
        data: status
      });

    } catch (error) {
      logger.error('Error obteniendo estado de conversaci√≥n:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estado'
      });
    }
  });

  /**
   * Inicia una nueva conversaci√≥n
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static startConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.body;
      const restaurant = req.restaurant;

      if (!restaurant) {
        return res.status(400).json({
          success: false,
          error: 'Restaurante no identificado'
        });
      }

      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Tel√©fono del cliente requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de tel√©fono inv√°lido'
        });
      }

      // Iniciar conversaci√≥n usando el servicio
      const result = await ConversationService.startConversation(restaurant, customerPhone);

      logger.info('Conversaci√≥n iniciada manualmente', {
        restaurantId: restaurant.id,
        customerPhone: customerPhone.substring(0, 8) + '****',
        conversationId: result.conversation.id
      });

      res.status(201).json({
        success: true,
        message: 'Conversaci√≥n iniciada exitosamente',
        data: {
          conversation: result.conversation,
          customer: result.customer,
          send_result: result.sendResult
        }
      });

    } catch (error) {
      logger.error('Error iniciando conversaci√≥n:', error);
      res.status(500).json({
        success: false,
        error: 'Error iniciando conversaci√≥n'
      });
    }
  });

  /**
   * Reinicia una conversaci√≥n
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static restartConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id || req.params.restaurantId;

      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de tel√©fono inv√°lido'
        });
      }

      // Reiniciar conversaci√≥n usando el servicio
      const result = await ConversationService.restartConversation(restaurantId, customerPhone);

      logger.info('Conversaci√≥n reiniciada', {
        restaurantId,
        customerPhone: customerPhone.substring(0, 8) + '****',
        newConversationId: result.conversation.id
      });

      res.json({
        success: true,
        message: 'Conversaci√≥n reiniciada exitosamente',
        data: result
      });

    } catch (error) {
      logger.error('Error reiniciando conversaci√≥n:', error);
      res.status(500).json({
        success: false,
        error: 'Error reiniciando conversaci√≥n'
      });
    }
  });

  /**
   * Actualiza una conversaci√≥n
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateConversation = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversaci√≥n inv√°lido'
        });
      }

      const allowedFields = ['status', 'current_step', 'conversation_summary'];
      const updateData = {};

      Object.keys(req.body).forEach(key => {
        if (allowedFields.includes(key)) {
          updateData[key] = req.body[key];
        }
      });

      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No hay campos v√°lidos para actualizar'
        });
      }

      // Validar valores espec√≠ficos
      if (updateData.status && !Object.values(CONVERSATION_STATUS).includes(updateData.status)) {
        return res.status(400).json({
          success: false,
          error: 'Estado de conversaci√≥n inv√°lido'
        });
      }

      if (updateData.current_step && !Object.values(CONVERSATION_STEPS).includes(updateData.current_step)) {
        return res.status(400).json({
          success: false,
          error: 'Paso de conversaci√≥n inv√°lido'
        });
      }

      // Actualizar conversaci√≥n
      const updatedConversation = await Conversation.update(conversationId, updateData);

      logger.info('Conversaci√≥n actualizada', {
        conversationId,
        updatedFields: Object.keys(updateData)
      });

      res.json({
        success: true,
        message: 'Conversaci√≥n actualizada exitosamente',
        data: updatedConversation
      });

    } catch (error) {
      logger.error('Error actualizando conversaci√≥n:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Conversaci√≥n no encontrada'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando conversaci√≥n'
        });
      }
    }
  });

  /**
   * Marca una conversaci√≥n como abandonada
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static abandonConversation = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversaci√≥n inv√°lido'
        });
      }

      // Abandonar conversaci√≥n
      const abandonedConversation = await Conversation.abandon(conversationId);

      logger.info('Conversaci√≥n marcada como abandonada', { conversationId });

      res.json({
        success: true,
        message: 'Conversaci√≥n marcada como abandonada',
        data: abandonedConversation
      });

    } catch (error) {
      logger.error('Error marcando conversaci√≥n como abandonada:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Conversaci√≥n no encontrada'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error abandonando conversaci√≥n'
        });
      }
    }
  });

  /**
   * Simula un mensaje en una conversaci√≥n (para testing)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static simulateMessage = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;
      const { message, role = 'user' } = req.body;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversaci√≥n inv√°lido'
        });
      }

      if (!message || !message.trim()) {
        return res.status(400).json({
          success: false,
          error: 'Mensaje es requerido'
        });
      }

      if (!['user', 'assistant'].includes(role)) {
        return res.status(400).json({
          success: false,
          error: 'Role debe ser "user" o "assistant"'
        });
      }

      // Solo permitir en desarrollo
      if (process.env.NODE_ENV !== 'development') {
        return res.status(403).json({
          success: false,
          error: 'Funci√≥n solo disponible en desarrollo'
        });
      }

      // Agregar mensaje al contexto
      const updatedConversation = await Conversation.addToContext(conversationId, role, message);

      logger.info('Mensaje simulado agregado', {
        conversationId,
        role,
        messageLength: message.length
      });

      res.json({
        success: true,
        message: 'Mensaje simulado agregado exitosamente',
        data: updatedConversation
      });

    } catch (error) {
      logger.error('Error simulando mensaje:', error);
      res.status(500).json({
        success: false,
        error: 'Error simulando mensaje'
      });
    }
  });

  /**
   * Obtiene estad√≠sticas de conversaciones
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getConversationStatistics = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar par√°metros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(req.query);
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error
        });
      }

      const { start_date, end_date } = dateValidation.data;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      // Obtener estad√≠sticas usando el servicio
      const statistics = await ConversationService.getConversationStats(restaurantId, dateRange);

      logger.info('Estad√≠sticas de conversaciones obtenidas', {
        restaurantId,
        dateRange,
        totalConversations: statistics.total_conversations
      });

      res.json({
        success: true,
        data: statistics
      });

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de conversaciones:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estad√≠sticas'
      });
    }
  });

  /**
   * Limpia conversaciones inactivas
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static cleanupInactiveConversations = asyncHandler(async (req, res) => {
    try {
      const { max_inactive_hours = 2 } = req.query;
      const maxHours = parseInt(max_inactive_hours);

      if (maxHours < 1 || maxHours > 24) {
        return res.status(400).json({
          success: false,
          error: 'max_inactive_hours debe estar entre 1 y 24'
        });
      }

      // Limpiar conversaciones usando el servicio
      const cleanedCount = await ConversationService.cleanupInactiveConversations(maxHours);

      logger.info('Limpieza manual de conversaciones ejecutada', {
        maxInactiveHours: maxHours,
        cleanedCount
      });

      res.json({
        success: true,
        message: `Limpieza completada: ${cleanedCount} conversaciones marcadas como abandonadas`,
        data: {
          cleaned_count: cleanedCount,
          max_inactive_hours: maxHours
        }
      });

    } catch (error) {
      logger.error('Error limpiando conversaciones inactivas:', error);
      res.status(500).json({
        success: false,
        error: 'Error limpiando conversaciones'
      });
    }
  });

  /**
   * Env√≠a mensaje manual en una conversaci√≥n
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static sendManualMessage = asyncHandler(async (req, res) => {
    try {
      const { conversationId } = req.params;
      const { message } = req.body;

      if (!ValidationService.isValidUUID(conversationId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de conversaci√≥n inv√°lido'
        });
      }

      if (!message || !message.trim()) {
        return res.status(400).json({
          success: false,
          error: 'Mensaje es requerido'
        });
      }

      // Validar mensaje
      const validation = ValidationService.validateIncomingMessage(message, null);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      // Obtener conversaci√≥n para el tel√©fono del cliente
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) {
        return res.status(404).json({
          success: false,
          error: 'Conversaci√≥n no encontrada'
        });
      }

      // Enviar mensaje
      const sendResult = await WhatsAppService.sendMessage(
        conversation.customer_phone,
        message,
        { addEmojis: true }
      );

      // Agregar mensaje al contexto
      await Conversation.addToContext(conversationId, 'assistant', message);

      logger.info('Mensaje manual enviado en conversaci√≥n', {
        conversationId,
        customerPhone: conversation.customer_phone?.substring(0, 8) + '****',
        messageLength: message.length,
        success: sendResult.success
      });

      res.json({
        success: true,
        message: 'Mensaje enviado exitosamente',
        data: {
          conversation_id: conversationId,
          send_result: sendResult
        }
      });

    } catch (error) {
      logger.error('Error enviando mensaje manual:', error);
      res.status(500).json({
        success: false,
        error: 'Error enviando mensaje'
      });
    }
  });

  /**
   * Exporta conversaciones a CSV/JSON
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static exportConversations = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const { format = 'json', limit = 1000 } = req.query;

      if (!['json', 'csv'].includes(format)) {
        return res.status(400).json({
          success: false,
          error: 'Formato debe ser "json" o "csv"'
        });
      }

      const limitNumber = parseInt(limit);
      if (limitNumber < 1 || limitNumber > 10000) {
        return res.status(400).json({
          success: false,
          error: 'L√≠mite debe estar entre 1 y 10000'
        });
      }

      // Obtener conversaciones
      const result = await Conversation.getRecent(restaurantId, {
        page: 1,
        limit: limitNumber
      });

      const conversations = result.conversations;

      if (format === 'json') {
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename="conversations-${restaurantId}-${Date.now()}.json"`);
        
        res.json({
          restaurant_id: restaurantId,
          exported_at: new Date().toISOString(),
          total_conversations: conversations.length,
          conversations: conversations
        });
      } else {
        // CSV format (implementaci√≥n b√°sica)
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="conversations-${restaurantId}-${Date.now()}.csv"`);
        
        let csv = 'id,customer_phone,status,current_step,created_at,last_interaction_at,order_total\n';
        
        conversations.forEach(conv => {
          csv += `${conv.id},${conv.customer_phone},${conv.status},${conv.current_step},${conv.created_at},${conv.last_interaction_at},${conv.order_total || 0}\n`;
        });
        
        res.send(csv);
      }

      logger.info('Conversaciones exportadas', {
        restaurantId,
        format,
        count: conversations.length
      });

    } catch (error) {
      logger.error('Error exportando conversaciones:', error);
      res.status(500).json({
        success: false,
        error: 'Error exportando conversaciones'
      });
    }
  });
}

module.exports = ConversationController;


================================================
File: src/controllers/menuController.js
================================================
const Menu = require('../models/Menu');
const ValidationService = require('../services/validationService');
const logger = require('../utils/logger');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE MEN√ö
// ============================================

class MenuController {

  // ============================================
  // CATEGOR√çAS
  // ============================================

  /**
   * Obtiene todas las categor√≠as de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCategories = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inv√°lido'
        });
      }

      const { active_only = 'true' } = req.query;
      const activeOnly = active_only === 'true';

      const categories = await Menu.getCategories(restaurantId, activeOnly);

      logger.info('Categor√≠as de men√∫ obtenidas', {
        restaurantId,
        categoriesCount: categories.length,
        activeOnly
      });

      res.json({
        success: true,
        data: categories
      });

    } catch (error) {
      logger.error('Error obteniendo categor√≠as de men√∫:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo categor√≠as'
      });
    }
  });

  /**
   * Crea una nueva categor√≠a
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createCategory = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar datos de entrada
      const validation = ValidationService.validateMenuCategoryCreation(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const categoryData = validation.data;

      // Crear categor√≠a
      const category = await Menu.createCategory(restaurantId, categoryData);

      logger.info('Categor√≠a de men√∫ creada', {
        restaurantId,
        categoryId: category.id,
        name: category.name
      });

      res.status(201).json({
        success: true,
        message: 'Categor√≠a creada exitosamente',
        data: category
      });

    } catch (error) {
      logger.error('Error creando categor√≠a de men√∫:', error);
      
      if (error.message.includes('ya existe')) {
        res.status(409).json({
          success: false,
          error: 'Ya existe una categor√≠a con ese nombre'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error creando categor√≠a'
        });
      }
    }
  });

  /**
   * Actualiza una categor√≠a
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateCategory = asyncHandler(async (req, res) => {
    try {
      const { categoryId } = req.params;

      if (!ValidationService.isValidUUID(categoryId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de categor√≠a inv√°lido'
        });
      }

      // Validar que hay datos para actualizar
      if (!req.body || Object.keys(req.body).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No hay datos para actualizar'
        });
      }

      const updateData = req.body;

      // Validar campos espec√≠ficos si est√°n presentes
      const allowedFields = ['name', 'description', 'display_order', 'emoji', 'is_active'];
      const filteredData = {};

      Object.keys(updateData).forEach(key => {
        if (allowedFields.includes(key)) {
          filteredData[key] = updateData[key];
        }
      });

      if (Object.keys(filteredData).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No hay campos v√°lidos para actualizar'
        });
      }

      // Actualizar categor√≠a
      const updatedCategory = await Menu.updateCategory(categoryId, filteredData);

      logger.info('Categor√≠a actualizada', {
        categoryId,
        updatedFields: Object.keys(filteredData)
      });

      res.json({
        success: true,
        message: 'Categor√≠a actualizada exitosamente',
        data: updatedCategory
      });

    } catch (error) {
      logger.error('Error actualizando categor√≠a:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Categor√≠a no encontrada'
        });
      } else if (error.message.includes('ya existe')) {
        res.status(409).json({
          success: false,
          error: 'Ya existe una categor√≠a con ese nombre'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando categor√≠a'
        });
      }
    }
  });

  // ============================================
  // MEN√ö COMPLETO
  // ============================================

  /**
   * Obtiene el men√∫ completo de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getFullMenu = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inv√°lido'
        });
      }

      const { available_only = 'true' } = req.query;
      const availableOnly = available_only === 'true';

      const menu = await Menu.getFullMenu(restaurantId, availableOnly);

      logger.info('Men√∫ completo obtenido', {
        restaurantId,
        categoriesCount: menu.categories.length,
        totalItems: menu.total_items,
        availableOnly
      });

      res.json({
        success: true,
        data: menu
      });

    } catch (error) {
      logger.error('Error obteniendo men√∫ completo:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo men√∫'
      });
    }
  });

  // ============================================
  // ITEMS DEL MEN√ö
  // ============================================

  /**
   * Obtiene un item espec√≠fico del men√∫
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getMenuItem = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;
      const restaurantId = req.restaurant?.id;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inv√°lido'
        });
      }

      const item = await Menu.getItem(itemId, restaurantId);

      if (!item) {
        return res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      }

      logger.info('Item de men√∫ obtenido', {
        itemId,
        itemName: item.name,
        restaurantId: restaurantId || 'any'
      });

      res.json({
        success: true,
        data: item
      });

    } catch (error) {
      logger.error('Error obteniendo item de men√∫:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo item'
      });
    }
  });

  /**
   * Crea un nuevo item del men√∫
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createMenuItem = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar datos de entrada
      const validation = ValidationService.validateMenuItemCreation(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const itemData = validation.data;

      // Crear item
      const item = await Menu.createItem(restaurantId, itemData);

      logger.info('Item de men√∫ creado', {
        restaurantId,
        itemId: item.id,
        name: item.name,
        price: item.price
      });

      res.status(201).json({
        success: true,
        message: 'Item creado exitosamente',
        data: item
      });

    } catch (error) {
      logger.error('Error creando item de men√∫:', error);
      
      if (error.message.includes('no pertenece')) {
        res.status(400).json({
          success: false,
          error: 'La categor√≠a no pertenece a este restaurante'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error creando item'
        });
      }
    }
  });

  /**
   * Actualiza un item del men√∫
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateMenuItem = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inv√°lido'
        });
      }

      // Validar datos de actualizaci√≥n
      const validation = ValidationService.validateMenuItemUpdate(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const updateData = validation.data;

      // Actualizar item
      const updatedItem = await Menu.updateItem(itemId, updateData);

      logger.info('Item de men√∫ actualizado', {
        itemId,
        updatedFields: Object.keys(updateData)
      });

      res.json({
        success: true,
        message: 'Item actualizado exitosamente',
        data: updatedItem
      });

    } catch (error) {
      logger.error('Error actualizando item de men√∫:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando item'
        });
      }
    }
  });

  /**
   * Cambia la disponibilidad de un item
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static toggleItemAvailability = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;
      const { is_available } = req.body;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inv√°lido'
        });
      }

      if (typeof is_available !== 'boolean') {
        return res.status(400).json({
          success: false,
          error: 'is_available debe ser booleano'
        });
      }

      // Actualizar disponibilidad
      const success = await Menu.setItemAvailability(itemId, is_available);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      }

      logger.info('Disponibilidad de item actualizada', {
        itemId,
        isAvailable: is_available
      });

      res.json({
        success: true,
        message: `Item ${is_available ? 'activado' : 'desactivado'} exitosamente`,
        data: {
          item_id: itemId,
          is_available
        }
      });

    } catch (error) {
      logger.error('Error cambiando disponibilidad de item:', error);
      res.status(500).json({
        success: false,
        error: 'Error actualizando disponibilidad'
      });
    }
  });

  /**
   * Elimina un item del men√∫
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static deleteMenuItem = asyncHandler(async (req, res) => {
    try {
      const { itemId } = req.params;

      if (!ValidationService.isValidUUID(itemId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de item inv√°lido'
        });
      }

      // Eliminar item (soft delete si tiene pedidos asociados)
      const success = await Menu.deleteItem(itemId);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: 'Item no encontrado'
        });
      }

      logger.info('Item de men√∫ eliminado', { itemId });

      res.json({
        success: true,
        message: 'Item eliminado exitosamente'
      });

    } catch (error) {
      logger.error('Error eliminando item de men√∫:', error);
      res.status(500).json({
        success: false,
        error: 'Error eliminando item'
      });
    }
  });

  // ============================================
  // B√öSQUEDA Y FILTROS
  // ============================================

  /**
   * Busca items en el men√∫
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static searchMenuItems = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const {
        q: searchTerm = '',
        category_id = null,
        min_price = null,
        max_price = null,
        available_only = 'true'
      } = req.query;

      // Validar par√°metros
      if (category_id && !ValidationService.isValidUUID(category_id)) {
        return res.status(400).json({
          success: false,
          error: 'ID de categor√≠a inv√°lido'
        });
      }

      const filters = {
        categoryId: category_id,
        minPrice: min_price ? parseFloat(min_price) : null,
        maxPrice: max_price ? parseFloat(max_price) : null,
        availableOnly: available_only === 'true'
      };

      // Realizar b√∫squeda
      const items = await Menu.searchItems(restaurantId, searchTerm, filters);

      logger.info('B√∫squeda de items realizada', {
        restaurantId,
        searchTerm,
        filtersApplied: Object.keys(filters).filter(key => filters[key] !== null).length,
        resultsCount: items.length
      });

      res.json({
        success: true,
        data: {
          items,
          search_term: searchTerm,
          filters_applied: filters,
          results_count: items.length
        }
      });

    } catch (error) {
      logger.error('Error buscando items de men√∫:', error);
      res.status(500).json({
        success: false,
        error: 'Error realizando b√∫squeda'
      });
    }
  });

  /**
   * Obtiene items m√°s populares
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getPopularItems = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const { limit = 10 } = req.query;
      const limitNumber = parseInt(limit);

      if (limitNumber < 1 || limitNumber > 50) {
        return res.status(400).json({
          success: false,
          error: 'L√≠mite debe estar entre 1 y 50'
        });
      }

      const popularItems = await Menu.getPopularItems(restaurantId, limitNumber);

      logger.info('Items populares obtenidos', {
        restaurantId,
        limit: limitNumber,
        itemsFound: popularItems.length
      });

      res.json({
        success: true,
        data: {
          items: popularItems,
          limit: limitNumber,
          generated_at: new Date().toISOString()
        }
      });

    } catch (error) {
      logger.error('Error obteniendo items populares:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo items populares'
      });
    }
  });

  // ============================================
  // OPERACIONES EN LOTE
  // ============================================

  /**
   * Actualiza orden de display de items
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateDisplayOrder = asyncHandler(async (req, res) => {
    try {
      const { updates } = req.body;

      if (!Array.isArray(updates) || updates.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un array de actualizaciones'
        });
      }

      // Validar estructura de actualizaciones
      for (const update of updates) {
        if (!update.id || !ValidationService.isValidUUID(update.id)) {
          return res.status(400).json({
            success: false,
            error: 'ID inv√°lido en actualizaciones'
          });
        }

        if (typeof update.display_order !== 'number' || update.display_order < 0) {
          return res.status(400).json({
            success: false,
            error: 'display_order debe ser un n√∫mero no negativo'
          });
        }
      }

      // Actualizar orden
      const success = await Menu.updateDisplayOrder(updates);

      if (!success) {
        return res.status(500).json({
          success: false,
          error: 'Error actualizando orden'
        });
      }

      logger.info('Orden de display actualizado', {
        updatesCount: updates.length
      });

      res.json({
        success: true,
        message: 'Orden actualizado exitosamente',
        data: {
          updated_items: updates.length
        }
      });

    } catch (error) {
      logger.error('Error actualizando orden de display:', error);
      res.status(500).json({
        success: false,
        error: 'Error actualizando orden'
      });
    }
  });

  /**
   * Operaci√≥n en lote para cambiar disponibilidad
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static batchUpdateAvailability = asyncHandler(async (req, res) => {
    try {
      const { item_ids, is_available } = req.body;

      if (!Array.isArray(item_ids) || item_ids.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un array de IDs de items'
        });
      }

      if (typeof is_available !== 'boolean') {
        return res.status(400).json({
          success: false,
          error: 'is_available debe ser booleano'
        });
      }

      // Validar IDs
      for (const itemId of item_ids) {
        if (!ValidationService.isValidUUID(itemId)) {
          return res.status(400).json({
            success: false,
            error: `ID inv√°lido: ${itemId}`
          });
        }
      }

      // Actualizar disponibilidad de cada item
      const results = [];
      let successCount = 0;
      let errorCount = 0;

      for (const itemId of item_ids) {
        try {
          const success = await Menu.setItemAvailability(itemId, is_available);
          results.push({ item_id: itemId, success });
          if (success) successCount++;
          else errorCount++;
        } catch (error) {
          results.push({ item_id: itemId, success: false, error: error.message });
          errorCount++;
        }
      }

      logger.info('Actualizaci√≥n en lote de disponibilidad completada', {
        totalItems: item_ids.length,
        successCount,
        errorCount,
        isAvailable: is_available
      });

      res.json({
        success: true,
        message: `Disponibilidad actualizada: ${successCount} exitosos, ${errorCount} errores`,
        data: {
          results,
          summary: {
            total: item_ids.length,
            successful: successCount,
            failed: errorCount
          }
        }
      });

    } catch (error) {
      logger.error('Error en actualizaci√≥n en lote:', error);
      res.status(500).json({
        success: false,
        error: 'Error en actualizaci√≥n en lote'
      });
    }
  });

  // ============================================
  // UTILIDADES
  // ============================================

  /**
   * Obtiene resumen del men√∫
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getMenuSummary = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Obtener categor√≠as y items populares
      const [categories, popularItems] = await Promise.all([
        Menu.getCategories(restaurantId, true),
        Menu.getPopularItems(restaurantId, 5)
      ]);

      const totalItems = categories.reduce((sum, cat) => sum + parseInt(cat.items_count), 0);
      const totalCategories = categories.length;

      const summary = {
        restaurant_id: restaurantId,
        total_categories: totalCategories,
        total_items: totalItems,
        categories: categories.map(cat => ({
          id: cat.id,
          name: cat.name,
          emoji: cat.emoji,
          items_count: cat.items_count
        })),
        popular_items: popularItems.slice(0, 5),
        generated_at: new Date().toISOString()
      };

      res.json({
        success: true,
        data: summary
      });

    } catch (error) {
      logger.error('Error obteniendo resumen del men√∫:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo resumen'
      });
    }
  });
}

module.exports = MenuController;


================================================
File: src/controllers/orderController.js
================================================
const Order = require('../models/Order');
const OrderService = require('../services/orderService');
const ValidationService = require('../services/validationService');
const logger = require('../utils/logger');
const { ORDER_STATUS } = require('../utils/constants');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE PEDIDOS
// ============================================

class OrderController {

  /**
   * Obtiene pedidos de un restaurante con filtros
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrders = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      if (!ValidationService.isValidUUID(restaurantId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante inv√°lido'
        });
      }

      // Validar par√°metros de paginaci√≥n
      const paginationValidation = ValidationService.validatePaginationParams(req.query);
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error
        });
      }

      const { page, limit, sort_by, sort_order } = paginationValidation.data;

      // Preparar filtros
      const filters = {
        page,
        limit,
        sort_by,
        sort_order,
        status: req.query.status,
        customer_phone: req.query.customer_phone,
        start_date: req.query.start_date,
        end_date: req.query.end_date
      };

      // Validar fechas si est√°n presentes
      if (filters.start_date || filters.end_date) {
        const dateValidation = ValidationService.validateDateRangeParams({
          start_date: filters.start_date,
          end_date: filters.end_date
        });
        
        if (!dateValidation.isValid) {
          return res.status(400).json({
            success: false,
            error: dateValidation.error
          });
        }
      }

      // Obtener pedidos
      const result = await Order.findByRestaurant(restaurantId, filters);

      logger.info('Pedidos obtenidos', {
        restaurantId,
        page,
        limit,
        totalItems: result.pagination.total_items,
        filtersApplied: Object.keys(filters).filter(key => filters[key]).length
      });

      res.json({
        success: true,
        data: result.orders,
        pagination: result.pagination,
        filters_applied: filters
      });

    } catch (error) {
      logger.error('Error obteniendo pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedidos'
      });
    }
  });

  /**
   * Obtiene un pedido espec√≠fico por ID
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrderById = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;
      const restaurantId = req.restaurant?.id;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inv√°lido'
        });
      }

      const order = await Order.findById(orderId, restaurantId);

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Pedido no encontrado'
        });
      }

      logger.info('Pedido obtenido por ID', {
        orderId,
        restaurantId: order.restaurant_id,
        status: order.status
      });

      res.json({
        success: true,
        data: order
      });

    } catch (error) {
      logger.error('Error obteniendo pedido por ID:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedido'
      });
    }
  });

  /**
   * Crea un nuevo pedido manualmente
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createOrder = asyncHandler(async (req, res) => {
    try {
      // Validar datos del pedido
      const validation = ValidationService.validateOrderCreation(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const orderData = validation.data;

      // Validar direcci√≥n de entrega
      const addressValidation = ValidationService.validateDeliveryAddress(orderData.delivery_address);
      if (!addressValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: `Direcci√≥n inv√°lida: ${addressValidation.error}`
        });
      }

      // Expandir datos de direcci√≥n
      const expandedOrderData = {
        ...orderData,
        delivery_street: orderData.delivery_address.street,
        delivery_number: orderData.delivery_address.number,
        delivery_neighborhood: orderData.delivery_address.neighborhood,
        delivery_references: orderData.delivery_address.references,
        delivery_postal_code: orderData.delivery_address.postal_code
      };

      // Calcular tiempo estimado de entrega
      const estimatedTime = await Order.calculateDeliveryTime(
        orderData.restaurant_id,
        orderData.delivery_address.neighborhood
      );
      expandedOrderData.estimated_delivery_time = estimatedTime;

      // Crear pedido
      const order = await Order.create(expandedOrderData);

      logger.info('Pedido creado manualmente', {
        orderId: order.id,
        restaurantId: order.restaurant_id,
        customerPhone: order.customer_phone?.substring(0, 8) + '****',
        total: order.total
      });

      res.status(201).json({
        success: true,
        message: 'Pedido creado exitosamente',
        data: order
      });

    } catch (error) {
      logger.error('Error creando pedido:', error);
      res.status(500).json({
        success: false,
        error: 'Error creando pedido'
      });
    }
  });

  /**
   * Actualiza el estado de un pedido
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateOrderStatus = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inv√°lido'
        });
      }

      // Validar datos de actualizaci√≥n
      const validation = ValidationService.validateOrderStatusUpdate(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      const { status, internal_notes, estimated_delivery_time } = validation.data;

      // Actualizar estado usando el servicio
      const updatedOrder = await OrderService.updateOrderStatus(orderId, status, {
        internal_notes,
        estimated_delivery_time,
        notify_customer: req.body.notify_customer !== false, // Default true
        restaurant: req.restaurant
      });

      logger.info('Estado de pedido actualizado', {
        orderId,
        newStatus: status,
        notifyCustomer: req.body.notify_customer !== false
      });

      res.json({
        success: true,
        message: 'Estado actualizado exitosamente',
        data: updatedOrder
      });

    } catch (error) {
      logger.error('Error actualizando estado de pedido:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Pedido no encontrado'
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error actualizando pedido'
        });
      }
    }
  });

  /**
   * Cancela un pedido
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static cancelOrder = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;
      const { reason, notify_customer = true } = req.body;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inv√°lido'
        });
      }

      if (!reason || reason.trim().length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Raz√≥n de cancelaci√≥n es requerida'
        });
      }

      // Cancelar pedido usando el servicio
      const cancelledOrder = await OrderService.cancelOrder(orderId, reason, {
        notify_customer,
        cancelled_by: 'restaurant'
      });

      logger.info('Pedido cancelado', {
        orderId,
        reason,
        notifyCustomer: notify_customer
      });

      res.json({
        success: true,
        message: 'Pedido cancelado exitosamente',
        data: cancelledOrder
      });

    } catch (error) {
      logger.error('Error cancelando pedido:', error);
      
      if (error.message.includes('no encontrado')) {
        res.status(404).json({
          success: false,
          error: 'Pedido no encontrado'
        });
      } else if (error.message.includes('no se puede cancelar')) {
        res.status(400).json({
          success: false,
          error: error.message
        });
      } else {
        res.status(500).json({
          success: false,
          error: 'Error cancelando pedido'
        });
      }
    }
  });

  /**
   * Obtiene pedidos activos (en preparaci√≥n/camino)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getActiveOrders = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      const activeOrders = await OrderService.getActiveOrders(restaurantId);

      logger.info('Pedidos activos obtenidos', {
        restaurantId,
        count: activeOrders.length,
        delayedCount: activeOrders.filter(o => o.is_delayed).length,
        urgentCount: activeOrders.filter(o => o.is_urgent).length
      });

      res.json({
        success: true,
        data: {
          orders: activeOrders,
          summary: {
            total: activeOrders.length,
            delayed: activeOrders.filter(o => o.is_delayed).length,
            urgent: activeOrders.filter(o => o.is_urgent).length,
            on_time: activeOrders.filter(o => !o.is_delayed && !o.is_urgent).length
          }
        }
      });

    } catch (error) {
      logger.error('Error obteniendo pedidos activos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedidos activos'
      });
    }
  });

  /**
   * Obtiene estad√≠sticas de pedidos
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrderStatistics = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar par√°metros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(req.query);
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error
        });
      }

      const { start_date, end_date } = dateValidation.data;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      // Obtener estad√≠sticas usando el servicio
      const statistics = await OrderService.getOrderStatistics(restaurantId, dateRange);

      logger.info('Estad√≠sticas de pedidos obtenidas', {
        restaurantId,
        dateRange,
        totalOrders: statistics.basic.total_orders
      });

      res.json({
        success: true,
        data: statistics
      });

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estad√≠sticas'
      });
    }
  });

  /**
   * Busca pedidos con filtros avanzados
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static searchOrders = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar par√°metros de paginaci√≥n
      const paginationValidation = ValidationService.validatePaginationParams(req.query);
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error
        });
      }

      const filters = {
        ...paginationValidation.data,
        customer_phone: req.query.customer_phone,
        status: req.query.status,
        start_date: req.query.start_date,
        end_date: req.query.end_date,
        min_total: req.query.min_total ? parseFloat(req.query.min_total) : null,
        max_total: req.query.max_total ? parseFloat(req.query.max_total) : null,
        neighborhood: req.query.neighborhood
      };

      // Realizar b√∫squeda
      const results = await OrderService.searchOrders(restaurantId, filters);

      logger.info('B√∫squeda de pedidos realizada', {
        restaurantId,
        filtersCount: Object.keys(filters).filter(key => filters[key]).length,
        resultsCount: results.pagination.total_items
      });

      res.json({
        success: true,
        data: results.orders,
        pagination: results.pagination,
        filters_applied: filters
      });

    } catch (error) {
      logger.error('Error buscando pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error realizando b√∫squeda'
      });
    }
  });

  /**
   * Obtiene pedidos de un cliente espec√≠fico
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCustomerOrders = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.params;
      const restaurantId = req.restaurant?.id;
      const { limit = 10 } = req.query;

      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Tel√©fono del cliente requerido'
        });
      }

      if (!ValidationService.isValidMexicanPhone(customerPhone)) {
        return res.status(400).json({
          success: false,
          error: 'Formato de tel√©fono inv√°lido'
        });
      }

      const limitNumber = parseInt(limit);
      if (limitNumber < 1 || limitNumber > 50) {
        return res.status(400).json({
          success: false,
          error: 'L√≠mite debe estar entre 1 y 50'
        });
      }

      // Obtener pedidos del cliente
      const orders = await Order.findByCustomer(customerPhone, restaurantId, limitNumber);

      logger.info('Pedidos de cliente obtenidos', {
        customerPhone: customerPhone.substring(0, 8) + '****',
        restaurantId: restaurantId || 'all',
        ordersFound: orders.length
      });

      res.json({
        success: true,
        data: {
          customer_phone: customerPhone,
          orders,
          total_found: orders.length
        }
      });

    } catch (error) {
      logger.error('Error obteniendo pedidos de cliente:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo pedidos del cliente'
      });
    }
  });

  /**
   * Genera reporte de ventas
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static generateSalesReport = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Validar par√°metros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(req.query);
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error
        });
      }

      const {
        start_date,
        end_date,
        group_by = 'day',
        include_items = 'false'
      } = req.query;

      const options = {
        start_date,
        end_date,
        group_by,
        include_items: include_items === 'true'
      };

      // Generar reporte
      const report = await OrderService.generateSalesReport(restaurantId, options);

      logger.info('Reporte de ventas generado', {
        restaurantId,
        dateRange: { start_date, end_date },
        groupBy: group_by,
        includeItems: options.include_items
      });

      res.json({
        success: true,
        data: report
      });

    } catch (error) {
      logger.error('Error generando reporte de ventas:', error);
      res.status(500).json({
        success: false,
        error: 'Error generando reporte'
      });
    }
  });

  /**
   * Valida si un pedido puede ser modificado
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static validateOrderModification = asyncHandler(async (req, res) => {
    try {
      const { orderId } = req.params;

      if (!ValidationService.isValidUUID(orderId)) {
        return res.status(400).json({
          success: false,
          error: 'ID de pedido inv√°lido'
        });
      }

      // Validar modificaci√≥n usando el servicio
      const validation = await OrderService.validateOrderModification(orderId);

      res.json({
        success: true,
        data: {
          can_modify: validation.canModify,
          reason: validation.reason,
          order: validation.order || null
        }
      });

    } catch (error) {
      logger.error('Error validando modificaci√≥n de pedido:', error);
      res.status(500).json({
        success: false,
        error: 'Error validando modificaci√≥n'
      });
    }
  });

  /**
   * Obtiene resumen r√°pido de pedidos
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getOrdersSummary = asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant?.id || req.params.restaurantId;
      
      if (!restaurantId) {
        return res.status(400).json({
          success: false,
          error: 'ID de restaurante requerido'
        });
      }

      // Obtener res√∫menes de diferentes per√≠odos
      const [todaySummary, weekSummary, monthSummary] = await Promise.all([
        Order.getSalesSummary(restaurantId, 'today'),
        Order.getSalesSummary(restaurantId, 'week'),
        Order.getSalesSummary(restaurantId, 'month')
      ]);

      // Obtener pedidos activos
      const activeOrders = await OrderService.getActiveOrders(restaurantId);

      const summary = {
        restaurant_id: restaurantId,
        active_orders: {
          total: activeOrders.length,
          delayed: activeOrders.filter(o => o.is_delayed).length,
          urgent: activeOrders.filter(o => o.is_urgent).length
        },
        sales_summary: {
          today: todaySummary,
          week: weekSummary,
          month: monthSummary
        },
        generated_at: new Date().toISOString()
      };

      res.json({
        success: true,
        data: summary
      });

    } catch (error) {
      logger.error('Error obteniendo resumen de pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo resumen'
      });
    }
  });

  /**
   * Actualiza m√∫ltiples pedidos en lote
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static batchUpdateOrders = asyncHandler(async (req, res) => {
    try {
      const { updates } = req.body;

      if (!Array.isArray(updates) || updates.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Se requiere un array de actualizaciones'
        });
      }

      if (updates.length > 50) {
        return res.status(400).json({
          success: false,
          error: 'M√°ximo 50 actualizaciones por lote'
        });
      }

      // Validar estructura de actualizaciones  
      for (const update of updates) {
        if (!update.order_id || !ValidationService.isValidUUID(update.order_id)) {
          return res.status(400).json({
            success: false,
            error: 'ID de pedido inv√°lido en actualizaciones'
          });
        }

        if (!update.status || !Object.values(ORDER_STATUS).includes(update.status)) {
          return res.status(400).json({
            success: false,
            error: 'Estado inv√°lido en actualizaciones'
          });
        }
      }

      // Procesar actualizaciones
      const results = [];
      let successCount = 0;
      let errorCount = 0;

      for (const update of updates) {
        try {
          const updatedOrder = await OrderService.updateOrderStatus(
            update.order_id,
            update.status,
            {
              internal_notes: update.internal_notes,
              notify_customer: update.notify_customer !== false
            }
          );

          results.push({
            order_id: update.order_id,
            success: true,
            new_status: update.status
          });
          successCount++;

        } catch (error) {
          results.push({
            order_id: update.order_id,
            success: false,
            error: error.message
          });
          errorCount++;
        }
      }

      logger.info('Actualizaci√≥n en lote de pedidos completada', {
        totalUpdates: updates.length,
        successCount,
        errorCount
      });

      res.json({
        success: true,
        message: `Actualizaciones completadas: ${successCount} exitosas, ${errorCount} errores`,
        data: {
          results,
          summary: {
            total: updates.length,
            successful: successCount,
            failed: errorCount
          }
        }
      });

    } catch (error) {
      logger.error('Error en actualizaci√≥n en lote de pedidos:', error);
      res.status(500).json({
        success: false,
        error: 'Error en actualizaci√≥n en lote'
      });
    }
  });
}

module.exports = OrderController;


================================================
File: src/controllers/restaurantController.js
================================================
const Restaurant = require("../models/Restaurant");
const ValidationService = require("../services/validationService");
const logger = require("../utils/logger");
const { asyncHandler } = require("../middleware/errorHandler");

// ============================================
// CONTROLADOR DE RESTAURANTES
// ============================================

class RestaurantController {
  /**
   * Obtiene lista de restaurantes con paginaci√≥n
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getAllRestaurants = asyncHandler(async (req, res) => {
    try {
      // Validar par√°metros de consulta
      const paginationValidation = ValidationService.validatePaginationParams(
        req.query
      );
      if (!paginationValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: paginationValidation.error,
        });
      }

      const { page, limit, sort_by, sort_order } = paginationValidation.data;

      const { search = "", is_active = null } = req.query;

      // Obtener restaurantes
      const result = await Restaurant.findAll({
        page,
        limit,
        search,
        isActive: is_active !== null ? is_active === "true" : null,
        sortBy: sort_by,
        sortOrder: sort_order,
      });

      logger.info("Lista de restaurantes obtenida", {
        page,
        limit,
        total: result.pagination.total_items,
        search: search || "none",
      });

      res.json({
        success: true,
        data: result.restaurants,
        pagination: result.pagination,
      });
    } catch (error) {
      logger.error("Error obteniendo lista de restaurantes:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurantes",
      });
    }
  });

  /**
   * Obtiene un restaurante por ID
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getRestaurantById = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inv√°lido",
        });
      }

      const restaurant = await Restaurant.findById(id);

      if (!restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante obtenido por ID", {
        restaurantId: id,
        restaurantName: restaurant.name,
      });

      res.json({
        success: true,
        data: restaurant,
      });
    } catch (error) {
      logger.error("Error obteniendo restaurante por ID:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurante",
      });
    }
  });

  /**
   * Obtiene un restaurante por slug
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getRestaurantBySlug = asyncHandler(async (req, res) => {
    try {
      const { slug } = req.params;

      if (!slug || slug.length < 2) {
        return res.status(400).json({
          success: false,
          error: "Slug inv√°lido",
        });
      }

      const restaurant = await Restaurant.findBySlug(slug);

      if (!restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante obtenido por slug", {
        slug,
        restaurantId: restaurant.id,
        restaurantName: restaurant.name,
      });

      res.json({
        success: true,
        data: restaurant,
      });
    } catch (error) {
      logger.error("Error obteniendo restaurante por slug:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurante",
      });
    }
  });

  /**
   * Crea un nuevo restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static createRestaurant = asyncHandler(async (req, res) => {
  try {
    console.log('üì• 1. Datos recibidos en backend:', JSON.stringify(req.body, null, 2));

    // ‚úÖ USAR VALIDACI√ìN DE JOI
    const validation = ValidationService.validateRestaurantCreation(req.body);
    if (!validation.isValid) {
      console.log('‚ùå Error de validaci√≥n:', validation.error);
      return res.status(400).json({
        success: false,
        error: validation.error
      });
    }

    console.log('‚úÖ Validaci√≥n de Joi pasada');

    const restaurantData = validation.data;

    console.log('üìä 2. Datos validados:', JSON.stringify(restaurantData, null, 2));

    // Verificar slug disponible
    console.log('üîç 3. Verificando disponibilidad de slug...');
    const isSlugAvailable = await Restaurant.isSlugAvailable(restaurantData.slug);
    console.log('üìù 4. Slug disponible:', isSlugAvailable);
    
    if (!isSlugAvailable) {
      console.log('‚ùå Slug no disponible');
      return res.status(409).json({
        success: false,
        error: 'El slug ya est√° en uso'
      });
    }

    console.log('‚úÖ 5. Slug disponible, creando restaurante...');

    // Crear restaurante
    const restaurant = await Restaurant.create(restaurantData);

    console.log('‚úÖ 6. Restaurante creado exitosamente:', restaurant);

    res.status(201).json({
      success: true,
      message: 'Restaurante creado exitosamente',
      data: restaurant
    });

  } catch (error) {
    console.error('üî¥ ERROR COMPLETO:', {
      message: error.message,
      stack: error.stack,
      code: error.code,
      detail: error.detail
    });
    
    res.status(500).json({
      success: false,
      error: 'Error creando restaurante: ' + error.message
    });
  }
});

  /**
   * Actualiza un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateRestaurant = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inv√°lido",
        });
      }

      // Validar datos de actualizaci√≥n
      const validation = ValidationService.validateRestaurantUpdate(req.body);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error,
        });
      }

      const updateData = validation.data;

      // Si se est√° actualizando el slug, verificar disponibilidad
      if (updateData.slug) {
        const isSlugAvailable = await Restaurant.isSlugAvailable(
          updateData.slug,
          id
        );
        if (!isSlugAvailable) {
          return res.status(409).json({
            success: false,
            error: "El slug ya est√° en uso",
          });
        }
      }

      // Actualizar restaurante
      const updatedRestaurant = await Restaurant.update(id, updateData);

      logger.info("Restaurante actualizado", {
        restaurantId: id,
        updatedFields: Object.keys(updateData),
      });

      res.json({
        success: true,
        message: "Restaurante actualizado exitosamente",
        data: updatedRestaurant,
      });
    } catch (error) {
      logger.error("Error actualizando restaurante:", error);

      if (error.message.includes("no encontrado")) {
        res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      } else if (error.message.includes("ya est√° en uso")) {
        res.status(409).json({
          success: false,
          error: error.message,
        });
      } else {
        res.status(500).json({
          success: false,
          error: "Error actualizando restaurante",
        });
      }
    }
  });

  /**
   * Actualiza configuraci√≥n de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateRestaurantSettings = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inv√°lido",
        });
      }

      const {
        claude_api_key,
        claude_model,
        ai_personality,
        welcome_message,
        goodbye_message,
        error_message,
        auto_confirm_orders,
        require_phone_validation,
        max_conversation_time,
        notification_email,
        notification_phone,
      } = req.body;

      // Validar campos espec√≠ficos si est√°n presentes
      if (
        notification_email &&
        !ValidationService.isValidEmail(notification_email)
      ) {
        return res.status(400).json({
          success: false,
          error: "Email de notificaci√≥n inv√°lido",
        });
      }

      if (
        notification_phone &&
        !ValidationService.isValidMexicanPhone(notification_phone)
      ) {
        return res.status(400).json({
          success: false,
          error: "Tel√©fono de notificaci√≥n inv√°lido",
        });
      }

      const settingsData = {
        claude_api_key,
        claude_model,
        ai_personality,
        welcome_message,
        goodbye_message,
        error_message,
        auto_confirm_orders,
        require_phone_validation,
        max_conversation_time,
        notification_email,
        notification_phone,
      };

      // Remover campos undefined
      Object.keys(settingsData).forEach((key) => {
        if (settingsData[key] === undefined) {
          delete settingsData[key];
        }
      });

      if (Object.keys(settingsData).length === 0) {
        return res.status(400).json({
          success: false,
          error: "No hay configuraciones para actualizar",
        });
      }

      // Actualizar configuraci√≥n
      const updatedSettings = await Restaurant.updateSettings(id, settingsData);

      logger.info("Configuraci√≥n de restaurante actualizada", {
        restaurantId: id,
        updatedFields: Object.keys(settingsData),
      });

      res.json({
        success: true,
        message: "Configuraci√≥n actualizada exitosamente",
        data: updatedSettings,
      });
    } catch (error) {
      logger.error("Error actualizando configuraci√≥n de restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error actualizando configuraci√≥n",
      });
    }
  });

  /**
   * Desactiva un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static deactivateRestaurant = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inv√°lido",
        });
      }

      const success = await Restaurant.deactivate(id);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante desactivado", { restaurantId: id });

      res.json({
        success: true,
        message: "Restaurante desactivado exitosamente",
      });
    } catch (error) {
      logger.error("Error desactivando restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error desactivando restaurante",
      });
    }
  });

  /**
   * Activa un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static activateRestaurant = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inv√°lido",
        });
      }

      const success = await Restaurant.activate(id);

      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      logger.info("Restaurante activado", { restaurantId: id });

      res.json({
        success: true,
        message: "Restaurante activado exitosamente",
      });
    } catch (error) {
      logger.error("Error activando restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error activando restaurante",
      });
    }
  });

  /**
   * Obtiene estad√≠sticas de un restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getRestaurantStats = asyncHandler(async (req, res) => {
    try {
      const { id } = req.params;

      if (!ValidationService.isValidUUID(id)) {
        return res.status(400).json({
          success: false,
          error: "ID de restaurante inv√°lido",
        });
      }

      // Validar par√°metros de fecha
      const dateValidation = ValidationService.validateDateRangeParams(
        req.query
      );
      if (!dateValidation.isValid) {
        return res.status(400).json({
          success: false,
          error: dateValidation.error,
        });
      }

      const { start_date, end_date } = dateValidation.data;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      // Obtener estad√≠sticas
      const stats = await Restaurant.getStats(id, dateRange);

      logger.info("Estad√≠sticas de restaurante obtenidas", {
        restaurantId: id,
        dateRange: dateRange,
      });

      res.json({
        success: true,
        data: stats,
      });
    } catch (error) {
      logger.error("Error obteniendo estad√≠sticas de restaurante:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo estad√≠sticas",
      });
    }
  });

  /**
   * Verifica disponibilidad de slug
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static checkSlugAvailability = asyncHandler(async (req, res) => {
    try {
      const { slug } = req.params;
      const { exclude_id } = req.query;

      if (!slug || slug.length < 2) {
        return res.status(400).json({
          success: false,
          error: "Slug inv√°lido",
        });
      }

      if (exclude_id && !ValidationService.isValidUUID(exclude_id)) {
        return res.status(400).json({
          success: false,
          error: "ID de exclusi√≥n inv√°lido",
        });
      }

      const isAvailable = await Restaurant.isSlugAvailable(slug, exclude_id);

      res.json({
        success: true,
        data: {
          slug,
          available: isAvailable,
        },
      });
    } catch (error) {
      logger.error("Error verificando disponibilidad de slug:", error);
      res.status(500).json({
        success: false,
        error: "Error verificando disponibilidad",
      });
    }
  });

  /**
   * Obtiene el restaurante actual (basado en el middleware de tenant)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCurrentRestaurant = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      // Obtener datos completos del restaurante
      const restaurant = await Restaurant.findById(req.restaurant.id);

      if (!restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no encontrado",
        });
      }

      res.json({
        success: true,
        data: restaurant,
      });
    } catch (error) {
      logger.error("Error obteniendo restaurante actual:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo restaurante",
      });
    }
  });

  /**
   * Actualiza el restaurante actual
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static updateCurrentRestaurant = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      // Reutilizar l√≥gica de actualizaci√≥n
      req.params.id = req.restaurant.id;
      return RestaurantController.updateRestaurant(req, res);
    } catch (error) {
      logger.error("Error actualizando restaurante actual:", error);
      res.status(500).json({
        success: false,
        error: "Error actualizando restaurante",
      });
    }
  });

  /**
   * Obtiene estad√≠sticas del restaurante actual
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getCurrentRestaurantStats = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      // Reutilizar l√≥gica de estad√≠sticas
      req.params.id = req.restaurant.id;
      return RestaurantController.getRestaurantStats(req, res);
    } catch (error) {
      logger.error(
        "Error obteniendo estad√≠sticas del restaurante actual:",
        error
      );
      res.status(500).json({
        success: false,
        error: "Error obteniendo estad√≠sticas",
      });
    }
  });

  /**
   * Obtiene resumen del dashboard del restaurante
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getDashboardSummary = asyncHandler(async (req, res) => {
    try {
      if (!req.restaurant) {
        return res.status(404).json({
          success: false,
          error: "Restaurante no identificado",
        });
      }

      const restaurantId = req.restaurant.id;

      // Obtener estad√≠sticas de diferentes per√≠odos
      const [todayStats, weekStats, monthStats] = await Promise.all([
        Restaurant.getStats(restaurantId, {
          startDate: new Date().toISOString().split("T")[0],
          endDate: new Date().toISOString().split("T")[0],
        }),
        Restaurant.getStats(restaurantId, {
          startDate: new Date(
            Date.now() - 7 * 24 * 60 * 60 * 1000
          ).toISOString(),
          endDate: new Date().toISOString(),
        }),
        Restaurant.getStats(restaurantId, {
          startDate: new Date(
            Date.now() - 30 * 24 * 60 * 60 * 1000
          ).toISOString(),
          endDate: new Date().toISOString(),
        }),
      ]);

      const summary = {
        restaurant: {
          id: req.restaurant.id,
          name: req.restaurant.name,
          slug: req.restaurant.slug,
          is_active: req.restaurant.is_active,
        },
        stats: {
          today: todayStats,
          week: weekStats,
          month: monthStats,
        },
        generated_at: new Date().toISOString(),
      };

      res.json({
        success: true,
        data: summary,
      });
    } catch (error) {
      logger.error("Error obteniendo resumen del dashboard:", error);
      res.status(500).json({
        success: false,
        error: "Error obteniendo resumen",
      });
    }
  });
}

module.exports = RestaurantController;



================================================
File: src/controllers/webhookController.js
================================================
const WhatsAppService = require('../services/whatsappService');
const ConversationService = require('../services/conversationService');
const ValidationService = require('../services/validationService');
const logger = require('../utils/logger');
const { asyncHandler } = require('../middleware/errorHandler');

// ============================================
// CONTROLADOR DE WEBHOOKS
// ============================================

class WebhookController {

  /**
   * Maneja webhooks de WhatsApp (Twilio y Meta)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleWhatsAppWebhook = asyncHandler(async (req, res) => {
    try {
      const provider = req.query.provider || 'twilio';
      
      logger.debug('Webhook recibido', {
        provider,
        headers: req.headers,
        body: req.body,
        query: req.query
      });

      // Validar webhook seg√∫n el proveedor
      const validationResult = WhatsAppService.validateWebhook(req, provider);
      
      if (!validationResult) {
        logger.warn('Webhook inv√°lido recibido', {
          provider,
          ip: req.ip,
          userAgent: req.get('User-Agent')
        });
        
        return res.status(403).json({
          success: false,
          error: 'Webhook no autorizado'
        });
      }

      // Para Meta WhatsApp, manejar verificaci√≥n de webhook
      if (provider === 'meta' && req.method === 'GET') {
        logger.info('Verificaci√≥n de webhook de Meta WhatsApp exitosa');
        return res.status(200).send(validationResult);
      }

      // Validar datos del webhook
      const webhookValidation = ValidationService.validateWhatsAppWebhook(req.body, provider);
      if (!webhookValidation.isValid) {
        logger.warn('Datos de webhook inv√°lidos', {
          provider,
          error: webhookValidation.error
        });
        
        return res.status(400).json({
          success: false,
          error: 'Datos de webhook inv√°lidos'
        });
      }

      // Procesar mensaje entrante
      const messageData = WhatsAppService.processIncomingMessage(req.body, provider);
      
      if (!messageData) {
        logger.debug('Webhook sin mensaje procesable (posible notificaci√≥n de estado)');
        return res.status(200).json({ success: true, message: 'Webhook procesado' });
      }

      // Verificar que hay un restaurante asociado
      if (!req.restaurant) {
        logger.warn('Mensaje recibido sin restaurante asociado', {
          provider,
          from: messageData.from?.substring(0, 8) + '****',
          to: messageData.to
        });
        
        return res.status(200).json({
          success: false,
          message: 'Restaurante no encontrado'
        });
      }

      // Procesar mensaje de forma as√≠ncrona para responder r√°pido al webhook
      setImmediate(async () => {
        try {
          await WebhookController.processIncomingMessage(req.restaurant, messageData);
        } catch (error) {
          logger.error('Error procesando mensaje de forma as√≠ncrona:', error);
        }
      });

      // Responder inmediatamente al webhook
      res.status(200).json({
        success: true,
        message: 'Mensaje recibido y proces√°ndose'
      });

    } catch (error) {
      logger.error('Error manejando webhook de WhatsApp:', error);
      
      // Siempre responder 200 para evitar reintentos innecesarios
      res.status(200).json({
        success: false,
        error: 'Error interno procesando webhook'
      });
    }
  });

  /**
   * Verifica webhook de Meta WhatsApp (m√©todo GET)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static verifyMetaWebhook = asyncHandler(async (req, res) => {
    try {
      const mode = req.query['hub.mode'];
      const token = req.query['hub.verify_token'];
      const challenge = req.query['hub.challenge'];

      logger.info('Verificaci√≥n de webhook Meta WhatsApp solicitada', {
        mode,
        token: token ? token.substring(0, 10) + '...' : 'none'
      });

      const validationResult = WhatsAppService.validateWebhook(req, 'meta');
      
      if (validationResult && validationResult === challenge) {
        logger.info('Verificaci√≥n de webhook exitosa');
        return res.status(200).send(challenge);
      } else {
        logger.warn('Verificaci√≥n de webhook fallida');
        return res.status(403).send('Error de verificaci√≥n');
      }

    } catch (error) {
      logger.error('Error verificando webhook de Meta:', error);
      res.status(500).send('Error interno');
    }
  });

  /**
   * Webhook espec√≠fico para Twilio
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleTwilioWebhook = asyncHandler(async (req, res) => {
    req.query.provider = 'twilio';
    return WebhookController.handleWhatsAppWebhook(req, res);
  });

  /**
   * Webhook espec√≠fico para Meta WhatsApp
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleMetaWebhook = asyncHandler(async (req, res) => {
    // Manejar verificaci√≥n GET
    if (req.method === 'GET') {
      return WebhookController.verifyMetaWebhook(req, res);
    }
    
    // Manejar mensajes POST
    req.query.provider = 'meta';
    return WebhookController.handleWhatsAppWebhook(req, res);
  });

  /**
   * Procesa mensaje entrante
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} messageData - Datos del mensaje
   */
  static async processIncomingMessage(restaurant, messageData) {
    try {
      const startTime = Date.now();

      logger.info('Procesando mensaje entrante', {
        restaurantId: restaurant.id,
        restaurantName: restaurant.name,
        customerPhone: messageData.from?.substring(0, 8) + '****',
        messageLength: messageData.body?.length || 0,
        hasMedia: !!messageData.mediaUrl
      });

      // Verificar que el restaurante est√© activo
      if (!restaurant.is_active) {
        logger.warn('Mensaje recibido para restaurante inactivo', {
          restaurantId: restaurant.id
        });
        return;
      }

      // Verificar horarios de operaci√≥n
      if (!this.isRestaurantOpen(restaurant)) {
        await this.sendClosedMessage(messageData.from, restaurant);
        return;
      }

      // Procesar mensaje con el servicio de conversaciones
      const result = await ConversationService.processIncomingMessage({
        restaurant,
        customerPhone: messageData.from,
        messageText: messageData.body || '',
        messageData
      });

      const processingTime = Date.now() - startTime;

      if (result.success) {
        logger.info('Mensaje procesado exitosamente', {
          restaurantId: restaurant.id,
          customerPhone: messageData.from?.substring(0, 8) + '****',
          processingTime: `${processingTime}ms`,
          conversationId: result.conversation?.id,
          actionsProcessed: result.actions_processed?.length || 0,
          claudeUsage: result.claudeResult?.usage
        });
      } else {
        logger.error('Error procesando mensaje', {
          restaurantId: restaurant.id,
          customerPhone: messageData.from?.substring(0, 8) + '****',
          processingTime: `${processingTime}ms`,
          error: result.error
        });
      }

    } catch (error) {
      logger.error('Error en procesamiento de mensaje:', error);
      
      // Intentar enviar mensaje de error al cliente
      try {
        await WhatsAppService.sendMessage(
          messageData.from,
          restaurant.error_message || 'Lo siento, tuve un problema t√©cnico. ¬øPodr√≠as repetir tu mensaje?'
        );
      } catch (sendError) {
        logger.error('Error enviando mensaje de error:', sendError);
      }
    }
  }

  /**
   * Verifica si el restaurante est√° abierto
   * @param {Object} restaurant - Datos del restaurante
   * @returns {boolean} True si est√° abierto
   */
  static isRestaurantOpen(restaurant) {
    try {
      if (!restaurant.opens_at || !restaurant.closes_at) {
        return true; // Si no hay horarios definidos, asumir abierto
      }

      const now = new Date();
      const currentTime = now.toTimeString().slice(0, 8); // HH:mm:ss

      const opensAt = restaurant.opens_at;
      const closesAt = restaurant.closes_at;

      // Manejar caso donde cierra despu√©s de medianoche
      if (closesAt < opensAt) {
        return currentTime >= opensAt || currentTime <= closesAt;
      }

      return currentTime >= opensAt && currentTime <= closesAt;

    } catch (error) {
      logger.error('Error verificando horarios de restaurante:', error);
      return true; // En caso de error, asumir abierto
    }
  }

  /**
   * Env√≠a mensaje de restaurante cerrado
   * @param {string} customerPhone - Tel√©fono del cliente
   * @param {Object} restaurant - Datos del restaurante
   */
  static async sendClosedMessage(customerPhone, restaurant) {
    try {
      const message = `üïê Lo siento, ${restaurant.name} est√° cerrado en este momento.\n\n` +
                     `‚è∞ Nuestros horarios son: ${restaurant.opens_at} - ${restaurant.closes_at}\n\n` +
                     `¬°Te esperamos durante nuestro horario de atenci√≥n! üòä`;

      await WhatsAppService.sendMessage(customerPhone, message);

      logger.info('Mensaje de restaurante cerrado enviado', {
        restaurantId: restaurant.id,
        customerPhone: customerPhone?.substring(0, 8) + '****'
      });

    } catch (error) {
      logger.error('Error enviando mensaje de restaurante cerrado:', error);
    }
  }

  /**
   * Maneja webhooks de prueba/desarrollo
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static handleTestWebhook = asyncHandler(async (req, res) => {
    try {
      logger.info('Webhook de prueba recibido', {
        method: req.method,
        headers: req.headers,
        body: req.body,
        query: req.query
      });

      // En desarrollo, simular procesamiento
      if (process.env.NODE_ENV === 'development') {
        const testMessage = {
          messageId: 'test-' + Date.now(),
          from: req.body.from || '+525512345678',
          to: req.body.to || '+525587654321',
          body: req.body.message || 'Mensaje de prueba',
          timestamp: new Date(),
          provider: 'test'
        };

        if (req.restaurant) {
          setImmediate(async () => {
            try {
              await WebhookController.processIncomingMessage(req.restaurant, testMessage);
            } catch (error) {
              logger.error('Error procesando mensaje de prueba:', error);
            }
          });
        }

        return res.status(200).json({
          success: true,
          message: 'Webhook de prueba procesado',
          data: testMessage
        });
      }

      res.status(200).json({
        success: true,
        message: 'Webhook de prueba recibido'
      });

    } catch (error) {
      logger.error('Error manejando webhook de prueba:', error);
      res.status(500).json({
        success: false,
        error: 'Error procesando webhook de prueba'
      });
    }
  });

  /**
   * Obtiene estad√≠sticas de webhooks
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static getWebhookStats = asyncHandler(async (req, res) => {
    try {
      // Esta funci√≥n requerir√≠a una tabla de logs de webhooks
      // Por ahora retornamos estad√≠sticas b√°sicas
      const stats = {
        total_webhooks_received: 0,
        successful_processing: 0,
        failed_processing: 0,
        avg_processing_time: 0,
        providers: {
          twilio: 0,
          meta: 0,
          test: 0
        },
        last_24h: {
          total: 0,
          successful: 0,
          failed: 0
        }
      };

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de webhooks:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo estad√≠sticas'
      });
    }
  });

  /**
   * Reinicia una conversaci√≥n espec√≠fica
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static restartConversation = asyncHandler(async (req, res) => {
    try {
      const { customerPhone } = req.body;
      
      if (!customerPhone) {
        return res.status(400).json({
          success: false,
          error: 'Tel√©fono del cliente es requerido'
        });
      }

      if (!req.restaurant) {
        return res.status(400).json({
          success: false,
          error: 'Restaurante no identificado'
        });
      }

      // Reiniciar conversaci√≥n
      const result = await ConversationService.restartConversation(
        req.restaurant.id,
        customerPhone
      );

      logger.info('Conversaci√≥n reiniciada manualmente', {
        restaurantId: req.restaurant.id,
        customerPhone: customerPhone?.substring(0, 8) + '****',
        newConversationId: result.conversation?.id
      });

      res.json({
        success: true,
        message: 'Conversaci√≥n reiniciada exitosamente',
        data: {
          conversation_id: result.conversation?.id,
          customer_id: result.customer?.id
        }
      });

    } catch (error) {
      logger.error('Error reiniciando conversaci√≥n:', error);
      res.status(500).json({
        success: false,
        error: 'Error reiniciando conversaci√≥n'
      });
    }
  });

  /**
   * Env√≠a mensaje manual desde el dashboard
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  static sendManualMessage = asyncHandler(async (req, res) => {
    try {
      const { customerPhone, message } = req.body;

      if (!customerPhone || !message) {
        return res.status(400).json({
          success: false,
          error: 'Tel√©fono del cliente y mensaje son requeridos'
        });
      }

      if (!req.restaurant) {
        return res.status(400).json({
          success: false,
          error: 'Restaurante no identificado'
        });
      }

      // Validar mensaje
      const validation = ValidationService.validateIncomingMessage(message, null);
      if (!validation.isValid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      // Enviar mensaje
      const result = await WhatsAppService.sendMessage(customerPhone, message, {
        addEmojis: true,
        restaurantName: req.restaurant.name
      });

      logger.info('Mensaje manual enviado', {
        restaurantId: req.restaurant.id,
        customerPhone: customerPhone?.substring(0, 8) + '****',
        messageLength: message.length,
        success: result.success
      });

      res.json({
        success: true,
        message: 'Mensaje enviado exitosamente',
        data: {
          message_id: result.messageId,
          provider: result.provider
        }
      });

    } catch (error) {
      logger.error('Error enviando mensaje manual:', error);
      res.status(500).json({
        success: false,
        error: 'Error enviando mensaje'
      });
    }
  });
}

module.exports = WebhookController;


================================================
File: src/middleware/auth.js
================================================
const jwt = require("jsonwebtoken");
const bcrypt = require("bcryptjs");
const logger = require("../utils/logger");
const { AuthenticationError, AuthorizationError } = require("./errorHandler");

// ============================================
// MIDDLEWARE DE AUTENTICACI√ìN
// ============================================

class AuthMiddleware {
  /**
   * Genera un JWT token
   * @param {Object} payload - Datos a incluir en el token
   * @param {Object} options - Opciones del token
   * @returns {string} JWT token
   */
  static generateToken(payload, options = {}) {
    const defaultOptions = {
      expiresIn: process.env.JWT_EXPIRES_IN || "24h",
      issuer: "ChatBot-Chingon",
      audience: "restaurant-api",
    };

    const tokenOptions = { ...defaultOptions, ...options };

    try {
      return jwt.sign(payload, process.env.JWT_SECRET, tokenOptions);
    } catch (error) {
      logger.error("Error generando JWT token:", error);
      throw new Error("Error generando token de autenticaci√≥n");
    }
  }

  /**
   * Verifica un JWT token
   * @param {string} token - Token a verificar
   * @returns {Object} Payload decodificado
   */
  static verifyToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      if (error.name === "TokenExpiredError") {
        throw new AuthenticationError("Token expirado");
      } else if (error.name === "JsonWebTokenError") {
        throw new AuthenticationError("Token inv√°lido");
      } else {
        logger.error("Error verificando JWT token:", error);
        throw new AuthenticationError("Error de autenticaci√≥n");
      }
    }
  }

  /**
   * Hash de contrase√±a usando bcrypt
   * @param {string} password - Contrase√±a a hashear
   * @returns {Promise<string>} Hash de la contrase√±a
   */
  static async hashPassword(password) {
    try {
      const saltRounds = parseInt(process.env.BCRYPT_ROUNDS) || 10;
      return await bcrypt.hash(password, saltRounds);
    } catch (error) {
      logger.error("Error hasheando contrase√±a:", error);
      throw new Error("Error procesando contrase√±a");
    }
  }

  /**
   * Compara contrase√±a con hash
   * @param {string} password - Contrase√±a en texto plano
   * @param {string} hash - Hash almacenado
   * @returns {Promise<boolean>} True si coinciden
   */
  static async comparePassword(password, hash) {
    try {
      return await bcrypt.compare(password, hash);
    } catch (error) {
      logger.error("Error comparando contrase√±a:", error);
      return false;
    }
  }

  /**
   * Extrae token del header Authorization
   * @param {Object} req - Request object
   * @returns {string|null} Token extra√≠do
   */
  static extractTokenFromHeader(req) {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return null;
    }

    // Formato esperado: "Bearer <token>"
    const parts = authHeader.split(" ");

    if (parts.length !== 2 || parts[0] !== "Bearer") {
      return null;
    }

    return parts[1];
  }

  /**
   * Middleware principal de autenticaci√≥n JWT
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static authenticateToken = (req, res, next) => {
    try {
      const token = AuthMiddleware.extractTokenFromHeader(req); // Cambiar this por AuthMiddleware

      if (!token) {
        logger.warn("Intento de acceso sin token", {
          ip: req.ip,
          path: req.path,
          userAgent: req.get("User-Agent"),
        });
        throw new AuthenticationError("Token de acceso requerido");
      }

      // Verificar token
      const decoded = AuthMiddleware.verifyToken(token); // Cambiar this por AuthMiddleware

      // Agregar informaci√≥n del usuario al request
      req.user = {
        id: decoded.sub || decoded.userId,
        email: decoded.email,
        role: decoded.role || "user",
        restaurantId: decoded.restaurantId,
        permissions: decoded.permissions || [],
      };

      // Log de acceso exitoso
      logger.debug("Autenticaci√≥n exitosa", {
        userId: req.user.id,
        role: req.user.role,
        path: req.path,
      });

      next();
    } catch (error) {
      if (error instanceof AuthenticationError) {
        logger.warn("Error de autenticaci√≥n", {
          error: error.message,
          ip: req.ip,
          path: req.path,
        });
      } else {
        logger.error("Error inesperado en autenticaci√≥n:", error);
      }

      next(error);
    }
  };

  /**
   * Middleware de autenticaci√≥n opcional
   * No falla si no hay token, pero lo procesa si existe
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static optionalAuth = (req, res, next) => {
    try {
      const token = AuthMiddleware.extractTokenFromHeader(req);

      if (!token) {
        // No hay token, continuar sin autenticaci√≥n
        req.user = null;
        return next();
      }

      // Hay token, intentar verificarlo
      try {
        const decoded = AuthMiddleware.verifyToken(token);

        req.user = {
          id: decoded.sub || decoded.userId,
          email: decoded.email,
          role: decoded.role || "user",
          restaurantId: decoded.restaurantId,
          permissions: decoded.permissions || [],
        };

        logger.debug("Autenticaci√≥n opcional exitosa", {
          userId: req.user.id,
          path: req.path,
        });
      } catch (authError) {
        // Token inv√°lido, continuar sin autenticaci√≥n
        logger.warn("Token inv√°lido en autenticaci√≥n opcional", {
          error: authError.message,
          path: req.path,
        });
        req.user = null;
      }

      next();
    } catch (error) {
      logger.error("Error en autenticaci√≥n opcional:", error);
      // En caso de error, continuar sin autenticaci√≥n
      req.user = null;
      next();
    }
  };

  /**
   * Middleware para verificar roles espec√≠ficos
   * @param {Array|string} allowedRoles - Roles permitidos
   * @returns {Function} Middleware function
   */
  static requireRole = (allowedRoles) => {
    const roles = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];

    return (req, res, next) => {
      try {
        if (!req.user) {
          throw new AuthenticationError("Autenticaci√≥n requerida");
        }

        const userRole = req.user.role;

        if (!roles.includes(userRole)) {
          logger.warn("Acceso denegado por rol insuficiente", {
            userId: req.user.id,
            userRole,
            requiredRoles: roles,
            path: req.path,
          });
          throw new AuthorizationError(
            `Acceso denegado. Roles requeridos: ${roles.join(", ")}`
          );
        }

        logger.debug("Verificaci√≥n de rol exitosa", {
          userId: req.user.id,
          userRole,
          path: req.path,
        });

        next();
      } catch (error) {
        next(error);
      }
    };
  };

  /**
   * Middleware para verificar permisos espec√≠ficos
   * @param {Array|string} requiredPermissions - Permisos requeridos
   * @returns {Function} Middleware function
   */
  static requirePermission = (requiredPermissions) => {
    const permissions = Array.isArray(requiredPermissions)
      ? requiredPermissions
      : [requiredPermissions];

    return (req, res, next) => {
      try {
        if (!req.user) {
          throw new AuthenticationError("Autenticaci√≥n requerida");
        }

        const userPermissions = req.user.permissions || [];

        // Verificar si el usuario tiene todos los permisos requeridos
        const hasAllPermissions = permissions.every((permission) =>
          userPermissions.includes(permission)
        );

        if (!hasAllPermissions) {
          logger.warn("Acceso denegado por permisos insuficientes", {
            userId: req.user.id,
            userPermissions,
            requiredPermissions: permissions,
            path: req.path,
          });
          throw new AuthorizationError("Permisos insuficientes");
        }

        logger.debug("Verificaci√≥n de permisos exitosa", {
          userId: req.user.id,
          permissions,
          path: req.path,
        });

        next();
      } catch (error) {
        next(error);
      }
    };
  };

  /**
   * Middleware para verificar acceso al restaurante
   * Verifica que el usuario tenga acceso al restaurante especificado
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static requireRestaurantAccess = (req, res, next) => {
    try {
      if (!req.user) {
        throw new AuthenticationError("Autenticaci√≥n requerida");
      }

      // Super admin puede acceder a cualquier restaurante
      if (req.user.role === "super_admin") {
        return next();
      }

      // Obtener ID del restaurante de diferentes fuentes
      const restaurantId =
        req.restaurant?.id ||
        req.params.restaurantId ||
        req.body.restaurant_id ||
        req.user.restaurantId;

      if (!restaurantId) {
        throw new AuthorizationError("ID de restaurante no especificado");
      }

      // Verificar que el usuario pertenece al restaurante
      if (req.user.restaurantId !== restaurantId) {
        logger.warn("Intento de acceso a restaurante no autorizado", {
          userId: req.user.id,
          userRestaurantId: req.user.restaurantId,
          requestedRestaurantId: restaurantId,
          path: req.path,
        });
        throw new AuthorizationError("Acceso denegado al restaurante");
      }

      logger.debug("Acceso al restaurante autorizado", {
        userId: req.user.id,
        restaurantId,
        path: req.path,
      });

      next();
    } catch (error) {
      next(error);
    }
  };

  /**
   * Middleware para API keys (para integraciones)
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static authenticateApiKey = (req, res, next) => {
    try {
      const apiKey = req.headers["x-api-key"] || req.query.api_key;

      if (!apiKey) {
        throw new AuthenticationError("API Key requerida");
      }

      // Verificar API key (en una implementaci√≥n real, esto estar√≠a en la BD)
      // Por ahora usamos una verificaci√≥n simple con variable de entorno
      const validApiKeys = (process.env.VALID_API_KEYS || "")
        .split(",")
        .filter(Boolean);

      if (!validApiKeys.includes(apiKey)) {
        logger.warn("API Key inv√°lida utilizada", {
          apiKey: apiKey.substring(0, 8) + "****",
          ip: req.ip,
          path: req.path,
        });
        throw new AuthenticationError("API Key inv√°lida");
      }

      // Establecer informaci√≥n b√°sica del "usuario" API
      req.user = {
        id: "api-user",
        role: "api",
        type: "api_key",
        permissions: ["read", "write"], // Permisos b√°sicos para API
      };

      logger.debug("Autenticaci√≥n con API Key exitosa", {
        apiKey: apiKey.substring(0, 8) + "****",
        path: req.path,
      });

      next();
    } catch (error) {
      next(error);
    }
  };

  /**
   * Middleware que permite autenticaci√≥n con JWT o API Key
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static authenticateJwtOrApiKey = (req, res, next) => {
    const hasJwtToken = !!AuthMiddleware.extractTokenFromHeader(req);
    const hasApiKey = !!(req.headers["x-api-key"] || req.query.api_key);

    if (hasJwtToken) {
      // Usar autenticaci√≥n JWT
      return AuthMiddleware.authenticateToken(req, res, next);
    } else if (hasApiKey) {
      // Usar autenticaci√≥n API Key
      return AuthMiddleware.authenticateApiKey(req, res, next);
    } else {
      // Ning√∫n m√©todo de autenticaci√≥n proporcionado
      throw new AuthenticationError("Token JWT o API Key requerido");
    }
  };

  /**
   * Middleware para refrescar tokens
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static refreshToken = (req, res, next) => {
    try {
      const { refresh_token } = req.body;

      if (!refresh_token) {
        throw new AuthenticationError("Refresh token requerido");
      }

      // Verificar refresh token
      const decoded = AuthMiddleware.verifyToken(refresh_token); // Cambiar this por AuthMiddleware

      if (decoded.type !== "refresh") {
        throw new AuthenticationError("Token de refresco inv√°lido");
      }

      // Generar nuevo access token
      const newToken = AuthMiddleware.generateToken({
        sub: decoded.sub,
        email: decoded.email,
        role: decoded.role,
        restaurantId: decoded.restaurantId,
        permissions: decoded.permissions,
      });

      req.newToken = newToken;
      req.user = {
        id: decoded.sub,
        email: decoded.email,
        role: decoded.role,
        restaurantId: decoded.restaurantId,
        permissions: decoded.permissions,
      };

      logger.info("Token refrescado exitosamente", {
        userId: req.user.id,
      });

      next();
    } catch (error) {
      next(error);
    }
  };

  /**
   * Genera tokens de acceso y refresco
   * @param {Object} payload - Datos del usuario
   * @returns {Object} Tokens generados
   */
  static generateTokenPair(payload) {
    const accessToken = AuthMiddleware.generateToken(payload, {
      expiresIn: "1h",
    });
    const refreshToken = AuthMiddleware.generateToken(
      { ...payload, type: "refresh" },
      { expiresIn: "7d" }
    );

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      token_type: "Bearer",
      expires_in: 3600, // 1 hora en segundos
    };
  }

  /**
   * Middleware de logging de autenticaci√≥n
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   * @param {Function} next - Next function
   */
  static logAuthAttempt = (req, res, next) => {
    const hasAuth = !!(
      AuthMiddleware.extractTokenFromHeader(req) || req.headers["x-api-key"]
    );

    if (hasAuth) {
      logger.debug("Intento de autenticaci√≥n detectado", {
        path: req.path,
        method: req.method,
        ip: req.ip,
        userAgent: req.get("User-Agent"),
      });
    }

    next();
  };
}

module.exports = AuthMiddleware;



================================================
File: src/middleware/errorHandler.js
================================================
const logger = require('../utils/logger');
const { DEFAULT_MESSAGES } = require('../utils/constants');

// ============================================
// CLASES DE ERROR PERSONALIZADAS
// ============================================

/**
 * Error base para errores de negocio
 */
class AppError extends Error {
  constructor(message, statusCode = 500, isOperational = true) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date().toISOString();
    
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Error de validaci√≥n
 */
class ValidationError extends AppError {
  constructor(message, field = null) {
    super(message, 400);
    this.field = field;
    this.type = 'validation';
  }
}

/**
 * Error de base de datos
 */
class DatabaseError extends AppError {
  constructor(message, originalError = null) {
    super(message, 500);
    this.originalError = originalError;
    this.type = 'database';
  }
}

/**
 * Error de servicio externo (Claude, WhatsApp)
 */
class ExternalServiceError extends AppError {
  constructor(service, message, statusCode = 503) {
    super(`${service}: ${message}`, statusCode);
    this.service = service;
    this.type = 'external_service';
  }
}

/**
 * Error de autenticaci√≥n
 */
class AuthenticationError extends AppError {
  constructor(message = 'No autorizado') {
    super(message, 401);
    this.type = 'authentication';
  }
}

/**
 * Error de autorizaci√≥n
 */
class AuthorizationError extends AppError {
  constructor(message = 'Acceso denegado') {
    super(message, 403);
    this.type = 'authorization';
  }
}

/**
 * Error de recurso no encontrado
 */
class NotFoundError extends AppError {
  constructor(resource = 'Recurso') {
    super(`${resource} no encontrado`, 404);
    this.type = 'not_found';
  }
}

/**
 * Error de conflicto (recurso ya existe)
 */
class ConflictError extends AppError {
  constructor(message = 'Conflicto con recurso existente') {
    super(message, 409);
    this.type = 'conflict';
  }
}

/**
 * Error de rate limiting
 */
class RateLimitError extends AppError {
  constructor(message = 'Demasiadas solicitudes') {
    super(message, 429);
    this.type = 'rate_limit';
  }
}

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Determina si un error es operacional (esperado) o de programaci√≥n
 * @param {Error} error 
 * @returns {boolean}
 */
const isOperationalError = (error) => {
  if (error instanceof AppError) {
    return error.isOperational;
  }
  
  // Errores comunes que consideramos operacionales
  const operationalErrors = [
    'ValidationError',
    'CastError',
    'MongoError',
    'SequelizeValidationError',
    'SequelizeUniqueConstraintError'
  ];
  
  return operationalErrors.includes(error.name);
};

/**
 * Extrae informaci√≥n √∫til del error
 * @param {Error} error 
 * @returns {Object}
 */
const getErrorInfo = (error) => {
  const info = {
    name: error.name,
    message: error.message,
    timestamp: new Date().toISOString(),
  };

  // Informaci√≥n espec√≠fica por tipo de error
  if (error instanceof AppError) {
    info.type = error.type;
    info.statusCode = error.statusCode;
    info.isOperational = error.isOperational;
  }

  // Errores de base de datos PostgreSQL
  if (error.code) {
    info.code = error.code;
    
    switch (error.code) {
      case '23505': // unique_violation
        info.type = 'unique_constraint';
        info.constraint = error.constraint;
        break;
      case '23503': // foreign_key_violation
        info.type = 'foreign_key_violation';
        info.constraint = error.constraint;
        break;
      case '23502': // not_null_violation
        info.type = 'not_null_violation';
        info.column = error.column;
        break;
      case '22001': // string_data_right_truncation
        info.type = 'string_too_long';
        break;
      case '08006': // connection_failure
        info.type = 'connection_failure';
        break;
    }
  }

  // Errores de validaci√≥n de Joi
  if (error.isJoi) {
    info.type = 'joi_validation';
    info.details = error.details.map(detail => ({
      field: detail.path.join('.'),
      message: detail.message,
      value: detail.context?.value
    }));
  }

  return info;
};

/**
 * Genera una respuesta de error consistente
 * @param {Error} error 
 * @param {Object} req 
 * @returns {Object}
 */
const generateErrorResponse = (error, req) => {
  const errorInfo = getErrorInfo(error);
  const isDevelopment = process.env.NODE_ENV === 'development';
  
  // Respuesta base
  const response = {
    success: false,
    error: {
      message: errorInfo.message,
      type: errorInfo.type || 'unknown',
      timestamp: errorInfo.timestamp,
      requestId: req.id || req.headers['x-request-id']
    }
  };

  // En desarrollo, incluir m√°s detalles
  if (isDevelopment) {
    response.error.stack = error.stack;
    response.error.details = errorInfo;
    
    if (req.body && Object.keys(req.body).length > 0) {
      response.error.requestBody = req.body;
    }
    
    if (req.params && Object.keys(req.params).length > 0) {
      response.error.requestParams = req.params;
    }
  }

  // Mensajes amigables para usuarios finales
  const userFriendlyMessages = {
    validation: 'Los datos proporcionados no son v√°lidos',
    database: 'Error interno del servidor',
    external_service: 'Servicio temporalmente no disponible',
    authentication: 'Credenciales inv√°lidas',
    authorization: 'No tienes permisos para realizar esta acci√≥n',
    not_found: 'El recurso solicitado no existe',
    conflict: 'El recurso ya existe',
    rate_limit: 'Demasiadas solicitudes, intenta m√°s tarde',
    unique_constraint: 'Ya existe un registro con esos datos',
    foreign_key_violation: 'Referencia inv√°lida',
    not_null_violation: 'Campo requerido faltante'
  };

  // Si no es desarrollo, usar mensaje amigable
  if (!isDevelopment && userFriendlyMessages[errorInfo.type]) {
    response.error.message = userFriendlyMessages[errorInfo.type];
  }

  return response;
};

// ============================================
// MIDDLEWARE PRINCIPAL DE MANEJO DE ERRORES
// ============================================

/**
 * Middleware de manejo de errores para Express
 * Este debe ser el √öLTIMO middleware en la aplicaci√≥n
 */
const errorHandler = (error, req, res, next) => {
  const errorInfo = getErrorInfo(error);
  const isOperational = isOperationalError(error);
  
  // Log del error
  if (isOperational) {
    logger.warn('Error operacional capturado', {
      ...errorInfo,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
  } else {
    logger.error('Error no esperado capturado', {
      ...errorInfo,
      stack: error.stack,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      body: req.body,
      params: req.params,
      query: req.query
    });
  }

  // Determinar c√≥digo de estado HTTP
  let statusCode = 500;
  
  if (error instanceof AppError) {
    statusCode = error.statusCode;
  } else if (error.status) {
    statusCode = error.status;
  } else if (error.statusCode) {
    statusCode = error.statusCode;
  }

  // Generar respuesta
  const response = generateErrorResponse(error, req);
  
  // Enviar respuesta
  res.status(statusCode).json(response);
};

// ============================================
// MIDDLEWARE PARA 404
// ============================================

/**
 * Middleware para rutas no encontradas
 */
const notFoundHandler = (req, res, next) => {
  const error = new NotFoundError(`Ruta ${req.originalUrl}`);
  next(error);
};

// ============================================
// WRAPPER PARA FUNCIONES ASYNC
// ============================================

/**
 * Wrapper para capturar errores en funciones async
 * Evita tener que usar try/catch en cada controlador
 * 
 * @param {Function} fn - Funci√≥n async a envolver
 * @returns {Function} Funci√≥n envuelta
 */
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// ============================================
// MANEJADORES ESPEC√çFICOS
// ============================================

/**
 * Maneja errores espec√≠ficos de PostgreSQL
 * @param {Error} error 
 * @returns {AppError}
 */
const handleDatabaseError = (error) => {
  let message = 'Error de base de datos';
  let statusCode = 500;

  switch (error.code) {
    case '23505': // unique_violation
      message = 'Ya existe un registro con esos datos';
      statusCode = 409;
      break;
    case '23503': // foreign_key_violation
      message = 'Referencia inv√°lida a otro registro';
      statusCode = 400;
      break;
    case '23502': // not_null_violation
      message = `El campo ${error.column} es requerido`;
      statusCode = 400;
      break;
    case '22001': // string_data_right_truncation
      message = 'Uno de los campos es demasiado largo';
      statusCode = 400;
      break;
    case '08006': // connection_failure
      message = 'Error de conexi√≥n a la base de datos';
      statusCode = 503;
      break;
  }

  return new DatabaseError(message, error);
};

/**
 * Maneja errores de validaci√≥n de Joi
 * @param {Error} error 
 * @returns {ValidationError}
 */
const handleJoiValidationError = (error) => {
  const messages = error.details.map(detail => detail.message);
  return new ValidationError(messages.join(', '));
};

// ============================================
// MIDDLEWARE DE LOGGING DE ERRORES
// ============================================

/**
 * Middleware que loggea todos los errores que pasan por el sistema
 */
const errorLogger = (error, req, res, next) => {
  // Log espec√≠fico para diferentes tipos de error
  if (error.code && error.code.startsWith('23')) {
    logger.logDatabase('error', 'unknown', 0, 0, { error: error.message, code: error.code });
  } else if (error.service) {
    logger.error(`Error en servicio ${error.service}`, {
      service: error.service,
      message: error.message,
      statusCode: error.statusCode
    });
  } else {
    logger.error('Error no categorizado', {
      name: error.name,
      message: error.message,
      stack: error.stack
    });
  }

  next(error);
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Clases de error
  AppError,
  ValidationError,
  DatabaseError,
  ExternalServiceError,
  AuthenticationError,
  AuthorizationError,
  NotFoundError,
  ConflictError,
  RateLimitError,
  
  // Middleware
  errorHandler,
  notFoundHandler,
  errorLogger,
  asyncHandler,
  
  // Utilidades
  isOperationalError,
  getErrorInfo,
  generateErrorResponse,
  handleDatabaseError,
  handleJoiValidationError
};


================================================
File: src/middleware/rateLimiter.js
================================================
const rateLimit = require('express-rate-limit');
const logger = require('../utils/logger');
const { RATE_LIMITS, SECURITY_EVENTS } = require('../utils/constants');
const { RateLimitError } = require('./errorHandler');

// ============================================
// CONFIGURACI√ìN BASE DE RATE LIMITING
// ============================================

/**
 * Configuraci√≥n base para todos los rate limiters
 */
const baseConfig = {
  standardHeaders: true, // Retorna rate limit info en headers `RateLimit-*`
  legacyHeaders: false, // Deshabilita headers `X-RateLimit-*`
  
  // Funci√≥n personalizada para generar key
  keyGenerator: (req) => {
    // Usar IP + User-Agent para mejor identificaci√≥n
    const ip = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('User-Agent') || 'unknown';
    return `${ip}:${Buffer.from(userAgent).toString('base64').substring(0, 20)}`;
  },

  // Handler cuando se excede el l√≠mite
  handler: (req, res, next) => {
    const clientInfo = {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      url: req.originalUrl,
      method: req.method
    };

    logger.logSecurity(SECURITY_EVENTS.RATE_LIMIT_EXCEEDED, 'medium', {
      ...clientInfo,
      limit: req.rateLimit.limit,
      remaining: req.rateLimit.remaining,
      resetTime: new Date(req.rateLimit.resetTime)
    });

    const error = new RateLimitError(
      process.env.RATE_LIMIT_MESSAGE || 'Demasiadas solicitudes, intenta en unos minutos'
    );
    
    next(error);
  },

  // Funci√≥n para omitir ciertos requests
  skip: (req) => {
    // No aplicar rate limiting en desarrollo si est√° configurado
    if (process.env.NODE_ENV === 'development' && process.env.SKIP_RATE_LIMIT === 'true') {
      return true;
    }

    // No aplicar a health checks
    if (req.path === '/health') {
      return true;
    }

    return false;
  }
};

// ============================================
// RATE LIMITERS ESPEC√çFICOS
// ============================================

/**
 * Rate limiter general para API
 */
const apiLimiter = rateLimit({
  ...baseConfig,
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutos
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || RATE_LIMITS.API_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas solicitudes desde esta IP, intenta de nuevo en 15 minutos',
      retryAfter: 15 * 60
    }
  }
});

/**
 * Rate limiter estricto para webhooks
 */
const webhookLimiter = rateLimit({
  ...baseConfig,
  windowMs: 1 * 60 * 1000, // 1 minuto
  max: RATE_LIMITS.WEBHOOK_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas solicitudes al webhook',
      retryAfter: 60
    }
  },
  
  // Key espec√≠fica para webhooks (por proveedor)
  keyGenerator: (req) => {
    const ip = req.ip;
    const provider = req.headers['user-agent']?.includes('Twilio') ? 'twilio' : 
                    req.headers['user-agent']?.includes('facebookexternalhit') ? 'meta' : 'unknown';
    return `webhook:${provider}:${ip}`;
  }
});

/**
 * Rate limiter para operaciones con Claude AI
 */
const claudeLimiter = rateLimit({
  ...baseConfig,
  windowMs: 1 * 60 * 1000, // 1 minuto
  max: RATE_LIMITS.CLAUDE_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas solicitudes a la IA, intenta en un momento',
      retryAfter: 60
    }
  },
  
  // Solo aplicar a rutas que usen Claude
  skip: (req) => {
    if (baseConfig.skip(req)) return true;
    
    // Solo aplicar a rutas espec√≠ficas
    const claudeRoutes = ['/webhook', '/api/chat'];
    return !claudeRoutes.some(route => req.path.startsWith(route));
  }
});

/**
 * Rate limiter para WhatsApp
 */
const whatsappLimiter = rateLimit({
  ...baseConfig,
  windowMs: 1 * 60 * 1000, // 1 minuto
  max: RATE_LIMITS.WHATSAPP_PER_MINUTE,
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiados mensajes de WhatsApp',
      retryAfter: 60
    }
  }
});

/**
 * Rate limiter muy estricto para autenticaci√≥n
 */
const authLimiter = rateLimit({
  ...baseConfig,
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 5, // Solo 5 intentos cada 15 minutos
  skipSuccessfulRequests: true, // No contar requests exitosos
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiados intentos de autenticaci√≥n, intenta en 15 minutos',
      retryAfter: 15 * 60
    }
  },

  // Key espec√≠fica para auth (incluir endpoint)
  keyGenerator: (req) => {
    const ip = req.ip;
    const endpoint = req.path;
    return `auth:${endpoint}:${ip}`;
  }
});

/**
 * Rate limiter para operaciones de administraci√≥n
 */
const adminLimiter = rateLimit({
  ...baseConfig,
  windowMs: 5 * 60 * 1000, // 5 minutos
  max: 30, // 30 requests cada 5 minutos
  message: {
    success: false,
    error: {
      type: 'rate_limit',
      message: 'Demasiadas operaciones administrativas',
      retryAfter: 5 * 60
    }
  }
});

// ============================================
// RATE LIMITER DIN√ÅMICO
// ============================================

/**
 * Rate limiter que se ajusta basado en el endpoint
 * @param {Object} options - Configuraci√≥n espec√≠fica
 * @returns {Function} Middleware de rate limiting
 */
const createDynamicLimiter = (options = {}) => {
  const config = {
    ...baseConfig,
    windowMs: options.windowMs || 15 * 60 * 1000,
    max: options.max || 100,
    message: options.message || {
      success: false,
      error: {
        type: 'rate_limit',
        message: 'Demasiadas solicitudes',
        retryAfter: Math.floor((options.windowMs || 15 * 60 * 1000) / 1000)
      }
    },
    ...options
  };

  return rateLimit(config);
};

// ============================================
// MIDDLEWARE DE LOGGING
// ============================================

/**
 * Middleware que loggea informaci√≥n de rate limiting
 */
const rateLimitLogger = (req, res, next) => {
  // Solo loggear si hay informaci√≥n de rate limit
  if (req.rateLimit) {
    const { limit, remaining, resetTime } = req.rateLimit;
    
    // Loggear cuando quedan pocos requests
    if (remaining <= Math.floor(limit * 0.1)) { // 10% o menos
      logger.warn('Rate limit casi alcanzado', {
        ip: req.ip,
        path: req.path,
        method: req.method,
        limit,
        remaining,
        resetTime: new Date(resetTime),
        userAgent: req.get('User-Agent')
      });
    }

    // Agregar headers informativos
    res.set({
      'X-RateLimit-Limit': limit,
      'X-RateLimit-Remaining': remaining,
      'X-RateLimit-Reset': Math.ceil(resetTime / 1000)
    });
  }

  next();
};

// ============================================
// FUNCI√ìN DE BYPASS PARA TESTING
// ============================================

/**
 * Middleware que permite bypass de rate limiting para testing
 */
const testBypass = (req, res, next) => {
  // Solo en modo test
  if (process.env.NODE_ENV === 'test') {
    // Verificar header especial
    if (req.headers['x-test-bypass-rate-limit'] === process.env.TEST_BYPASS_TOKEN) {
      logger.debug('Rate limit bypass activado para testing');
      return next();
    }
  }

  next();
};

// ============================================
// UTILIDADES DE RATE LIMITING
// ============================================

/**
 * Obtiene informaci√≥n actual de rate limiting para una key
 * @param {string} key - Key del rate limit
 * @param {Object} store - Store del rate limiter
 * @returns {Promise<Object>} Informaci√≥n de rate limit
 */
const getRateLimitInfo = async (key, store) => {
  try {
    const record = await store.get(key);
    
    if (!record) {
      return {
        key,
        requests: 0,
        remaining: 'unlimited',
        resetTime: null
      };
    }

    return {
      key,
      requests: record.count || 0,
      remaining: Math.max(0, record.limit - record.count),
      resetTime: record.resetTime,
      limit: record.limit
    };
  } catch (error) {
    logger.error('Error obteniendo informaci√≥n de rate limit:', error);
    return null;
  }
};

/**
 * Limpia manualmente una key del rate limiter
 * @param {string} key - Key a limpiar
 * @param {Object} store - Store del rate limiter
 * @returns {Promise<boolean>} True si se limpi√≥ correctamente
 */
const clearRateLimit = async (key, store) => {
  try {
    await store.delete(key);
    logger.info('Rate limit limpiado manualmente', { key });
    return true;
  } catch (error) {
    logger.error('Error limpiando rate limit:', error);
    return false;
  }
};

/**
 * Middleware que permite resetear rate limit para IPs espec√≠ficas
 */
const createResetMiddleware = (allowedIPs = []) => {
  return (req, res, next) => {
    const clientIP = req.ip;
    
    // Solo permitir desde IPs espec√≠ficas
    if (allowedIPs.includes(clientIP) || allowedIPs.includes('*')) {
      if (req.query.resetRateLimit === 'true') {
        // Aqu√≠ se podr√≠a implementar la l√≥gica de reset
        logger.info('Rate limit reset solicitado', {
          ip: clientIP,
          path: req.path
        });
        
        res.json({
          success: true,
          message: 'Rate limit reset solicitado',
          ip: clientIP
        });
        return;
      }
    }

    next();
  };
};

// ============================================
// CONFIGURACI√ìN GLOBAL
// ============================================

/**
 * Aplica rate limiting global basado en el entorno
 */
const applyGlobalRateLimit = (app) => {
  // En producci√≥n, aplicar rate limiting m√°s estricto
  if (process.env.NODE_ENV === 'production') {
    app.use(rateLimitLogger);
    
    // Rate limiting global menos estricto
    app.use(createDynamicLimiter({
      windowMs: 15 * 60 * 1000, // 15 minutos
      max: 1000, // 1000 requests por IP cada 15 minutos
      message: {
        success: false,
        error: {
          type: 'rate_limit',
          message: 'Demasiadas solicitudes, intenta m√°s tarde',
          retryAfter: 15 * 60
        }
      }
    }));
  } else {
    // En desarrollo, solo logging
    app.use(rateLimitLogger);
  }
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Rate limiters espec√≠ficos
  apiLimiter,
  webhookLimiter,
  claudeLimiter,
  whatsappLimiter,
  authLimiter,
  adminLimiter,
  
  // Funciones
  createDynamicLimiter,
  rateLimitLogger,
  testBypass,
  applyGlobalRateLimit,
  
  // Utilidades
  getRateLimitInfo,
  clearRateLimit,
  createResetMiddleware,
  
  // Configuraci√≥n base
  baseConfig
};


================================================
File: src/middleware/tenantResolver.js
================================================
const { query } = require('../config/database');
const logger = require('../utils/logger');
const { NotFoundError, ValidationError } = require('./errorHandler');
const { VALIDATION_PATTERNS } = require('../utils/constants');

// ============================================
// CACHE DE RESTAURANTES
// ============================================

// Cache en memoria para evitar consultas repetitivas
const restaurantCache = new Map();
const cacheTimeout = 5 * 60 * 1000; // 5 minutos

/**
 * Limpia el cache de restaurantes
 */
const clearRestaurantCache = () => {
  restaurantCache.clear();
  logger.debug('Cache de restaurantes limpiado');
};

/**
 * Obtiene un restaurante del cache o base de datos
 * @param {string} key - Clave del cache (slug o phone)
 * @param {string} value - Valor a buscar
 * @param {string} field - Campo por el cual buscar
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const getRestaurantFromCacheOrDB = async (key, value, field) => {
  // Verificar cache
  const cached = restaurantCache.get(key);
  if (cached && Date.now() - cached.timestamp < cacheTimeout) {
    logger.debug('Restaurante obtenido del cache', { key, field });
    return cached.data;
  }

  // Consultar base de datos
  try {
    const result = await query(
      `SELECT 
        r.id,
        r.name,
        r.slug,
        r.phone,
        r.email,
        r.is_active,
        r.opens_at,
        r.closes_at,
        r.delivery_time_min,
        r.delivery_time_max,
        r.delivery_fee,
        r.minimum_order,
        r.whatsapp_phone_id,
        r.twilio_phone_number,
        rs.claude_api_key,
        rs.claude_model,
        rs.ai_personality,
        rs.welcome_message,
        rs.goodbye_message,
        rs.error_message,
        rs.auto_confirm_orders,
        rs.max_conversation_time,
        rs.notification_email,
        rs.notification_phone
      FROM restaurants r
      LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
      WHERE r.${field} = $1 AND r.is_active = true`,
      [value],
      `get_restaurant_by_${field}`
    );

    const restaurant = result.rows[0] || null;

    // Guardar en cache
    if (restaurant) {
      restaurantCache.set(key, {
        data: restaurant,
        timestamp: Date.now()
      });
      logger.debug('Restaurante guardado en cache', { key, field });
    }

    return restaurant;
    
  } catch (error) {
    logger.error(`Error obteniendo restaurante por ${field}:`, error);
    throw error;
  }
};

// ============================================
// RESOLVERS DE TENANT
// ============================================

/**
 * Resuelve tenant por slug en la URL
 * Ejemplo: /webhook/hot-wings
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveBySlug = async (req) => {
  const slug = req.params.restaurantSlug || req.params.slug;
  
  if (!slug) {
    return null;
  }

  // Validar formato del slug
  if (!VALIDATION_PATTERNS.SLUG.test(slug)) {
    throw new ValidationError('Formato de slug inv√°lido');
  }

  logger.debug('Resolviendo tenant por slug', { slug });
  
  const restaurant = await getRestaurantFromCacheOrDB(
    `slug:${slug}`, 
    slug, 
    'slug'
  );

  if (restaurant) {
    logger.debug('Tenant resuelto por slug', { 
      slug, 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

/**
 * Resuelve tenant por n√∫mero de WhatsApp
 * Para webhooks que llegan con n√∫mero espec√≠fico
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveByWhatsAppNumber = async (req) => {
  // Obtener n√∫mero del webhook (Twilio format: whatsapp:+525512345678)
  let phoneNumber = req.body?.To || req.body?.to;
  
  if (!phoneNumber) {
    return null;
  }

  // Limpiar formato de Twilio
  if (phoneNumber.startsWith('whatsapp:')) {
    phoneNumber = phoneNumber.replace('whatsapp:', '');
  }

  logger.debug('Resolviendo tenant por n√∫mero WhatsApp', { phoneNumber });

  // Buscar por twilio_phone_number
  let restaurant = await getRestaurantFromCacheOrDB(
    `twilio:${phoneNumber}`,
    phoneNumber,
    'twilio_phone_number'
  );

  // Si no se encuentra, buscar por phone principal
  if (!restaurant) {
    restaurant = await getRestaurantFromCacheOrDB(
      `phone:${phoneNumber}`,
      phoneNumber,
      'phone'
    );
  }

  if (restaurant) {
    logger.debug('Tenant resuelto por WhatsApp', { 
      phoneNumber, 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

/**
 * Resuelve tenant por Meta WhatsApp Phone Number ID
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveByMetaPhoneId = async (req) => {
  const phoneNumberId = req.body?.entry?.[0]?.changes?.[0]?.value?.metadata?.phone_number_id;
  
  if (!phoneNumberId) {
    return null;
  }

  logger.debug('Resolviendo tenant por Meta Phone ID', { phoneNumberId });

  const restaurant = await getRestaurantFromCacheOrDB(
    `meta:${phoneNumberId}`,
    phoneNumberId,
    'whatsapp_phone_id'
  );

  if (restaurant) {
    logger.debug('Tenant resuelto por Meta WhatsApp', { 
      phoneNumberId, 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

/**
 * Resuelve tenant por header personalizado
 * Para casos especiales o APIs internas
 * @param {Object} req - Request object
 * @returns {Promise<Object|null>} Datos del restaurante
 */
const resolveByHeader = async (req) => {
  const restaurantId = req.headers['x-restaurant-id'];
  const restaurantSlug = req.headers['x-restaurant-slug'];

  if (!restaurantId && !restaurantSlug) {
    return null;
  }

  logger.debug('Resolviendo tenant por header', { restaurantId, restaurantSlug });

  let restaurant = null;

  if (restaurantId) {
    restaurant = await getRestaurantFromCacheOrDB(
      `id:${restaurantId}`,
      restaurantId,
      'id'
    );
  } else if (restaurantSlug) {
    restaurant = await getRestaurantFromCacheOrDB(
      `slug:${restaurantSlug}`,
      restaurantSlug,
      'slug'
    );
  }

  if (restaurant) {
    logger.debug('Tenant resuelto por header', { 
      restaurantId: restaurant.id,
      restaurantName: restaurant.name 
    });
  }

  return restaurant;
};

// ============================================
// MIDDLEWARE PRINCIPAL
// ============================================

/**
 * Middleware principal para resolver tenant
 * Intenta diferentes m√©todos en orden de prioridad
 * @param {Object} options - Opciones de configuraci√≥n
 * @returns {Function} Middleware function
 */
const tenantResolver = (options = {}) => {
  const {
    required = false,
    methods = ['slug', 'whatsapp', 'meta', 'header'],
    onNotFound = null,
    skipPaths = ['/health', '/']
  } = options;

  return async (req, res, next) => {
    try {
      // Saltar paths espec√≠ficos
      if (skipPaths.includes(req.path)) {
        return next();
      }

      logger.debug('Iniciando resoluci√≥n de tenant', {
        path: req.path,
        method: req.method,
        methods: methods
      });

      let restaurant = null;

      // Intentar diferentes m√©todos de resoluci√≥n
      for (const method of methods) {
        switch (method) {
          case 'slug':
            restaurant = await resolveBySlug(req);
            break;
          case 'whatsapp':
            restaurant = await resolveByWhatsAppNumber(req);
            break;
          case 'meta':
            restaurant = await resolveByMetaPhoneId(req);
            break;
          case 'header':
            restaurant = await resolveByHeader(req);
            break;
          default:
            logger.warn('M√©todo de resoluci√≥n desconocido:', method);
        }

        if (restaurant) {
          break;
        }
      }

      // Verificar si el restaurante est√° activo
      if (restaurant && !restaurant.is_active) {
        logger.warn('Intento de acceso a restaurante inactivo', {
          restaurantId: restaurant.id,
          restaurantName: restaurant.name
        });
        restaurant = null;
      }

      // Manejar caso de restaurante no encontrado
      if (!restaurant) {
        logger.warn('Tenant no resuelto', {
          path: req.path,
          method: req.method,
          body: req.body,
          params: req.params,
          headers: {
            'x-restaurant-id': req.headers['x-restaurant-id'],
            'x-restaurant-slug': req.headers['x-restaurant-slug']
          }
        });

        if (required) {
          if (onNotFound && typeof onNotFound === 'function') {
            return onNotFound(req, res, next);
          }
          
          throw new NotFoundError('Restaurante no encontrado o inactivo');
        }
      }

      // Agregar datos del restaurante al request
      if (restaurant) {
        req.restaurant = restaurant;
        req.restaurantId = restaurant.id;
        req.tenant = restaurant; // Alias para compatibilidad
        
        logger.info('Tenant resuelto exitosamente', {
          restaurantId: restaurant.id,
          restaurantName: restaurant.name,
          slug: restaurant.slug,
          path: req.path
        });

        // Agregar header de respuesta
        res.set('X-Restaurant-ID', restaurant.id);
        res.set('X-Restaurant-Name', restaurant.name);
      }

      next();

    } catch (error) {
      logger.error('Error en resoluci√≥n de tenant:', error);
      next(error);
    }
  };
};

// ============================================
// MIDDLEWARES ESPEC√çFICOS
// ============================================

/**
 * Middleware para webhooks que requiere tenant
 */
const webhookTenantResolver = tenantResolver({
  required: true,
  methods: ['slug', 'whatsapp', 'meta'],
  onNotFound: (req, res, next) => {
    // Para webhooks, devolver 200 para evitar reintentos
    res.status(200).json({
      success: false,
      message: 'Webhook recibido pero restaurante no encontrado'
    });
  }
});

/**
 * Middleware para API que requiere tenant
 */
const apiTenantResolver = tenantResolver({
  required: true,
  methods: ['header', 'slug'],
  skipPaths: ['/health', '/', '/api/docs']
});

/**
 * Middleware para dashboard que puede ser opcional
 */
const dashboardTenantResolver = tenantResolver({
  required: false,
  methods: ['header', 'slug'],
  skipPaths: ['/health', '/', '/api/docs', '/api/restaurants']
});

// ============================================
// UTILIDADES
// ============================================

/**
 * Obtiene datos completos del restaurante incluyendo men√∫ y reglas
 * @param {string} restaurantId - ID del restaurante
 * @returns {Promise<Object>} Datos completos del restaurante
 */
const getFullRestaurantData = async (restaurantId) => {
  try {
    const cacheKey = `full:${restaurantId}`;
    const cached = restaurantCache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < cacheTimeout) {
      return cached.data;
    }

    // Obtener datos base del restaurante
    const restaurantResult = await query(
      `SELECT * FROM restaurants WHERE id = $1 AND is_active = true`,
      [restaurantId],
      'get_full_restaurant_base'
    );

    if (restaurantResult.rows.length === 0) {
      return null;
    }

    const restaurant = restaurantResult.rows[0];

    // Obtener men√∫ activo
    const menuResult = await query(
      `SELECT 
        mi.id, mi.name, mi.description, mi.price, mi.is_available,
        mi.preparation_time, mi.display_order, mi.image_url,
        mc.name as category_name, mc.emoji as category_emoji
      FROM menu_items mi
      JOIN menu_categories mc ON mi.category_id = mc.id
      WHERE mi.restaurant_id = $1 AND mi.is_available = true
      ORDER BY mc.display_order, mi.display_order`,
      [restaurantId],
      'get_restaurant_menu'
    );

    // Obtener reglas de negocio
    const rulesResult = await query(
      `SELECT 
        id, menu_item_id, rule_type, rule_name, rule_config, ai_message_template
      FROM business_rules 
      WHERE restaurant_id = $1 AND is_active = true`,
      [restaurantId],
      'get_restaurant_rules'
    );

    const fullData = {
      ...restaurant,
      menu: menuResult.rows,
      business_rules: rulesResult.rows
    };

    // Guardar en cache
    restaurantCache.set(cacheKey, {
      data: fullData,
      timestamp: Date.now()
    });

    return fullData;

  } catch (error) {
    logger.error('Error obteniendo datos completos del restaurante:', error);
    throw error;
  }
};

/**
 * Valida si un restaurante est√° abierto en el horario actual
 * @param {Object} restaurant - Datos del restaurante
 * @returns {boolean} True si est√° abierto
 */
const isRestaurantOpen = (restaurant) => {
  if (!restaurant.opens_at || !restaurant.closes_at) {
    return true; // Si no hay horarios definidos, asumir abierto
  }

  const now = new Date();
  const currentTime = now.toTimeString().slice(0, 8); // HH:mm:ss

  const opensAt = restaurant.opens_at;
  const closesAt = restaurant.closes_at;

  // Manejar caso donde cierra despu√©s de medianoche
  if (closesAt < opensAt) {
    return currentTime >= opensAt || currentTime <= closesAt;
  }

  return currentTime >= opensAt && currentTime <= closesAt;
};

/**
 * Middleware que verifica horarios de operaci√≥n
 */
const checkOperatingHours = (req, res, next) => {
  if (!req.restaurant) {
    return next();
  }

  if (!isRestaurantOpen(req.restaurant)) {
    logger.info('Intento de acceso fuera de horario', {
      restaurantId: req.restaurant.id,
      currentTime: new Date().toTimeString().slice(0, 8),
      opensAt: req.restaurant.opens_at,
      closesAt: req.restaurant.closes_at
    });

    // Para webhooks, responder con mensaje apropiado
    if (req.path.startsWith('/webhook')) {
      return res.status(200).json({
        success: true,
        message: 'Restaurante cerrado'
      });
    }

    return res.status(400).json({
      success: false,
      error: {
        type: 'restaurant_closed',
        message: `Restaurante cerrado. Horarios: ${req.restaurant.opens_at} - ${req.restaurant.closes_at}`
      }
    });
  }

  next();
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Middleware principal
  tenantResolver,
  
  // Middlewares espec√≠ficos
  webhookTenantResolver,
  apiTenantResolver,
  dashboardTenantResolver,
  
  // Utilidades
  getFullRestaurantData,
  isRestaurantOpen,
  checkOperatingHours,
  clearRestaurantCache,
  
  // Resolvers individuales (para testing)
  resolveBySlug,
  resolveByWhatsAppNumber,
  resolveByMetaPhoneId,
  resolveByHeader
};


================================================
File: src/models/Conversation.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { CONVERSATION_STATUS, CONVERSATION_STEPS, TIME_LIMITS } = require('../utils/constants');

// ============================================
// MODELO CONVERSATION
// ============================================

class Conversation {

  /**
   * Crea o obtiene una conversaci√≥n activa
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Tel√©fono del cliente
   * @returns {Promise<Object>} Conversaci√≥n activa
   */
  static async getOrCreate(restaurantId, customerPhone) {
    if (!restaurantId || !customerPhone) {
      throw new ValidationError('ID del restaurante y tel√©fono del cliente son requeridos');
    }

    try {
      // Primero intentar obtener conversaci√≥n activa
      let conversation = await this.getActive(restaurantId, customerPhone);

      if (conversation) {
        // Verificar si no ha expirado
        const timeLimit = conversation.max_conversation_time || TIME_LIMITS.MAX_CONVERSATION_TIME;
        const timeSinceLastInteraction = Date.now() - new Date(conversation.last_interaction_at).getTime();

        if (timeSinceLastInteraction > timeLimit * 1000) {
          // Marcar como abandonada y crear nueva
          await this.abandon(conversation.id);
          conversation = null;
        } else {
          // Actualizar timestamp de √∫ltima interacci√≥n
          await this.updateLastInteraction(conversation.id);
          return conversation;
        }
      }

      // Crear nueva conversaci√≥n
      if (!conversation) {
        const result = await query(
          `INSERT INTO conversations (
            id, restaurant_id, customer_phone, status, current_step,
            order_data, ai_context, last_interaction_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP)
          RETURNING *`,
          [
            uuidv4(),
            restaurantId,
            customerPhone,
            CONVERSATION_STATUS.ACTIVE,
            CONVERSATION_STEPS.GREETING,
            JSON.stringify({
              items: [],
              subtotal: 0,
              delivery_fee: 0,
              total: 0
            }),
            JSON.stringify([])
          ],
          'create_conversation'
        );

        conversation = result.rows[0];

        logger.info('Nueva conversaci√≥n creada', {
          conversationId: conversation.id,
          restaurantId,
          customerPhone: customerPhone.substring(0, 8) + '****'
        });
      }

      return conversation;

    } catch (error) {
      logger.error('Error creando/obteniendo conversaci√≥n:', error);
      throw new DatabaseError('Error al gestionar conversaci√≥n', error);
    }
  }

  /**
   * Obtiene conversaci√≥n activa
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Tel√©fono del cliente
   * @returns {Promise<Object|null>} Conversaci√≥n activa
   */
  static async getActive(restaurantId, customerPhone) {
    try {
      const result = await query(
        `SELECT * FROM conversations 
         WHERE restaurant_id = $1 AND customer_phone = $2 AND status = $3
         ORDER BY last_interaction_at DESC
         LIMIT 1`,
        [restaurantId, customerPhone, CONVERSATION_STATUS.ACTIVE],
        'get_active_conversation'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error obteniendo conversaci√≥n activa:', error);
      throw new DatabaseError('Error al obtener conversaci√≥n', error);
    }
  }

  /**
   * Obtiene conversaci√≥n por ID
   * @param {string} conversationId - ID de la conversaci√≥n
   * @returns {Promise<Object|null>} Conversaci√≥n
   */
  static async findById(conversationId) {
    try {
      const result = await query(
        'SELECT * FROM conversations WHERE id = $1',
        [conversationId],
        'find_conversation_by_id'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error obteniendo conversaci√≥n por ID:', error);
      throw new DatabaseError('Error al obtener conversaci√≥n', error);
    }
  }

  /**
   * Actualiza el estado de la conversaci√≥n
   * @param {string} conversationId - ID de la conversaci√≥n
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async update(conversationId, updateData) {
    const allowedFields = [
      'status', 'current_step', 'order_data', 'ai_context', 'conversation_summary'
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        let value = updateData[key];
        
        // Serializar objetos/arrays a JSON
        if (key === 'order_data' || key === 'ai_context') {
          value = JSON.stringify(value);
        }
        
        fields.push(`${key} = $${paramCount}`);
        values.push(value);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos v√°lidos para actualizar');
    }

    // Siempre actualizar timestamp de √∫ltima interacci√≥n
    fields.push(`last_interaction_at = CURRENT_TIMESTAMP`);
    values.push(conversationId);

    try {
      const result = await query(
        `UPDATE conversations 
         SET ${fields.join(', ')}
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_conversation'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Conversaci√≥n');
      }

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando conversaci√≥n:', error);
      throw new DatabaseError('Error al actualizar conversaci√≥n', error);
    }
  }

  /**
   * Actualiza solo el timestamp de √∫ltima interacci√≥n
   * @param {string} conversationId - ID de la conversaci√≥n
   * @returns {Promise<boolean>} True si se actualiz√≥
   */
  static async updateLastInteraction(conversationId) {
    try {
      const result = await query(
        'UPDATE conversations SET last_interaction_at = CURRENT_TIMESTAMP WHERE id = $1',
        [conversationId],
        'update_last_interaction'
      );

      return result.rowCount > 0;

    } catch (error) {
      logger.error('Error actualizando √∫ltima interacci√≥n:', error);
      throw new DatabaseError('Error al actualizar interacci√≥n', error);
    }
  }

  /**
   * Agrega un mensaje al contexto de IA
   * @param {string} conversationId - ID de la conversaci√≥n
   * @param {string} role - 'user' o 'assistant'
   * @param {string} content - Contenido del mensaje
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async addToContext(conversationId, role, content) {
    if (!['user', 'assistant'].includes(role)) {
      throw new ValidationError('Role debe ser "user" o "assistant"');
    }

    try {
      // Obtener conversaci√≥n actual
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversaci√≥n');
      }

      // Obtener contexto actual
      let aiContext = [];
      try {
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando contexto de IA, reiniciando:', e);
        aiContext = [];
      }

      // Agregar nuevo mensaje
      const newMessage = {
        role,
        content,
        timestamp: new Date().toISOString()
      };

      aiContext.push(newMessage);

      // Mantener solo los √∫ltimos 12 mensajes (6 intercambios)
      if (aiContext.length > 12) {
        aiContext = aiContext.slice(-12);
      }

      // Actualizar conversaci√≥n
      return await this.update(conversationId, {
        ai_context: aiContext
      });

    } catch (error) {
      logger.error('Error agregando mensaje al contexto:', error);
      throw new DatabaseError('Error al actualizar contexto', error);
    }
  }

  /**
   * Actualiza los datos del pedido en la conversaci√≥n
   * @param {string} conversationId - ID de la conversaci√≥n
   * @param {Object} orderData - Datos del pedido
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async updateOrderData(conversationId, orderData) {
    try {
      // Obtener conversaci√≥n actual
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversaci√≥n');
      }

      // Obtener datos actuales del pedido
      let currentOrderData = {};
      try {
        currentOrderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        logger.warn('Error parseando datos del pedido, reiniciando:', e);
        currentOrderData = { items: [], subtotal: 0, delivery_fee: 0, total: 0 };
      }

      // Fusionar con nuevos datos
      const updatedOrderData = {
        ...currentOrderData,
        ...orderData
      };

      // Recalcular totales si hay items
      if (updatedOrderData.items && updatedOrderData.items.length > 0) {
        updatedOrderData.subtotal = updatedOrderData.items.reduce(
          (sum, item) => sum + (item.item_total || 0), 0
        );
        updatedOrderData.total = updatedOrderData.subtotal + (updatedOrderData.delivery_fee || 0);
      }

      return await this.update(conversationId, {
        order_data: updatedOrderData
      });

    } catch (error) {
      logger.error('Error actualizando datos del pedido:', error);
      throw new DatabaseError('Error al actualizar pedido', error);
    }
  }

  /**
   * Agrega un item al pedido
   * @param {string} conversationId - ID de la conversaci√≥n
   * @param {Object} item - Item a agregar
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async addItemToOrder(conversationId, item) {
    try {
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversaci√≥n');
      }

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        orderData = { items: [], subtotal: 0, delivery_fee: 0, total: 0 };
      }

      if (!orderData.items) {
        orderData.items = [];
      }

      // Validar item
      if (!item.menu_item_id || !item.name || !item.base_price || !item.quantity) {
        throw new ValidationError('Item incompleto: faltan campos requeridos');
      }

      // Calcular total del item
      const customizationsCost = (item.customizations || [])
        .reduce((sum, custom) => sum + (custom.extra_cost || 0), 0);
      
      item.item_total = (item.base_price + customizationsCost) * item.quantity;
      item.added_at = new Date().toISOString();

      // Agregar item
      orderData.items.push(item);

      return await this.updateOrderData(conversationId, orderData);

    } catch (error) {
      logger.error('Error agregando item al pedido:', error);
      throw new DatabaseError('Error al agregar item', error);
    }
  }

  /**
   * Remueve un item del pedido
   * @param {string} conversationId - ID de la conversaci√≥n
   * @param {number} itemIndex - √çndice del item a remover
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async removeItemFromOrder(conversationId, itemIndex) {
    try {
      const conversation = await this.findById(conversationId);
      if (!conversation) {
        throw new NotFoundError('Conversaci√≥n');
      }

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        throw new ValidationError('Error al procesar datos del pedido');
      }

      if (!orderData.items || itemIndex < 0 || itemIndex >= orderData.items.length) {
        throw new ValidationError('√çndice de item inv√°lido');
      }

      // Remover item
      const removedItem = orderData.items.splice(itemIndex, 1)[0];

      logger.info('Item removido del pedido', {
        conversationId,
        removedItem: removedItem.name,
        remainingItems: orderData.items.length
      });

      return await this.updateOrderData(conversationId, orderData);

    } catch (error) {
      logger.error('Error removiendo item del pedido:', error);
      throw new DatabaseError('Error al remover item', error);
    }
  }

  /**
   * Marca conversaci√≥n como completada
   * @param {string} conversationId - ID de la conversaci√≥n
   * @param {string} orderId - ID del pedido creado (opcional)
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async complete(conversationId, orderId = null) {
    try {
      const updateData = {
        status: CONVERSATION_STATUS.COMPLETED,
        current_step: CONVERSATION_STEPS.COMPLETED
      };

      if (orderId) {
        // Agregar referencia al pedido en los datos
        const conversation = await this.findById(conversationId);
        if (conversation) {
          let orderData = JSON.parse(conversation.order_data || '{}');
          orderData.order_id = orderId;
          updateData.order_data = orderData;
        }
      }

      const result = await this.update(conversationId, updateData);

      logger.info('Conversaci√≥n completada', {
        conversationId,
        orderId
      });

      return result;

    } catch (error) {
      logger.error('Error completando conversaci√≥n:', error);
      throw new DatabaseError('Error al completar conversaci√≥n', error);
    }
  }

  /**
   * Marca conversaci√≥n como abandonada
   * @param {string} conversationId - ID de la conversaci√≥n
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async abandon(conversationId) {
    try {
      const result = await this.update(conversationId, {
        status: CONVERSATION_STATUS.ABANDONED
      });

      logger.info('Conversaci√≥n marcada como abandonada', { conversationId });
      return result;

    } catch (error) {
      logger.error('Error marcando conversaci√≥n como abandonada:', error);
      throw new DatabaseError('Error al abandonar conversaci√≥n', error);
    }
  }

  /**
   * Limpia conversaciones inactivas
   * @param {number} maxInactiveHours - Horas m√°ximas de inactividad
   * @returns {Promise<number>} N√∫mero de conversaciones limpiadas
   */
  static async cleanupInactive(maxInactiveHours = 2) {
    try {
      const result = await query(
        `UPDATE conversations 
         SET status = $1 
         WHERE status = $2 
         AND last_interaction_at < CURRENT_TIMESTAMP - INTERVAL '${maxInactiveHours} hours'`,
        [CONVERSATION_STATUS.ABANDONED, CONVERSATION_STATUS.ACTIVE],
        'cleanup_inactive_conversations'
      );

      const cleanedCount = result.rowCount;

      if (cleanedCount > 0) {
        logger.info('Conversaciones inactivas limpiadas', {
          count: cleanedCount,
          maxInactiveHours
        });
      }

      return cleanedCount;

    } catch (error) {
      logger.error('Error limpiando conversaciones inactivas:', error);
      throw new DatabaseError('Error en limpieza de conversaciones', error);
    }
  }

  /**
   * Obtiene estad√≠sticas de conversaciones
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas
   */
  static async getStats(restaurantId, dateRange = {}) {
    const { startDate, endDate } = dateRange;
    
    try {
      let dateCondition = '';
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = 'AND created_at BETWEEN $2 AND $3';
        values.push(startDate, endDate);
      }

      const result = await query(
        `SELECT 
          COUNT(*) as total_conversations,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_conversations,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_conversations,
          COUNT(CASE WHEN status = 'abandoned' THEN 1 END) as abandoned_conversations,
          COUNT(DISTINCT customer_phone) as unique_customers,
          AVG(EXTRACT(EPOCH FROM (last_interaction_at - created_at))/60) as avg_duration_minutes
        FROM conversations 
        WHERE restaurant_id = $1 ${dateCondition}`,
        values,
        'get_conversation_stats'
      );

      const stats = result.rows[0];

      // Calcular tasas
      const total = parseInt(stats.total_conversations);
      stats.completion_rate = total > 0 
        ? ((parseInt(stats.completed_conversations) / total) * 100).toFixed(2)
        : 0;

      stats.abandonment_rate = total > 0
        ? ((parseInt(stats.abandoned_conversations) / total) * 100).toFixed(2)
        : 0;

      stats.avg_duration_minutes = parseFloat(stats.avg_duration_minutes || 0).toFixed(2);

      return stats;

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de conversaciones:', error);
      throw new DatabaseError('Error al obtener estad√≠sticas', error);
    }
  }

  /**
   * Obtiene conversaciones recientes de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Lista paginada de conversaciones
   */
  static async getRecent(restaurantId, options = {}) {
    const {
      page = 1,
      limit = 20,
      status = null,
      customerPhone = null
    } = options;

    const offset = (page - 1) * limit;

    try {
      const conditions = ['restaurant_id = $1'];
      const values = [restaurantId];
      let paramCount = 2;

      if (status) {
        conditions.push(`status = $${paramCount}`);
        values.push(status);
        paramCount++;
      }

      if (customerPhone) {
        conditions.push(`customer_phone = $${paramCount}`);
        values.push(customerPhone);
        paramCount++;
      }

      const whereClause = conditions.join(' AND ');

      // Consulta principal
      const conversationsResult = await query(
        `SELECT 
          id, customer_phone, status, current_step,
          last_interaction_at, created_at,
          CASE 
            WHEN order_data::text != '{}' THEN 
              (order_data->>'total')::numeric 
            ELSE 0 
          END as order_total
        FROM conversations 
        WHERE ${whereClause}
        ORDER BY last_interaction_at DESC
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'get_recent_conversations'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM conversations WHERE ${whereClause}`,
        values.slice(0, -2),
        'count_conversations'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        conversations: conversationsResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error obteniendo conversaciones recientes:', error);
      throw new DatabaseError('Error al obtener conversaciones', error);
    }
  }
}

module.exports = Conversation;


================================================
File: src/models/Customer.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { formatPhoneNumber, isValidWhatsAppNumber } = require('../config/whatsapp');

// ============================================
// MODELO CUSTOMER
// ============================================

class Customer {

  /**
   * Crea o obtiene un cliente por tel√©fono
   * @param {string} phone - N√∫mero de tel√©fono
   * @param {Object} additionalData - Datos adicionales del cliente
   * @returns {Promise<Object>} Cliente creado o existente
   */
  static async findOrCreate(phone, additionalData = {}) {
    if (!phone) {
      throw new ValidationError('N√∫mero de tel√©fono es requerido');
    }

    const formattedPhone = formatPhoneNumber(phone);
    
    if (!isValidWhatsAppNumber(formattedPhone)) {
      throw new ValidationError('N√∫mero de tel√©fono inv√°lido');
    }

    try {
      // Primero intentar encontrar cliente existente
      let customer = await this.findByPhone(formattedPhone);

      if (customer) {
        // Si hay datos adicionales, actualizar
        if (Object.keys(additionalData).length > 0) {
          customer = await this.update(customer.id, additionalData);
        }
        return customer;
      }

      // Crear nuevo cliente
      const {
        name = null,
        default_address = null,
        default_references = null
      } = additionalData;

      const result = await query(
        `INSERT INTO customers (
          id, phone, name, default_address, default_references, first_order_at
        ) VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)
        RETURNING *`,
        [uuidv4(), formattedPhone, name, default_address, default_references],
        'create_customer'
      );

      customer = result.rows[0];

      logger.info('Nuevo cliente creado', {
        customerId: customer.id,
        phone: formattedPhone.substring(0, 8) + '****'
      });

      return customer;

    } catch (error) {
      if (error.code === '23505') { // unique violation
        // Race condition - otro proceso cre√≥ el cliente
        return await this.findByPhone(formattedPhone);
      }

      logger.error('Error creando/obteniendo cliente:', error);
      throw new DatabaseError('Error al gestionar cliente', error);
    }
  }

  /**
   * Busca un cliente por tel√©fono
   * @param {string} phone - N√∫mero de tel√©fono
   * @returns {Promise<Object|null>} Cliente encontrado
   */
  static async findByPhone(phone) {
    try {
      const formattedPhone = formatPhoneNumber(phone);
      
      const result = await query(
        'SELECT * FROM customers WHERE phone = $1',
        [formattedPhone],
        'find_customer_by_phone'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error buscando cliente por tel√©fono:', error);
      throw new DatabaseError('Error al buscar cliente', error);
    }
  }

  /**
   * Busca un cliente por ID
   * @param {string} customerId - ID del cliente
   * @returns {Promise<Object|null>} Cliente encontrado
   */
  static async findById(customerId) {
    try {
      const result = await query(
        'SELECT * FROM customers WHERE id = $1',
        [customerId],
        'find_customer_by_id'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error buscando cliente por ID:', error);
      throw new DatabaseError('Error al buscar cliente', error);
    }
  }

  /**
   * Actualiza datos de un cliente
   * @param {string} customerId - ID del cliente
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Cliente actualizado
   */
  static async update(customerId, updateData) {
    const allowedFields = ['name', 'default_address', 'default_references'];
    
    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos v√°lidos para actualizar');
    }

    values.push(customerId);

    try {
      const result = await query(
        `UPDATE customers 
         SET ${fields.join(', ')}
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_customer'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Cliente');
      }

      logger.info('Cliente actualizado', {
        customerId,
        updatedFields: Object.keys(updateData)
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando cliente:', error);
      throw new DatabaseError('Error al actualizar cliente', error);
    }
  }

  /**
   * Obtiene el historial de pedidos de un cliente
   * @param {string} customerId - ID del cliente
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Historial paginado
   */
  static async getOrderHistory(customerId, options = {}) {
    const {
      page = 1,
      limit = 10,
      restaurantId = null,
      startDate = null,
      endDate = null
    } = options;

    const offset = (page - 1) * limit;

    try {
      const conditions = ['o.customer_id = $1'];
      const values = [customerId];
      let paramCount = 2;

      if (restaurantId) {
        conditions.push(`o.restaurant_id = $${paramCount}`);
        values.push(restaurantId);
        paramCount++;
      }

      if (startDate) {
        conditions.push(`o.created_at >= $${paramCount}`);
        values.push(startDate);
        paramCount++;
      }

      if (endDate) {
        conditions.push(`o.created_at <= $${paramCount}`);
        values.push(endDate);
        paramCount++;
      }

      const whereClause = conditions.join(' AND ');

      // Consulta principal
      const ordersResult = await query(
        `SELECT 
          o.id, o.status, o.total, o.created_at, o.delivered_at,
          r.name as restaurant_name,
          COUNT(oi.id) as items_count
        FROM orders o
        JOIN restaurants r ON o.restaurant_id = r.id
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE ${whereClause}
        GROUP BY o.id, r.name
        ORDER BY o.created_at DESC
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'get_customer_order_history'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM orders o WHERE ${whereClause}`,
        values.slice(0, -2),
        'count_customer_orders'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        orders: ordersResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error obteniendo historial de pedidos:', error);
      throw new DatabaseError('Error al obtener historial', error);
    }
  }

  /**
   * Obtiene estad√≠sticas de un cliente
   * @param {string} customerId - ID del cliente
   * @returns {Promise<Object>} Estad√≠sticas del cliente
   */
  static async getStats(customerId) {
    try {
      const result = await query(
        `SELECT 
          c.total_orders,
          c.total_spent,
          c.first_order_at,
          c.last_order_at,
          COUNT(DISTINCT o.restaurant_id) as restaurants_visited,
          COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as completed_orders,
          COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders,
          COALESCE(AVG(CASE WHEN o.status = 'delivered' THEN o.total END), 0) as avg_order_value,
          
          -- Items favoritos
          (SELECT oi.item_name 
           FROM order_items oi 
           JOIN orders o2 ON oi.order_id = o2.id
           WHERE o2.customer_id = c.id AND o2.status = 'delivered'
           GROUP BY oi.item_name 
           ORDER BY COUNT(*) DESC 
           LIMIT 1) as favorite_item,
           
          -- Restaurante favorito
          (SELECT r.name 
           FROM orders o3 
           JOIN restaurants r ON o3.restaurant_id = r.id
           WHERE o3.customer_id = c.id AND o3.status = 'delivered'
           GROUP BY r.id, r.name 
           ORDER BY COUNT(*) DESC 
           LIMIT 1) as favorite_restaurant

        FROM customers c
        LEFT JOIN orders o ON c.id = o.customer_id
        WHERE c.id = $1
        GROUP BY c.id`,
        [customerId],
        'get_customer_stats'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Cliente');
      }

      const stats = result.rows[0];

      // Calcular m√©tricas adicionales
      stats.completion_rate = stats.total_orders > 0 
        ? ((stats.completed_orders / stats.total_orders) * 100).toFixed(2)
        : 0;

      stats.cancellation_rate = stats.total_orders > 0
        ? ((stats.cancelled_orders / stats.total_orders) * 100).toFixed(2)
        : 0;

      // Calcular d√≠as como cliente
      if (stats.first_order_at) {
        const daysSinceFirstOrder = Math.floor(
          (Date.now() - new Date(stats.first_order_at).getTime()) / (1000 * 60 * 60 * 24)
        );
        stats.days_as_customer = daysSinceFirstOrder;
        stats.orders_per_month = daysSinceFirstOrder > 0 
          ? ((stats.total_orders / daysSinceFirstOrder) * 30).toFixed(2)
          : 0;
      }

      return stats;

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de cliente:', error);
      throw new DatabaseError('Error al obtener estad√≠sticas', error);
    }
  }

  /**
   * Obtiene los items favoritos de un cliente
   * @param {string} customerId - ID del cliente
   * @param {number} limit - L√≠mite de resultados
   * @returns {Promise<Array>} Items favoritos
   */
  static async getFavoriteItems(customerId, limit = 5) {
    try {
      const result = await query(
        `SELECT 
          oi.item_name,
          oi.menu_item_id,
          COUNT(*) as order_count,
          SUM(oi.quantity) as total_quantity,
          AVG(oi.base_price) as avg_price,
          MAX(o.created_at) as last_ordered,
          mi.image_url
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE o.customer_id = $1 AND o.status = 'delivered'
        GROUP BY oi.menu_item_id, oi.item_name, mi.image_url
        ORDER BY order_count DESC, total_quantity DESC
        LIMIT $2`,
        [customerId, limit],
        'get_customer_favorite_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo items favoritos del cliente:', error);
      throw new DatabaseError('Error al obtener items favoritos', error);
    }
  }

  /**
   * Obtiene clientes frecuentes de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Array>} Clientes frecuentes
   */
  static async getFrequentCustomers(restaurantId, options = {}) {
    const {
      limit = 20,
      minOrders = 3,
      period = null // 'month', 'week', etc.
    } = options;

    try {
      let dateCondition = '';
      const values = [restaurantId, minOrders, limit];

      if (period === 'month') {
        dateCondition = "AND o.created_at >= CURRENT_DATE - INTERVAL '30 days'";
      } else if (period === 'week') {
        dateCondition = "AND o.created_at >= CURRENT_DATE - INTERVAL '7 days'";
      }

      const result = await query(
        `SELECT 
          c.id,
          c.phone,
          c.name,
          c.default_address,
          COUNT(o.id) as total_orders,
          SUM(CASE WHEN o.status = 'delivered' THEN o.total ELSE 0 END) as total_spent,
          MAX(o.created_at) as last_order_date,
          AVG(CASE WHEN o.status = 'delivered' THEN o.total END) as avg_order_value
        FROM customers c
        JOIN orders o ON c.id = o.customer_id
        WHERE o.restaurant_id = $1 ${dateCondition}
        GROUP BY c.id
        HAVING COUNT(o.id) >= $2
        ORDER BY total_orders DESC, total_spent DESC
        LIMIT $3`,
        values,
        'get_frequent_customers'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo clientes frecuentes:', error);
      throw new DatabaseError('Error al obtener clientes frecuentes', error);
    }
  }

  /**
   * Busca clientes por criterios
   * @param {Object} searchCriteria - Criterios de b√∫squeda
   * @param {Object} options - Opciones de paginaci√≥n
   * @returns {Promise<Object>} Resultados paginados
   */
  static async search(searchCriteria = {}, options = {}) {
    const {
      phone = null,
      name = null,
      minOrders = null,
      maxOrders = null,
      minSpent = null,
      maxSpent = null
    } = searchCriteria;

    const {
      page = 1,
      limit = 20,
      sortBy = 'total_orders',
      sortOrder = 'DESC'
    } = options;

    const offset = (page - 1) * limit;

    try {
      const conditions = [];
      const values = [];
      let paramCount = 1;

      if (phone) {
        conditions.push(`c.phone ILIKE $${paramCount}`);
        values.push(`%${phone}%`);
        paramCount++;
      }

      if (name) {
        conditions.push(`c.name ILIKE $${paramCount}`);
        values.push(`%${name}%`);
        paramCount++;
      }

      if (minOrders !== null) {
        conditions.push(`c.total_orders >= $${paramCount}`);
        values.push(minOrders);
        paramCount++;
      }

      if (maxOrders !== null) {
        conditions.push(`c.total_orders <= $${paramCount}`);
        values.push(maxOrders);
        paramCount++;
      }

      if (minSpent !== null) {
        conditions.push(`c.total_spent >= $${paramCount}`);
        values.push(minSpent);
        paramCount++;
      }

      if (maxSpent !== null) {
        conditions.push(`c.total_spent <= $${paramCount}`);
        values.push(maxSpent);
        paramCount++;
      }

      const whereClause = conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : '';

      // Consulta principal
      const customersResult = await query(
        `SELECT 
          c.*,
          EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - c.last_order_at))/86400 as days_since_last_order
        FROM customers c
        ${whereClause}
        ORDER BY c.${sortBy} ${sortOrder.toUpperCase()}
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'search_customers'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM customers c ${whereClause}`,
        values.slice(0, -2),
        'count_search_customers'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        customers: customersResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error buscando clientes:', error);
      throw new DatabaseError('Error al buscar clientes', error);
    }
  }

  /**
   * Actualiza estad√≠sticas despu√©s de un pedido
   * Esta funci√≥n es llamada autom√°ticamente cuando se crea un pedido
   * @param {string} customerId - ID del cliente
   * @param {number} orderTotal - Total del pedido
   * @returns {Promise<boolean>} True si se actualiz√≥ correctamente
   */
  static async updateOrderStats(customerId, orderTotal) {
    try {
      await query(
        `UPDATE customers 
         SET total_orders = total_orders + 1,
             total_spent = total_spent + $1,
             last_order_at = CURRENT_TIMESTAMP
         WHERE id = $2`,
        [orderTotal, customerId],
        'update_customer_order_stats'
      );

      return true;

    } catch (error) {
      logger.error('Error actualizando estad√≠sticas de cliente:', error);
      // No lanzar error para no afectar el flujo del pedido
      return false;
    }
  }

  /**
   * Obtiene recomendaciones para un cliente basadas en su historial
   * @param {string} customerId - ID del cliente
   * @param {string} restaurantId - ID del restaurante
   * @param {number} limit - L√≠mite de recomendaciones
   * @returns {Promise<Array>} Items recomendados
   */
  static async getRecommendations(customerId, restaurantId, limit = 5) {
    try {
      // Obtener items que el cliente no ha pedido pero que han pedido clientes similares
      const result = await query(
        `WITH customer_items AS (
          SELECT DISTINCT oi.menu_item_id
          FROM order_items oi
          JOIN orders o ON oi.order_id = o.id
          WHERE o.customer_id = $1 AND o.restaurant_id = $2
        ),
        similar_customers AS (
          SELECT DISTINCT o2.customer_id
          FROM orders o1
          JOIN orders o2 ON o1.restaurant_id = o2.restaurant_id
          JOIN order_items oi1 ON o1.id = oi1.order_id
          JOIN order_items oi2 ON o2.id = oi2.order_id
          WHERE o1.customer_id = $1 
          AND o1.restaurant_id = $2
          AND o2.customer_id != $1
          AND oi1.menu_item_id = oi2.menu_item_id
        ),
        recommended_items AS (
          SELECT 
            mi.id, mi.name, mi.description, mi.price, mi.image_url,
            COUNT(*) as popularity_score
          FROM menu_items mi
          JOIN order_items oi ON mi.id = oi.menu_item_id
          JOIN orders o ON oi.order_id = o.id
          WHERE o.customer_id IN (SELECT customer_id FROM similar_customers)
          AND o.restaurant_id = $2
          AND mi.is_available = true
          AND mi.id NOT IN (SELECT menu_item_id FROM customer_items)
          GROUP BY mi.id
        )
        SELECT * FROM recommended_items
        ORDER BY popularity_score DESC
        LIMIT $3`,
        [customerId, restaurantId, limit],
        'get_customer_recommendations'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo recomendaciones para cliente:', error);
      // Retornar array vac√≠o en caso de error
      return [];
    }
  }
}

module.exports = Customer;


================================================
File: src/models/Menu.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { getFoodEmoji } = require('../utils/constants');

// ============================================
// MODELO MENU
// ============================================

class Menu {

  // ============================================
  // CATEGOR√çAS
  // ============================================

  /**
   * Crea una nueva categor√≠a de men√∫
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} categoryData - Datos de la categor√≠a
   * @returns {Promise<Object>} Categor√≠a creada
   */
  static async createCategory(restaurantId, categoryData) {
    const {
      name,
      description = '',
      display_order = 0,
      emoji = null
    } = categoryData;

    if (!name) {
      throw new ValidationError('El nombre de la categor√≠a es requerido');
    }

    try {
      // Auto-asignar emoji si no se proporciona
      const finalEmoji = emoji || getFoodEmoji(name);

      const result = await query(
        `INSERT INTO menu_categories (
          id, restaurant_id, name, description, display_order, emoji
        ) VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING *`,
        [uuidv4(), restaurantId, name, description, display_order, finalEmoji],
        'create_menu_category'
      );

      logger.info('Categor√≠a de men√∫ creada', {
        restaurantId,
        categoryId: result.rows[0].id,
        name
      });

      return result.rows[0];

    } catch (error) {
      if (error.code === '23505') { // unique violation
        throw new ValidationError('Ya existe una categor√≠a con ese nombre en este restaurante');
      }

      logger.error('Error creando categor√≠a de men√∫:', error);
      throw new DatabaseError('Error al crear categor√≠a', error);
    }
  }

  /**
   * Obtiene todas las categor√≠as de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {boolean} activeOnly - Solo categor√≠as activas
   * @returns {Promise<Array>} Lista de categor√≠as
   */
  static async getCategories(restaurantId, activeOnly = true) {
    try {
      let whereClause = 'WHERE restaurant_id = $1';
      if (activeOnly) {
        whereClause += ' AND is_active = true';
      }

      const result = await query(
        `SELECT 
          id, name, description, display_order, emoji, is_active,
          created_at,
          (SELECT COUNT(*) FROM menu_items WHERE category_id = mc.id AND is_available = true) as items_count
        FROM menu_categories mc
        ${whereClause}
        ORDER BY display_order, name`,
        [restaurantId],
        'get_menu_categories'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo categor√≠as de men√∫:', error);
      throw new DatabaseError('Error al obtener categor√≠as', error);
    }
  }

  /**
   * Actualiza una categor√≠a
   * @param {string} categoryId - ID de la categor√≠a
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Categor√≠a actualizada
   */
  static async updateCategory(categoryId, updateData) {
    const allowedFields = ['name', 'description', 'display_order', 'emoji', 'is_active'];
    
    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos v√°lidos para actualizar');
    }

    values.push(categoryId);

    try {
      const result = await query(
        `UPDATE menu_categories 
         SET ${fields.join(', ')}
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_menu_category'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Categor√≠a');
      }

      logger.info('Categor√≠a actualizada', {
        categoryId,
        updatedFields: Object.keys(updateData)
      });

      return result.rows[0];

    } catch (error) {
      if (error.code === '23505') {
        throw new ValidationError('Ya existe una categor√≠a con ese nombre');
      }

      logger.error('Error actualizando categor√≠a:', error);
      throw new DatabaseError('Error al actualizar categor√≠a', error);
    }
  }

  // ============================================
  // ITEMS DEL MEN√ö
  // ============================================

  /**
   * Crea un nuevo item del men√∫
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} itemData - Datos del item
   * @returns {Promise<Object>} Item creado
   */
  static async createItem(restaurantId, itemData) {
    const {
      category_id,
      name,
      description = '',
      price,
      preparation_time = 15,
      display_order = 0,
      ingredients = [],
      allergens = [],
      calories = null,
      image_url = null
    } = itemData;

    if (!category_id || !name || !price) {
      throw new ValidationError('Categor√≠a, nombre y precio son requeridos');
    }

    if (price <= 0) {
      throw new ValidationError('El precio debe ser mayor a 0');
    }

    try {
      // Verificar que la categor√≠a pertenece al restaurante
      const categoryCheck = await query(
        'SELECT id FROM menu_categories WHERE id = $1 AND restaurant_id = $2',
        [category_id, restaurantId],
        'check_category_ownership'
      );

      if (categoryCheck.rows.length === 0) {
        throw new ValidationError('La categor√≠a no pertenece a este restaurante');
      }

      const result = await query(
        `INSERT INTO menu_items (
          id, restaurant_id, category_id, name, description, price,
          preparation_time, display_order, ingredients, allergens, calories, image_url
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        RETURNING *`,
        [
          uuidv4(), restaurantId, category_id, name, description, price,
          preparation_time, display_order, ingredients, allergens, calories, image_url
        ],
        'create_menu_item'
      );

      logger.info('Item de men√∫ creado', {
        restaurantId,
        itemId: result.rows[0].id,
        name,
        price
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error creando item de men√∫:', error);
      throw new DatabaseError('Error al crear item de men√∫', error);
    }
  }

  /**
   * Obtiene el men√∫ completo de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {boolean} availableOnly - Solo items disponibles
   * @returns {Promise<Object>} Men√∫ organizado por categor√≠as
   */
  static async getFullMenu(restaurantId, availableOnly = true) {
    try {
      let itemCondition = 'mi.restaurant_id = $1';
      if (availableOnly) {
        itemCondition += ' AND mi.is_available = true AND mc.is_active = true';
      }

      const result = await query(
        `SELECT 
          mc.id as category_id,
          mc.name as category_name,
          mc.description as category_description,
          mc.emoji as category_emoji,
          mc.display_order as category_order,
          mi.id as item_id,
          mi.name as item_name,
          mi.description as item_description,
          mi.price,
          mi.preparation_time,
          mi.display_order as item_order,
          mi.ingredients,
          mi.allergens,
          mi.calories,
          mi.image_url,
          mi.is_available
        FROM menu_categories mc
        LEFT JOIN menu_items mi ON mc.id = mi.category_id AND ${itemCondition}
        WHERE mc.restaurant_id = $1
        ORDER BY mc.display_order, mc.name, mi.display_order, mi.name`,
        [restaurantId],
        'get_full_menu'
      );

      // Organizar por categor√≠as
      const menu = {};
      
      result.rows.forEach(row => {
        const categoryKey = row.category_id;
        
        if (!menu[categoryKey]) {
          menu[categoryKey] = {
            id: row.category_id,
            name: row.category_name,
            description: row.category_description,
            emoji: row.category_emoji,
            display_order: row.category_order,
            items: []
          };
        }

        if (row.item_id) {
          menu[categoryKey].items.push({
            id: row.item_id,
            name: row.item_name,
            description: row.item_description,
            price: parseFloat(row.price),
            preparation_time: row.preparation_time,
            display_order: row.item_order,
            ingredients: row.ingredients || [],
            allergens: row.allergens || [],
            calories: row.calories,
            image_url: row.image_url,
            is_available: row.is_available
          });
        }
      });

      // Convertir a array ordenado
      const menuArray = Object.values(menu).sort((a, b) => a.display_order - b.display_order);

      return {
        restaurant_id: restaurantId,
        categories: menuArray,
        total_categories: menuArray.length,
        total_items: menuArray.reduce((sum, cat) => sum + cat.items.length, 0)
      };

    } catch (error) {
      logger.error('Error obteniendo men√∫ completo:', error);
      throw new DatabaseError('Error al obtener men√∫', error);
    }
  }

  /**
   * Obtiene un item espec√≠fico del men√∫
   * @param {string} itemId - ID del item
   * @param {string} restaurantId - ID del restaurante (para verificaci√≥n)
   * @returns {Promise<Object|null>} Item del men√∫
   */
  static async getItem(itemId, restaurantId = null) {
    try {
      let whereClause = 'WHERE mi.id = $1';
      const values = [itemId];

      if (restaurantId) {
        whereClause += ' AND mi.restaurant_id = $2';
        values.push(restaurantId);
      }

      const result = await query(
        `SELECT 
          mi.*,
          mc.name as category_name,
          mc.emoji as category_emoji
        FROM menu_items mi
        JOIN menu_categories mc ON mi.category_id = mc.id
        ${whereClause}`,
        values,
        'get_menu_item'
      );

      return result.rows[0] || null;

    } catch (error) {
      logger.error('Error obteniendo item de men√∫:', error);
      throw new DatabaseError('Error al obtener item', error);
    }
  }

  /**
   * Actualiza un item del men√∫
   * @param {string} itemId - ID del item
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Item actualizado
   */
  static async updateItem(itemId, updateData) {
    const allowedFields = [
      'category_id', 'name', 'description', 'price', 'is_available',
      'preparation_time', 'display_order', 'ingredients', 'allergens',
      'calories', 'image_url'
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError('No hay campos v√°lidos para actualizar');
    }

    // Validar precio si se est√° actualizando
    if (updateData.price !== undefined && updateData.price <= 0) {
      throw new ValidationError('El precio debe ser mayor a 0');
    }

    values.push(itemId);

    try {
      const result = await query(
        `UPDATE menu_items 
         SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        'update_menu_item'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Item de men√∫');
      }

      logger.info('Item de men√∫ actualizado', {
        itemId,
        updatedFields: Object.keys(updateData)
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando item de men√∫:', error);
      throw new DatabaseError('Error al actualizar item', error);
    }
  }

  /**
   * Cambia disponibilidad de un item
   * @param {string} itemId - ID del item
   * @param {boolean} isAvailable - Nueva disponibilidad
   * @returns {Promise<boolean>} True si se actualiz√≥ correctamente
   */
  static async setItemAvailability(itemId, isAvailable) {
    try {
      const result = await query(
        'UPDATE menu_items SET is_available = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING id',
        [isAvailable, itemId],
        'set_item_availability'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Item de men√∫');
      }

      logger.info('Disponibilidad de item actualizada', {
        itemId,
        isAvailable
      });

      return true;

    } catch (error) {
      logger.error('Error actualizando disponibilidad de item:', error);
      throw new DatabaseError('Error al actualizar disponibilidad', error);
    }
  }

  /**
   * Elimina un item del men√∫ (soft delete)
   * @param {string} itemId - ID del item
   * @returns {Promise<boolean>} True si se elimin√≥ correctamente
   */
  static async deleteItem(itemId) {
    try {
      // Verificar si el item tiene pedidos asociados
      const ordersCheck = await query(
        'SELECT COUNT(*) as count FROM order_items WHERE menu_item_id = $1',
        [itemId],
        'check_item_orders'
      );

      if (parseInt(ordersCheck.rows[0].count) > 0) {
        // Si hay pedidos, solo desactivar
        return await this.setItemAvailability(itemId, false);
      }

      // Si no hay pedidos, eliminar f√≠sicamente
      const result = await query(
        'DELETE FROM menu_items WHERE id = $1 RETURNING id',
        [itemId],
        'delete_menu_item'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Item de men√∫');
      }

      logger.info('Item de men√∫ eliminado', { itemId });
      return true;

    } catch (error) {
      logger.error('Error eliminando item de men√∫:', error);
      throw new DatabaseError('Error al eliminar item', error);
    }
  }

  /**
   * Busca items en el men√∫
   * @param {string} restaurantId - ID del restaurante
   * @param {string} searchTerm - T√©rmino de b√∫squeda
   * @param {Object} filters - Filtros adicionales
   * @returns {Promise<Array>} Items encontrados
   */
  static async searchItems(restaurantId, searchTerm, filters = {}) {
    const {
      categoryId = null,
      minPrice = null,
      maxPrice = null,
      availableOnly = true
    } = filters;

    try {
      const conditions = ['mi.restaurant_id = $1'];
      const values = [restaurantId];
      let paramCount = 2;

      if (searchTerm) {
        conditions.push(`(mi.name ILIKE $${paramCount} OR mi.description ILIKE $${paramCount})`);
        values.push(`%${searchTerm}%`);
        paramCount++;
      }

      if (categoryId) {
        conditions.push(`mi.category_id = $${paramCount}`);
        values.push(categoryId);
        paramCount++;
      }

      if (minPrice !== null) {
        conditions.push(`mi.price >= $${paramCount}`);
        values.push(minPrice);
        paramCount++;
      }

      if (maxPrice !== null) {
        conditions.push(`mi.price <= $${paramCount}`);
        values.push(maxPrice);
        paramCount++;
      }

      if (availableOnly) {
        conditions.push('mi.is_available = true');
        conditions.push('mc.is_active = true');
      }

      const result = await query(
        `SELECT 
          mi.*,
          mc.name as category_name,
          mc.emoji as category_emoji
        FROM menu_items mi
        JOIN menu_categories mc ON mi.category_id = mc.id
        WHERE ${conditions.join(' AND ')}
        ORDER BY mi.name`,
        values,
        'search_menu_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error buscando items de men√∫:', error);
      throw new DatabaseError('Error al buscar items', error);
    }
  }

  /**
   * Obtiene items m√°s populares de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {number} limit - N√∫mero de items a retornar
   * @returns {Promise<Array>} Items m√°s populares
   */
  static async getPopularItems(restaurantId, limit = 10) {
    try {
      const result = await query(
        `SELECT 
          mi.*,
          mc.name as category_name,
          COUNT(oi.id) as order_count,
          SUM(oi.quantity) as total_quantity,
          COALESCE(SUM(oi.item_total), 0) as total_revenue
        FROM menu_items mi
        JOIN menu_categories mc ON mi.category_id = mc.id
        LEFT JOIN order_items oi ON mi.id = oi.menu_item_id
        WHERE mi.restaurant_id = $1 AND mi.is_available = true
        GROUP BY mi.id, mc.name
        ORDER BY order_count DESC, total_quantity DESC
        LIMIT $2`,
        [restaurantId, limit],
        'get_popular_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo items populares:', error);
      throw new DatabaseError('Error al obtener items populares', error);
    }
  }

  /**
   * Actualiza orden de display en lote
   * @param {Array} updates - Array de {id, display_order}
   * @returns {Promise<boolean>} True si se actualiz√≥ correctamente
   */
  static async updateDisplayOrder(updates) {
    if (!Array.isArray(updates) || updates.length === 0) {
      throw new ValidationError('Se requiere un array de actualizaciones');
    }

    try {
      return await transaction(async (client) => {
        for (const update of updates) {
          await client.query(
            'UPDATE menu_items SET display_order = $1 WHERE id = $2',
            [update.display_order, update.id]
          );
        }

        logger.info('Orden de display actualizado', {
          updatedCount: updates.length
        });

        return true;
      });

    } catch (error) {
      logger.error('Error actualizando orden de display:', error);
      throw new DatabaseError('Error al actualizar orden', error);
    }
  }
}

module.exports = Menu;


================================================
File: src/models/Order.js
================================================
const { query, transaction } = require('../config/database');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { ValidationError, DatabaseError, NotFoundError } = require('../middleware/errorHandler');
const { ORDER_STATUS, BUSINESS_CONFIG } = require('../utils/constants');

// ============================================
// MODELO ORDER
// ============================================

class Order {

  /**
   * Crea un nuevo pedido desde una conversaci√≥n
   * @param {Object} orderData - Datos del pedido
   * @returns {Promise<Object>} Pedido creado
   */
  static async create(orderData) {
    const {
      restaurant_id,
      customer_id = null,
      conversation_id = null,
      customer_phone,
      customer_name = null,
      delivery_street,
      delivery_number,
      delivery_neighborhood,
      delivery_references = null,
      delivery_postal_code = null,
      items = [],
      subtotal,
      delivery_fee = 0,
      total,
      estimated_delivery_time = null,
      special_instructions = null
    } = orderData;

    // Validaciones b√°sicas
    if (!restaurant_id || !customer_phone || !items || items.length === 0) {
      throw new ValidationError('Datos de pedido incompletos');
    }

    if (!delivery_street || !delivery_number || !delivery_neighborhood) {
      throw new ValidationError('Direcci√≥n de entrega incompleta');
    }

    if (subtotal <= 0 || total <= 0) {
      throw new ValidationError('Montos del pedido inv√°lidos');
    }

    try {
      return await transaction(async (client) => {
        // Crear el pedido principal
        const orderResult = await client.query(
          `INSERT INTO orders (
            id, restaurant_id, customer_id, conversation_id, customer_phone, customer_name,
            delivery_street, delivery_number, delivery_neighborhood, 
            delivery_references, delivery_postal_code,
            subtotal, delivery_fee, total, estimated_delivery_time, special_instructions
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
          RETURNING *`,
          [
            uuidv4(), restaurant_id, customer_id, conversation_id, customer_phone, customer_name,
            delivery_street, delivery_number, delivery_neighborhood,
            delivery_references, delivery_postal_code,
            subtotal, delivery_fee, total, estimated_delivery_time, special_instructions
          ]
        );

        const order = orderResult.rows[0];

        // Crear los items del pedido
        for (const item of items) {
          await client.query(
            `INSERT INTO order_items (
              id, order_id, menu_item_id, item_name, base_price, quantity,
              customizations, customizations_cost, item_total, special_notes
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
            [
              uuidv4(),
              order.id,
              item.menu_item_id,
              item.name,
              item.base_price,
              item.quantity,
              JSON.stringify(item.customizations || []),
              item.customizations_cost || 0,
              item.item_total,
              item.notes || null
            ]
          );
        }

        // Actualizar estad√≠sticas del cliente si existe
        if (customer_id) {
          await client.query(
            `UPDATE customers 
             SET total_orders = total_orders + 1,
                 total_spent = total_spent + $1,
                 last_order_at = CURRENT_TIMESTAMP
             WHERE id = $2`,
            [total, customer_id]
          );
        }

        logger.info('Pedido creado exitosamente', {
          orderId: order.id,
          restaurantId: restaurant_id,
          customerPhone: customer_phone.substring(0, 8) + '****',
          total: total,
          itemsCount: items.length
        });

        return order;
      });

    } catch (error) {
      logger.error('Error creando pedido:', error);
      throw new DatabaseError('Error al crear pedido', error);
    }
  }

  /**
   * Obtiene un pedido por ID
   * @param {string} orderId - ID del pedido
   * @param {string} restaurantId - ID del restaurante (opcional, para verificaci√≥n)
   * @returns {Promise<Object|null>} Pedido con sus items
   */
  static async findById(orderId, restaurantId = null) {
    try {
      let whereClause = 'WHERE o.id = $1';
      const values = [orderId];

      if (restaurantId) {
        whereClause += ' AND o.restaurant_id = $2';
        values.push(restaurantId);
      }

      // Obtener datos del pedido
      const orderResult = await query(
        `SELECT 
          o.*,
          r.name as restaurant_name,
          r.phone as restaurant_phone
        FROM orders o
        JOIN restaurants r ON o.restaurant_id = r.id
        ${whereClause}`,
        values,
        'find_order_by_id'
      );

      if (orderResult.rows.length === 0) {
        return null;
      }

      const order = orderResult.rows[0];

      // Obtener items del pedido
      const itemsResult = await query(
        `SELECT 
          oi.*,
          mi.description as menu_item_description,
          mi.image_url as menu_item_image
        FROM order_items oi
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE oi.order_id = $1
        ORDER BY oi.created_at`,
        [orderId],
        'get_order_items'
      );

      // Parsear customizaciones
      order.items = itemsResult.rows.map(item => ({
        ...item,
        customizations: JSON.parse(item.customizations || '[]')
      }));

      return order;

    } catch (error) {
      logger.error('Error obteniendo pedido por ID:', error);
      throw new DatabaseError('Error al obtener pedido', error);
    }
  }

  /**
   * Actualiza el estado de un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} newStatus - Nuevo estado
   * @param {Object} additionalData - Datos adicionales
   * @returns {Promise<Object>} Pedido actualizado
   */
  static async updateStatus(orderId, newStatus, additionalData = {}) {
    const validStatuses = Object.values(ORDER_STATUS);
    
    if (!validStatuses.includes(newStatus)) {
      throw new ValidationError('Estado de pedido inv√°lido');
    }

    try {
      const fields = ['status = $2'];
      const values = [orderId, newStatus];
      let paramCount = 3;

      // Agregar timestamp espec√≠fico seg√∫n el estado
      if (newStatus === ORDER_STATUS.DELIVERED) {
        fields.push(`delivered_at = CURRENT_TIMESTAMP`);
      }

      // Agregar notas internas si se proporcionan
      if (additionalData.internal_notes) {
        fields.push(`internal_notes = $${paramCount}`);
        values.push(additionalData.internal_notes);
        paramCount++;
      }

      // Agregar tiempo estimado si se proporciona
      if (additionalData.estimated_delivery_time) {
        fields.push(`estimated_delivery_time = $${paramCount}`);
        values.push(additionalData.estimated_delivery_time);
        paramCount++;
      }

      const result = await query(
        `UPDATE orders 
         SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP
         WHERE id = $1
         RETURNING *`,
        values,
        'update_order_status'
      );

      if (result.rows.length === 0) {
        throw new NotFoundError('Pedido');
      }

      logger.info('Estado de pedido actualizado', {
        orderId,
        newStatus,
        previousStatus: result.rows[0].status
      });

      return result.rows[0];

    } catch (error) {
      logger.error('Error actualizando estado de pedido:', error);
      throw new DatabaseError('Error al actualizar pedido', error);
    }
  }

  /**
   * Obtiene pedidos de un restaurante con filtros
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Lista paginada de pedidos
   */
  static async findByRestaurant(restaurantId, options = {}) {
    const {
      page = 1,
      limit = 20,
      status = null,
      customerPhone = null,
      startDate = null,
      endDate = null,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = options;

    const offset = (page - 1) * limit;
    const validSortFields = ['created_at', 'total', 'status', 'customer_name'];
    const validSortOrders = ['ASC', 'DESC'];

    if (!validSortFields.includes(sortBy)) {
      throw new ValidationError('Campo de ordenamiento inv√°lido');
    }

    if (!validSortOrders.includes(sortOrder.toUpperCase())) {
      throw new ValidationError('Orden de ordenamiento inv√°lido');
    }

    try {
      const conditions = ['o.restaurant_id = $1'];
      const values = [restaurantId];
      let paramCount = 2;

      if (status) {
        conditions.push(`o.status = $${paramCount}`);
        values.push(status);
        paramCount++;
      }

      if (customerPhone) {
        conditions.push(`o.customer_phone = $${paramCount}`);
        values.push(customerPhone);
        paramCount++;
      }

      if (startDate) {
        conditions.push(`o.created_at >= $${paramCount}`);
        values.push(startDate);
        paramCount++;
      }

      if (endDate) {
        conditions.push(`o.created_at <= $${paramCount}`);
        values.push(endDate);
        paramCount++;
      }

      const whereClause = conditions.join(' AND ');

      // Consulta principal
      const ordersResult = await query(
        `SELECT 
          o.id, o.customer_phone, o.customer_name, o.status,
          o.total, o.created_at, o.estimated_delivery_time,
          o.delivery_neighborhood,
          COUNT(oi.id) as items_count
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE ${whereClause}
        GROUP BY o.id
        ORDER BY o.${sortBy} ${sortOrder.toUpperCase()}
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        'find_orders_by_restaurant'
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM orders o WHERE ${whereClause}`,
        values.slice(0, -2),
        'count_orders_by_restaurant'
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        orders: ordersResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1
        }
      };

    } catch (error) {
      logger.error('Error obteniendo pedidos por restaurante:', error);
      throw new DatabaseError('Error al obtener pedidos', error);
    }
  }

  /**
   * Obtiene pedidos de un cliente
   * @param {string} customerPhone - Tel√©fono del cliente
   * @param {string} restaurantId - ID del restaurante (opcional)
   * @param {number} limit - L√≠mite de resultados
   * @returns {Promise<Array>} Lista de pedidos del cliente
   */
  static async findByCustomer(customerPhone, restaurantId = null, limit = 10) {
    try {
      let whereClause = 'WHERE o.customer_phone = $1';
      const values = [customerPhone];

      if (restaurantId) {
        whereClause += ' AND o.restaurant_id = $2';
        values.push(restaurantId);
        values.push(limit);
      } else {
        values.push(limit);
      }

      const result = await query(
        `SELECT 
          o.*,
          r.name as restaurant_name,
          COUNT(oi.id) as items_count
        FROM orders o
        JOIN restaurants r ON o.restaurant_id = r.id
        LEFT JOIN order_items oi ON o.id = oi.order_id
        ${whereClause}
        GROUP BY o.id, r.name
        ORDER BY o.created_at DESC
        LIMIT $${values.length}`,
        values,
        'find_orders_by_customer'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo pedidos por cliente:', error);
      throw new DatabaseError('Error al obtener pedidos del cliente', error);
    }
  }

  /**
   * Obtiene estad√≠sticas de pedidos
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas de pedidos
   */
  static async getStats(restaurantId, dateRange = {}) {
    const { startDate, endDate } = dateRange;
    
    try {
      let dateCondition = '';
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = 'AND o.created_at BETWEEN $2 AND $3';
        values.push(startDate, endDate);
      }

      const result = await query(
        `SELECT 
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as delivered_orders,
          COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_orders,
          COUNT(CASE WHEN status = 'preparing' THEN 1 END) as preparing_orders,
          COUNT(DISTINCT customer_phone) as unique_customers,
          COALESCE(SUM(total), 0) as total_revenue,
          COALESCE(AVG(total), 0) as average_order_value,
          COALESCE(SUM(delivery_fee), 0) as total_delivery_fees,
          AVG(CASE 
            WHEN delivered_at IS NOT NULL THEN 
              EXTRACT(EPOCH FROM (delivered_at - created_at))/60 
            END) as avg_delivery_time_minutes
        FROM orders o
        WHERE restaurant_id = $1 ${dateCondition}`,
        values,
        'get_order_stats'
      );

      const stats = result.rows[0];

      // Calcular tasas
      const totalOrders = parseInt(stats.total_orders);
      stats.delivery_rate = totalOrders > 0 
        ? ((parseInt(stats.delivered_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.cancellation_rate = totalOrders > 0
        ? ((parseInt(stats.cancelled_orders) / totalOrders) * 100).toFixed(2)
        : 0;

      stats.average_order_value = parseFloat(stats.average_order_value || 0).toFixed(2);
      stats.avg_delivery_time_minutes = parseFloat(stats.avg_delivery_time_minutes || 0).toFixed(2);

      return stats;

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de pedidos:', error);
      throw new DatabaseError('Error al obtener estad√≠sticas', error);
    }
  }

  /**
   * Obtiene los items m√°s vendidos
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @param {number} limit - L√≠mite de resultados
   * @returns {Promise<Array>} Items m√°s vendidos
   */
  static async getTopItems(restaurantId, dateRange = {}, limit = 10) {
    const { startDate, endDate } = dateRange;
    
    try {
      let dateCondition = '';
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = 'AND o.created_at BETWEEN $2 AND $3';
        values.push(startDate, endDate);
        values.push(limit);
      } else {
        values.push(limit);
      }

      const result = await query(
        `SELECT 
          oi.item_name,
          oi.menu_item_id,
          COUNT(*) as order_count,
          SUM(oi.quantity) as total_quantity,
          SUM(oi.item_total) as total_revenue,
          AVG(oi.base_price) as avg_price,
          mi.image_url
        FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
        WHERE o.restaurant_id = $1 AND o.status != 'cancelled' ${dateCondition}
        GROUP BY oi.menu_item_id, oi.item_name, mi.image_url
        ORDER BY total_quantity DESC, order_count DESC
        LIMIT $${values.length}`,
        values,
        'get_top_items'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo items m√°s vendidos:', error);
      throw new DatabaseError('Error al obtener items populares', error);
    }
  }

  /**
   * Obtiene pedidos activos (en preparaci√≥n/camino)
   * @param {string} restaurantId - ID del restaurante
   * @returns {Promise<Array>} Pedidos activos
   */
  static async getActiveOrders(restaurantId) {
    try {
      const result = await query(
        `SELECT 
          o.*,
          COUNT(oi.id) as items_count,
          EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - o.created_at))/60 as minutes_since_order
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE o.restaurant_id = $1 
        AND o.status IN ('confirmed', 'preparing', 'ready', 'out_for_delivery')
        GROUP BY o.id
        ORDER BY o.created_at ASC`,
        [restaurantId],
        'get_active_orders'
      );

      return result.rows;

    } catch (error) {
      logger.error('Error obteniendo pedidos activos:', error);
      throw new DatabaseError('Error al obtener pedidos activos', error);
    }
  }

  /**
   * Cancela un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} reason - Raz√≥n de cancelaci√≥n
   * @returns {Promise<Object>} Pedido cancelado
   */
  static async cancel(orderId, reason = null) {
    try {
      // Verificar que el pedido pueda ser cancelado
      const order = await this.findById(orderId);
      if (!order) {
        throw new NotFoundError('Pedido');
      }

      if (order.status === ORDER_STATUS.DELIVERED) {
        throw new ValidationError('No se puede cancelar un pedido ya entregado');
      }

      if (order.status === ORDER_STATUS.CANCELLED) {
        throw new ValidationError('El pedido ya est√° cancelado');
      }

      const result = await this.updateStatus(orderId, ORDER_STATUS.CANCELLED, {
        internal_notes: reason ? `Cancelado: ${reason}` : 'Pedido cancelado'
      });

      logger.info('Pedido cancelado', {
        orderId,
        reason,
        previousStatus: order.status
      });

      return result;

    } catch (error) {
      logger.error('Error cancelando pedido:', error);
      throw new DatabaseError('Error al cancelar pedido', error);
    }
  }

  /**
   * Calcula el tiempo estimado de entrega
   * @param {string} restaurantId - ID del restaurante
   * @param {string} neighborhood - Colonia de entrega
   * @returns {Promise<number>} Tiempo estimado en minutos
   */
  static async calculateDeliveryTime(restaurantId, neighborhood = null) {
    try {
      // Obtener configuraci√≥n base del restaurante
      const restaurantResult = await query(
        'SELECT delivery_time_min, delivery_time_max FROM restaurants WHERE id = $1',
        [restaurantId],
        'get_restaurant_delivery_times'
      );

      if (restaurantResult.rows.length === 0) {
        return 30; // Valor por defecto
      }

      const { delivery_time_min, delivery_time_max } = restaurantResult.rows[0];

      // Verificar si hay zona espec√≠fica con tiempo extra
      if (neighborhood) {
        const zoneResult = await query(
          `SELECT extra_fee FROM delivery_zones 
           WHERE restaurant_id = $1 AND $2 = ANY(neighborhoods) AND is_active = true`,
          [restaurantId, neighborhood],
          'check_delivery_zone'
        );

        // Si est√° en zona especial, agregar tiempo extra
        if (zoneResult.rows.length > 0) {
          return delivery_time_max + 10; // 10 minutos extra para zonas especiales
        }
      }

      // Calcular basado en pedidos actuales
      const activeOrdersResult = await query(
        `SELECT COUNT(*) as active_count 
         FROM orders 
         WHERE restaurant_id = $1 
         AND status IN ('confirmed', 'preparing')`,
        [restaurantId],
        'count_active_orders'
      );

      const activeCount = parseInt(activeOrdersResult.rows[0].active_count);

      // Ajustar tiempo basado en carga de trabajo
      let estimatedTime = delivery_time_min;
      if (activeCount > 5) {
        estimatedTime = delivery_time_max;
      } else if (activeCount > 2) {
        estimatedTime = Math.round((delivery_time_min + delivery_time_max) / 2);
      }

      return estimatedTime;

    } catch (error) {
      logger.error('Error calculando tiempo de entrega:', error);
      return 30; // Valor por defecto en caso de error
    }
  }

  /**
   * Obtiene el resumen de ventas por per√≠odo
   * @param {string} restaurantId - ID del restaurante
   * @param {string} period - Per√≠odo: 'today', 'week', 'month'
   * @returns {Promise<Object>} Resumen de ventas
   */
  static async getSalesSummary(restaurantId, period = 'today') {
    try {
      let dateCondition = '';
      
      switch (period) {
        case 'today':
          dateCondition = "AND DATE(created_at) = CURRENT_DATE";
          break;
        case 'week':
          dateCondition = "AND created_at >= CURRENT_DATE - INTERVAL '7 days'";
          break;
        case 'month':
          dateCondition = "AND created_at >= CURRENT_DATE - INTERVAL '30 days'";
          break;
        default:
          dateCondition = "AND DATE(created_at) = CURRENT_DATE";
      }

      const result = await query(
        `SELECT 
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status = 'delivered' THEN 1 END) as completed_orders,
          COALESCE(SUM(CASE WHEN status = 'delivered' THEN total ELSE 0 END), 0) as total_sales,
          COALESCE(AVG(CASE WHEN status = 'delivered' THEN total ELSE NULL END), 0) as avg_order_value,
          COUNT(DISTINCT customer_phone) as unique_customers
        FROM orders 
        WHERE restaurant_id = $1 ${dateCondition}`,
        [restaurantId],
        'get_sales_summary'
      );

      const summary = result.rows[0];
      summary.period = period;
      summary.completion_rate = summary.total_orders > 0 
        ? ((summary.completed_orders / summary.total_orders) * 100).toFixed(2)
        : 0;

      return summary;

    } catch (error) {
      logger.error('Error obteniendo resumen de ventas:', error);
      throw new DatabaseError('Error al obtener resumen de ventas', error);
    }
  }
}

module.exports = Order;


================================================
File: src/models/Restaurant.js
================================================
const { query, transaction } = require("../config/database");
const logger = require("../utils/logger");
const { v4: uuidv4 } = require("uuid");
const bcrypt = require("bcryptjs");
const {
  ValidationError,
  DatabaseError,
  NotFoundError,
} = require("../middleware/errorHandler");

// ============================================
// MODELO RESTAURANT
// ============================================

class Restaurant {
  /**
   * Crea un nuevo restaurante
   * @param {Object} restaurantData - Datos del restaurante
   * @returns {Promise<Object>} Restaurante creado
   */
  static async create(restaurantData) {
    const {
      name,
      slug,
      phone,
      email,
      address,
      logo_url,
      country_code = "MX", // NUEVO
      currency = "MXN", // NUEVO
      timezone = "America/Mexico_City", // NUEVO
      opens_at = "09:00:00",
      closes_at = "23:00:00",
      delivery_time_min = 25,
      delivery_time_max = 35,
      delivery_fee = 0.0,
      minimum_order = 0.0,
      whatsapp_phone_id,
      twilio_phone_number,
    } = restaurantData;

    // Validaciones b√°sicas
    if (!name || !slug || !phone) {
      throw new ValidationError("Nombre, slug y tel√©fono son requeridos");
    }

    try {
      return await transaction(async (client) => {
        // Crear restaurante
        const restaurantResult = await client.query(
          `INSERT INTO restaurants (
    id, name, slug, phone, email, address, logo_url,
    country_code, currency, timezone,
    opens_at, closes_at, delivery_time_min, delivery_time_max,
    delivery_fee, minimum_order, whatsapp_phone_id, twilio_phone_number
  ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
  RETURNING *`,
          [
            uuidv4(),
            name,
            slug,
            phone,
            email,
            address,
            logo_url,
            country_code,
            currency,
            timezone,
            opens_at,
            closes_at,
            delivery_time_min,
            delivery_time_max,
            delivery_fee,
            minimum_order,
            whatsapp_phone_id,
            twilio_phone_number,
          ]
        );

        const restaurant = restaurantResult.rows[0];

        // Crear configuraci√≥n por defecto
        await client.query(
          `INSERT INTO restaurant_settings (
            id, restaurant_id, ai_personality, welcome_message, goodbye_message, error_message
          ) VALUES ($1, $2, $3, $4, $5, $6)`,
          [
            uuidv4(),
            restaurant.id,
            "Amigable y servicial",
            `¬°Hola! üëã Bienvenido a ${name}. ¬øEn qu√© puedo ayudarte hoy?`,
            "¬°Gracias por tu pedido! üôè Te esperamos pronto.",
            "Lo siento, tuve un problema t√©cnico. ¬øPodr√≠as repetir tu mensaje?",
          ]
        );

        logger.info("Restaurante creado exitosamente", {
          restaurantId: restaurant.id,
          name: restaurant.name,
          slug: restaurant.slug,
        });

        return restaurant;
      });
    } catch (error) {
      if (error.code === "23505") {
        // unique violation
        if (error.constraint === "restaurants_slug_key") {
          throw new ValidationError("El slug ya est√° en uso");
        }
        if (error.constraint === "restaurants_phone_key") {
          throw new ValidationError("El tel√©fono ya est√° registrado");
        }
      }

      logger.error("Error creando restaurante:", error);
      throw new DatabaseError("Error al crear restaurante", error);
    }
  }

  /**
   * Obtiene un restaurante por ID
   * @param {string} id - ID del restaurante
   * @returns {Promise<Object|null>} Datos del restaurante
   */
  static async findById(id) {
    try {
      const result = await query(
        `SELECT 
          r.*,
          rs.claude_api_key,
          rs.claude_model,
          rs.ai_personality,
          rs.welcome_message,
          rs.goodbye_message,
          rs.error_message,
          rs.auto_confirm_orders,
          rs.max_conversation_time,
          rs.notification_email,
          rs.notification_phone
        FROM restaurants r
        LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
        WHERE r.id = $1`,
        [id],
        "find_restaurant_by_id"
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error("Error obteniendo restaurante por ID:", error);
      throw new DatabaseError("Error al obtener restaurante", error);
    }
  }

  /**
   * Obtiene un restaurante por slug
   * @param {string} slug - Slug del restaurante
   * @returns {Promise<Object|null>} Datos del restaurante
   */
  static async findBySlug(slug) {
    try {
      const result = await query(
        `SELECT 
          r.*,
          rs.claude_api_key,
          rs.claude_model,
          rs.ai_personality,
          rs.welcome_message,
          rs.goodbye_message,
          rs.error_message,
          rs.auto_confirm_orders,
          rs.max_conversation_time,
          rs.notification_email,
          rs.notification_phone
        FROM restaurants r
        LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
        WHERE r.slug = $1`,
        [slug],
        "find_restaurant_by_slug"
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error("Error obteniendo restaurante por slug:", error);
      throw new DatabaseError("Error al obtener restaurante", error);
    }
  }

  /**
   * Obtiene un restaurante por tel√©fono
   * @param {string} phone - Tel√©fono del restaurante
   * @returns {Promise<Object|null>} Datos del restaurante
   */
  static async findByPhone(phone) {
    try {
      const result = await query(
        `SELECT 
          r.*,
          rs.claude_api_key,
          rs.claude_model,
          rs.ai_personality,
          rs.welcome_message,
          rs.goodbye_message,
          rs.error_message
        FROM restaurants r
        LEFT JOIN restaurant_settings rs ON r.id = rs.restaurant_id
        WHERE r.phone = $1 OR r.twilio_phone_number = $1`,
        [phone],
        "find_restaurant_by_phone"
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error("Error obteniendo restaurante por tel√©fono:", error);
      throw new DatabaseError("Error al obtener restaurante", error);
    }
  }

  /**
   * Actualiza un restaurante
   * @param {string} id - ID del restaurante
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Restaurante actualizado
   */
  static async update(id, updateData) {
    const allowedFields = [
      "name",
      "phone",
      "email",
      "address",
      "logo_url",
      "is_active",
      "opens_at",
      "closes_at",
      "delivery_time_min",
      "delivery_time_max",
      "delivery_fee",
      "minimum_order",
      "whatsapp_phone_id",
      "twilio_phone_number",
      "country_code",
      "currency",
      "timezone",
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    // Construir query din√°micamente
    Object.keys(updateData).forEach((key) => {
      if (allowedFields.includes(key) && updateData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError("No hay campos v√°lidos para actualizar");
    }

    values.push(id); // ID va al final

    try {
      const result = await query(
        `UPDATE restaurants 
         SET ${fields.join(", ")}, updated_at = CURRENT_TIMESTAMP
         WHERE id = $${paramCount}
         RETURNING *`,
        values,
        "update_restaurant"
      );

      if (result.rows.length === 0) {
        throw new NotFoundError("Restaurante");
      }

      logger.info("Restaurante actualizado", {
        restaurantId: id,
        updatedFields: Object.keys(updateData),
      });

      return result.rows[0];
    } catch (error) {
      if (error.code === "23505") {
        // unique violation
        if (error.constraint === "restaurants_phone_key") {
          throw new ValidationError("El tel√©fono ya est√° registrado");
        }
      }

      logger.error("Error actualizando restaurante:", error);
      throw new DatabaseError("Error al actualizar restaurante", error);
    }
  }

  /**
   * Actualiza configuraci√≥n del restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} settingsData - Configuraci√≥n a actualizar
   * @returns {Promise<Object>} Configuraci√≥n actualizada
   */
  static async updateSettings(restaurantId, settingsData) {
    const allowedFields = [
      "claude_api_key",
      "claude_model",
      "ai_personality",
      "welcome_message",
      "goodbye_message",
      "error_message",
      "auto_confirm_orders",
      "require_phone_validation",
      "max_conversation_time",
      "notification_email",
      "notification_phone",
    ];

    const fields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(settingsData).forEach((key) => {
      if (allowedFields.includes(key) && settingsData[key] !== undefined) {
        fields.push(`${key} = $${paramCount}`);
        values.push(settingsData[key]);
        paramCount++;
      }
    });

    if (fields.length === 0) {
      throw new ValidationError("No hay campos v√°lidos para actualizar");
    }

    values.push(restaurantId);

    try {
      // Verificar si existe configuraci√≥n
      const existsResult = await query(
        "SELECT id FROM restaurant_settings WHERE restaurant_id = $1",
        [restaurantId],
        "check_restaurant_settings_exists"
      );

      let result;

      if (existsResult.rows.length > 0) {
        // Actualizar existente
        result = await query(
          `UPDATE restaurant_settings 
           SET ${fields.join(", ")}, updated_at = CURRENT_TIMESTAMP
           WHERE restaurant_id = $${paramCount}
           RETURNING *`,
          values,
          "update_restaurant_settings"
        );
      } else {
        // Crear nueva configuraci√≥n
        const insertFields = [
          "id",
          "restaurant_id",
          ...Object.keys(settingsData),
        ];
        const insertValues = [
          uuidv4(),
          restaurantId,
          ...Object.values(settingsData),
        ];
        const placeholders = insertValues.map((_, i) => `$${i + 1}`).join(", ");

        result = await query(
          `INSERT INTO restaurant_settings (${insertFields.join(", ")})
           VALUES (${placeholders})
           RETURNING *`,
          insertValues,
          "create_restaurant_settings"
        );
      }

      logger.info("Configuraci√≥n de restaurante actualizada", {
        restaurantId,
        updatedFields: Object.keys(settingsData),
      });

      return result.rows[0];
    } catch (error) {
      logger.error("Error actualizando configuraci√≥n de restaurante:", error);
      throw new DatabaseError("Error al actualizar configuraci√≥n", error);
    }
  }

  /**
   * Obtiene lista de restaurantes con paginaci√≥n
   * @param {Object} options - Opciones de consulta
   * @returns {Promise<Object>} Lista paginada de restaurantes
   */
  static async findAll(options = {}) {
    const {
      page = 1,
      limit = 10,
      search = "",
      isActive = null,
      sortBy = "created_at",
      sortOrder = "DESC",
    } = options;

    const offset = (page - 1) * limit;
    const validSortFields = ["name", "created_at", "updated_at"];
    const validSortOrders = ["ASC", "DESC"];

    if (!validSortFields.includes(sortBy)) {
      throw new ValidationError("Campo de ordenamiento inv√°lido");
    }

    if (!validSortOrders.includes(sortOrder.toUpperCase())) {
      throw new ValidationError("Orden de ordenamiento inv√°lido");
    }

    try {
      // Construir WHERE clause
      const conditions = [];
      const values = [];
      let paramCount = 1;

      if (search) {
        conditions.push(
          `(r.name ILIKE $${paramCount} OR r.slug ILIKE $${paramCount})`
        );
        values.push(`%${search}%`);
        paramCount++;
      }

      if (isActive !== null) {
        conditions.push(`r.is_active = $${paramCount}`);
        values.push(isActive);
        paramCount++;
      }

      const whereClause =
        conditions.length > 0 ? "WHERE " + conditions.join(" AND ") : "";

      // Consulta principal
      const restaurantsResult = await query(
        `SELECT 
          r.id, r.name, r.slug, r.phone, r.email, r.is_active,
          r.opens_at, r.closes_at, r.created_at, r.updated_at,
          COUNT(o.id) as total_orders,
          COALESCE(SUM(o.total), 0) as total_revenue
        FROM restaurants r
        LEFT JOIN orders o ON r.id = o.restaurant_id
        ${whereClause}
        GROUP BY r.id
        ORDER BY r.${sortBy} ${sortOrder.toUpperCase()}
        LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
        [...values, limit, offset],
        "find_all_restaurants"
      );

      // Contar total
      const countResult = await query(
        `SELECT COUNT(*) as total FROM restaurants r ${whereClause}`,
        values.slice(0, -2), // Remover limit y offset
        "count_all_restaurants"
      );

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      return {
        restaurants: restaurantsResult.rows,
        pagination: {
          current_page: page,
          total_pages: totalPages,
          total_items: total,
          items_per_page: limit,
          has_next: page < totalPages,
          has_prev: page > 1,
        },
      };
    } catch (error) {
      logger.error("Error obteniendo lista de restaurantes:", error);
      throw new DatabaseError("Error al obtener restaurantes", error);
    }
  }

  /**
   * Desactiva un restaurante (soft delete)
   * @param {string} id - ID del restaurante
   * @returns {Promise<boolean>} True si se desactiv√≥ correctamente
   */
  static async deactivate(id) {
    try {
      const result = await query(
        "UPDATE restaurants SET is_active = false, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id",
        [id],
        "deactivate_restaurant"
      );

      if (result.rows.length === 0) {
        throw new NotFoundError("Restaurante");
      }

      logger.info("Restaurante desactivado", { restaurantId: id });
      return true;
    } catch (error) {
      logger.error("Error desactivando restaurante:", error);
      throw new DatabaseError("Error al desactivar restaurante", error);
    }
  }

  /**
   * Activa un restaurante
   * @param {string} id - ID del restaurante
   * @returns {Promise<boolean>} True si se activ√≥ correctamente
   */
  static async activate(id) {
    try {
      const result = await query(
        "UPDATE restaurants SET is_active = true, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id",
        [id],
        "activate_restaurant"
      );

      if (result.rows.length === 0) {
        throw new NotFoundError("Restaurante");
      }

      logger.info("Restaurante activado", { restaurantId: id });
      return true;
    } catch (error) {
      logger.error("Error activando restaurante:", error);
      throw new DatabaseError("Error al activar restaurante", error);
    }
  }

  /**
   * Obtiene estad√≠sticas b√°sicas de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas del restaurante
   */
  static async getStats(restaurantId, dateRange = {}) {
    const { startDate, endDate } = dateRange;

    try {
      let dateCondition = "";
      const values = [restaurantId];

      if (startDate && endDate) {
        dateCondition = "AND o.created_at BETWEEN $2 AND $3";
        values.push(startDate, endDate);
      }

      const result = await query(
        `SELECT 
          COUNT(DISTINCT o.id) as total_orders,
          COUNT(DISTINCT o.customer_phone) as unique_customers,
          COALESCE(SUM(o.total), 0) as total_revenue,
          COALESCE(AVG(o.total), 0) as average_order_value,
          COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as delivered_orders,
          COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders,
          COUNT(DISTINCT c.id) as total_conversations,
          COUNT(CASE WHEN c.status = 'completed' THEN 1 END) as completed_conversations
        FROM orders o
        LEFT JOIN conversations c ON o.restaurant_id = c.restaurant_id
        WHERE o.restaurant_id = $1 ${dateCondition}`,
        values,
        "get_restaurant_stats"
      );

      const stats = result.rows[0];

      // Calcular tasas
      stats.completion_rate =
        stats.total_orders > 0
          ? ((stats.delivered_orders / stats.total_orders) * 100).toFixed(2)
          : 0;

      stats.cancellation_rate =
        stats.total_orders > 0
          ? ((stats.cancelled_orders / stats.total_orders) * 100).toFixed(2)
          : 0;

      stats.conversion_rate =
        stats.total_conversations > 0
          ? (
              (stats.completed_conversations / stats.total_conversations) *
              100
            ).toFixed(2)
          : 0;

      return stats;
    } catch (error) {
      logger.error("Error obteniendo estad√≠sticas de restaurante:", error);
      throw new DatabaseError("Error al obtener estad√≠sticas", error);
    }
  }

  /**
   * Verifica si un slug est√° disponible
   * @param {string} slug - Slug a verificar
   * @param {string} excludeId - ID a excluir de la verificaci√≥n
   * @returns {Promise<boolean>} True si est√° disponible
   */
  static async isSlugAvailable(slug, excludeId = null) {
    try {
      let queryText = "SELECT id FROM restaurants WHERE slug = $1";
      const values = [slug];

      if (excludeId) {
        queryText += " AND id != $2";
        values.push(excludeId);
      }

      const result = await query(queryText, values, "check_slug_availability");
      return result.rows.length === 0;
    } catch (error) {
      logger.error("Error verificando disponibilidad de slug:", error);
      throw new DatabaseError("Error al verificar slug", error);
    }
  }
}

module.exports = Restaurant;



================================================
File: src/models/User.js
================================================
const { query, transaction } = require('../../database/connection');
const bcrypt = require('bcryptjs');
const logger = require('../utils/logger');
const { DatabaseError, NotFoundError, AuthenticationError } = require('../middleware/errorHandler');

// ============================================
// MODELO DE USUARIO
// ============================================

class User {
  /**
   * Busca usuario por email con perfil y rol
   * @param {string} email - Email del usuario
   * @returns {Promise<Object|null>} Usuario con perfil y rol
   */
  static async findByEmailWithProfile(email) {
    try {
      const result = await query(
        `SELECT 
          u.id as user_id,
          u.email,
          u.password_hash,
          u.first_name,
          u.last_name,
          u.is_active,
          u.email_verified,
          u.last_login,
          
          up.id as profile_id,
          up.restaurant_id,
          up.phone,
          up.avatar_url,
          up.settings,
          
          r.name as role_name,
          r.display_name as role_display_name,
          r.permissions,
          
          rest.name as restaurant_name,
          rest.slug as restaurant_slug
          
        FROM users u
        INNER JOIN user_profiles up ON u.id = up.user_id
        INNER JOIN roles r ON up.role_id = r.id
        LEFT JOIN restaurants rest ON up.restaurant_id = rest.id
        WHERE u.email = $1 AND u.is_active = true`,
        [email],
        'find_user_by_email_with_profile'
      );

      if (result.rows.length === 0) {
        return null;
      }

      const userData = result.rows[0];

      return {
        id: userData.user_id,
        email: userData.email,
        password_hash: userData.password_hash,
        first_name: userData.first_name,
        last_name: userData.last_name,
        is_active: userData.is_active,
        email_verified: userData.email_verified,
        last_login: userData.last_login,
        profile: {
          id: userData.profile_id,
          restaurant_id: userData.restaurant_id,
          phone: userData.phone,
          avatar_url: userData.avatar_url,
          settings: userData.settings,
          role: {
            name: userData.role_name,
            display_name: userData.role_display_name,
            permissions: userData.permissions
          },
          restaurant: userData.restaurant_name ? {
            name: userData.restaurant_name,
            slug: userData.restaurant_slug
          } : null
        }
      };

    } catch (error) {
      logger.error('Error buscando usuario por email:', error);
      throw new DatabaseError('Error al buscar usuario', error);
    }
  }

  /**
   * Actualiza √∫ltimo login del usuario
   * @param {string} userId - ID del usuario
   * @returns {Promise<void>}
   */
  static async updateLastLogin(userId) {
    try {
      await query(
        'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1',
        [userId],
        'update_last_login'
      );

      logger.debug('√öltimo login actualizado', { userId });

    } catch (error) {
      logger.error('Error actualizando √∫ltimo login:', error);
      // No lanzamos error para no interrumpir el login
    }
  }

  /**
   * Verifica contrase√±a
   * @param {string} plainPassword - Contrase√±a en texto plano
   * @param {string} hashedPassword - Contrase√±a hasheada
   * @returns {Promise<boolean>} True si la contrase√±a es correcta
   */
  static async verifyPassword(plainPassword, hashedPassword) {
    try {
      return await bcrypt.compare(plainPassword, hashedPassword);
    } catch (error) {
      logger.error('Error verificando contrase√±a:', error);
      return false;
    }
  }
}

module.exports = User;


================================================
File: src/routes/auth.js
================================================
const express = require('express');
const AuthController = require('../controllers/authController');
const AuthMiddleware = require('../middleware/auth');
const logger = require('../utils/logger');

const router = express.Router();

// ============================================
// RUTAS P√öBLICAS DE AUTENTICACI√ìN
// ============================================

/**
 * Login de usuario
 * URL: POST /api/auth/login
 * Body: { email, password }
 */
router.post('/login', AuthController.login);

/**
 * Refresh token
 * URL: POST /api/auth/refresh
 * Body: { refresh_token }
 */
router.post('/refresh', AuthMiddleware.refreshToken, AuthController.refreshToken);

// ============================================
// RUTAS PROTEGIDAS
// ============================================

/**
 * Obtiene informaci√≥n del usuario actual
 * URL: GET /api/auth/me
 * Headers: Authorization: Bearer <token>
 */
router.get('/me', 
  AuthMiddleware.authenticateToken, 
  AuthController.getCurrentUser
);

/**
 * Logout (invalidar token - opcional)
 * URL: POST /api/auth/logout
 */
router.post('/logout', 
  AuthMiddleware.authenticateToken, 
  (req, res) => {
    // En una implementaci√≥n real, aqu√≠ invalidar√≠as el token en una blacklist
    logger.info('Usuario cerr√≥ sesi√≥n', { userId: req.user.id });
    
    res.json({
      success: true,
      message: 'Sesi√≥n cerrada exitosamente'
    });
  }
);

module.exports = router;


================================================
File: src/routes/dashboard.js
================================================
const express = require('express');
const ConversationController = require('../controllers/conversationController');
const RestaurantController = require('../controllers/restaurantController');
const OrderController = require('../controllers/orderController');
const MenuController = require('../controllers/menuController');
const WhatsAppService = require('../services/whatsappService');
const ClaudeService = require('../services/claudeService');
const AuthMiddleware = require('../middleware/auth');
const { dashboardTenantResolver } = require('../middleware/tenantResolver');
const { asyncHandler } = require('../middleware/errorHandler');
const logger = require('../utils/logger');

const router = express.Router();

// ============================================
// TODAS LAS RUTAS REQUIEREN AUTENTICACI√ìN
// ============================================

router.use(AuthMiddleware.authenticateToken);
router.use(dashboardTenantResolver);

// ============================================
// RESUMEN GENERAL DEL DASHBOARD
// ============================================

/**
 * Obtiene resumen completo del dashboard
 * URL: GET /api/dashboard
 */
router.get('/', 
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant.id;

      // Obtener datos en paralelo para mejor rendimiento
      const [
        restaurantSummary,
        ordersSummary,
        menuSummary,
        conversationStats
      ] = await Promise.all([
        RestaurantController.getDashboardSummary(req, { json: () => {} }),
        OrderController.getOrdersSummary(req, { json: () => {} }),
        MenuController.getMenuSummary(req, { json: () => {} }),
        ConversationController.getConversationStatistics(req, { json: () => {} })
      ]);

      const dashboardData = {
        restaurant: req.restaurant,
        summary: {
          orders: ordersSummary?.data || {},
          menu: menuSummary?.data || {},
          conversations: conversationStats?.data || {}
        },
        last_updated: new Date().toISOString()
      };

      logger.info('Resumen de dashboard obtenido', {
        restaurantId,
        userId: req.user.id
      });

      res.json({
        success: true,
        data: dashboardData
      });

    } catch (error) {
      logger.error('Error obteniendo resumen de dashboard:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo resumen del dashboard'
      });
    }
  })
);

// ============================================
// GESTI√ìN DE CONVERSACIONES
// ============================================

/**
 * Obtiene conversaciones del restaurante
 * URL: GET /api/dashboard/conversations
 */
router.get('/conversations',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversations
);

/**
 * Obtiene una conversaci√≥n espec√≠fica
 * URL: GET /api/dashboard/conversations/:conversationId
 */
router.get('/conversations/:conversationId',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversationById
);

/**
 * Obtiene conversaci√≥n activa de un cliente
 * URL: GET /api/dashboard/conversations/customer/:customerPhone
 */
router.get('/conversations/customer/:customerPhone',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getActiveConversation
);

/**
 * Obtiene estado de conversaci√≥n de un cliente
 * URL: GET /api/dashboard/conversations/customer/:customerPhone/status
 */
router.get('/conversations/customer/:customerPhone/status',
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversationStatus
);

/**
 * Inicia una nueva conversaci√≥n
 * URL: POST /api/dashboard/conversations
 */
router.post('/conversations',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.startConversation
);

/**
 * Reinicia una conversaci√≥n
 * URL: POST /api/dashboard/conversations/customer/:customerPhone/restart
 */
router.post('/conversations/customer/:customerPhone/restart',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.restartConversation
);

/**
 * Actualiza una conversaci√≥n
 * URL: PUT /api/dashboard/conversations/:conversationId
 */
router.put('/conversations/:conversationId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.updateConversation
);

/**
 * Marca conversaci√≥n como abandonada
 * URL: POST /api/dashboard/conversations/:conversationId/abandon
 */
router.post('/conversations/:conversationId/abandon',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.abandonConversation
);

/**
 * Env√≠a mensaje manual en conversaci√≥n
 * URL: POST /api/dashboard/conversations/:conversationId/send
 */
router.post('/conversations/:conversationId/send',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.sendManualMessage
);

/**
 * Obtiene estad√≠sticas de conversaciones
 * URL: GET /api/dashboard/conversations/statistics
 */
router.get('/conversations/statistics',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.getConversationStatistics
);

/**
 * Limpia conversaciones inactivas
 * URL: POST /api/dashboard/conversations/cleanup
 */
router.post('/conversations/cleanup',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.cleanupInactiveConversations
);

/**
 * Exporta conversaciones
 * URL: GET /api/dashboard/conversations/export
 */
router.get('/conversations/export',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  ConversationController.exportConversations
);

// ============================================
// M√âTRICAS Y ESTAD√çSTICAS
// ============================================

/**
 * Obtiene m√©tricas en tiempo real
 * URL: GET /api/dashboard/metrics/realtime
 */
router.get('/metrics/realtime',
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant.id;

      // Obtener m√©tricas en tiempo real
      const [activeOrders, recentConversations] = await Promise.all([
        OrderController.getActiveOrders(req, { json: () => {} }),
        ConversationController.getConversations(req, { 
          query: { limit: 5, status: 'active' }, 
          json: () => {} 
        })
      ]);

      const metrics = {
        active_orders: activeOrders?.data?.summary || { total: 0, delayed: 0, urgent: 0 },
        active_conversations: recentConversations?.data?.length || 0,
        restaurant_status: req.restaurant.is_active ? 'active' : 'inactive',
        last_updated: new Date().toISOString()
      };

      res.json({
        success: true,
        data: metrics
      });

    } catch (error) {
      logger.error('Error obteniendo m√©tricas en tiempo real:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo m√©tricas'
      });
    }
  })
);

/**
 * Obtiene m√©tricas de rendimiento
 * URL: GET /api/dashboard/metrics/performance
 */
router.get('/metrics/performance',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const restaurantId = req.restaurant.id;

      // Obtener estad√≠sticas de rendimiento
      const [orderStats, conversationStats] = await Promise.all([
        OrderController.getOrderStatistics(req, { json: () => {} }),
        ConversationController.getConversationStatistics(req, { json: () => {} })
      ]);

      const performance = {
        order_stats: orderStats?.data?.basic || {},
        conversation_stats: conversationStats?.data || {},
        generated_at: new Date().toISOString()
      };

      res.json({
        success: true,
        data: performance
      });

    } catch (error) {
      logger.error('Error obteniendo m√©tricas de rendimiento:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo m√©tricas de rendimiento'
      });
    }
  })
);

// ============================================
// CONFIGURACI√ìN Y AJUSTES
// ============================================

/**
 * Obtiene configuraci√≥n actual del restaurante
 * URL: GET /api/dashboard/settings
 */
router.get('/settings',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.getCurrentRestaurant
);

/**
 * Actualiza configuraci√≥n del restaurante
 * URL: PUT /api/dashboard/settings
 */
router.put('/settings',
  AuthMiddleware.requireRole(['admin']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.updateCurrentRestaurant
);

/**
 * Actualiza configuraci√≥n avanzada
 * URL: PUT /api/dashboard/settings/advanced
 */
router.put('/settings/advanced',
  AuthMiddleware.requireRole(['admin']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      // Reutilizar l√≥gica del controlador de restaurantes
      req.params.id = req.restaurant.id;
      return RestaurantController.updateRestaurantSettings(req, res);

    } catch (error) {
      logger.error('Error actualizando configuraci√≥n avanzada:', error);
      res.status(500).json({
        success: false,
        error: 'Error actualizando configuraci√≥n'
      });
    }
  })
);

// ============================================
// HERRAMIENTAS DE DIAGN√ìSTICO
// ============================================

/**
 * Verifica estado de servicios externos
 * URL: GET /api/dashboard/health/services
 */
router.get('/health/services',
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      // Verificar estado de servicios
      const [whatsappStatus, claudeStatus] = await Promise.all([
        WhatsAppService.checkServicesStatus(),
        // ClaudeService.testClaudeConnection() // Implementar si es necesario
        Promise.resolve({ available: true }) // Placeholder
      ]);

      const servicesHealth = {
        whatsapp: {
          status: whatsappStatus.healthy ? 'healthy' : 'unhealthy',
          active_provider: whatsappStatus.activeProvider,
          details: whatsappStatus
        },
        claude: {
          status: claudeStatus.available ? 'healthy' : 'unhealthy',
          details: claudeStatus
        },
        database: {
          status: 'healthy' // Si llegamos aqu√≠, la BD est√° funcionando
        },
        last_checked: new Date().toISOString()
      };

      res.json({
        success: true,
        data: servicesHealth
      });

    } catch (error) {
      logger.error('Error verificando estado de servicios:', error);
      res.status(500).json({
        success: false,
        error: 'Error verificando servicios'
      });
    }
  })
);

/**
 * Prueba de conexi√≥n con WhatsApp
 * URL: POST /api/dashboard/test/whatsapp
 */
router.post('/test/whatsapp',
  AuthMiddleware.requireRole(['admin']),
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const { phone_number, test_message = 'üß™ Mensaje de prueba desde ChatBot Ching√≥n' } = req.body;

      if (!phone_number) {
        return res.status(400).json({
          success: false,
          error: 'N√∫mero de tel√©fono requerido para la prueba'
        });
      }

      // Enviar mensaje de prueba
      const result = await WhatsAppService.sendMessage(phone_number, test_message);

      logger.info('Prueba de WhatsApp ejecutada', {
        restaurantId: req.restaurant.id,
        phoneNumber: phone_number.substring(0, 8) + '****',
        success: result.success,
        userId: req.user.id
      });

      res.json({
        success: true,
        message: 'Mensaje de prueba enviado',
        data: {
          phone_number: phone_number,
          message_sent: test_message,
          provider_result: result
        }
      });

    } catch (error) {
      logger.error('Error en prueba de WhatsApp:', error);
      res.status(500).json({
        success: false,
        error: 'Error enviando mensaje de prueba'
      });
    }
  })
);

// ============================================
// ACTIVIDAD Y LOGS
// ============================================

/**
 * Obtiene actividad reciente
 * URL: GET /api/dashboard/activity
 */
router.get('/activity',
  AuthMiddleware.requireRestaurantAccess,
  asyncHandler(async (req, res) => {
    try {
      const { limit = 20 } = req.query;
      const limitNumber = Math.min(parseInt(limit), 100);

      // Obtener actividad reciente (combinando pedidos y conversaciones)
      const [recentOrders, recentConversations] = await Promise.all([
        OrderController.getOrders(req, { 
          query: { limit: limitNumber / 2, sort_by: 'created_at', sort_order: 'DESC' }, 
          json: () => {} 
        }),
        ConversationController.getConversations(req, { 
          query: { limit: limitNumber / 2, sort_by: 'last_interaction_at', sort_order: 'DESC' }, 
          json: () => {} 
        })
      ]);

      // Combinar y ordenar actividad
      const activity = [];

      // Agregar pedidos a la actividad
      if (recentOrders?.data) {
        recentOrders.data.forEach(order => {
          activity.push({
            type: 'order',
            id: order.id,
            title: `Pedido ${order.id.substring(0, 8)}`,
            description: `Total: $${order.total} - Estado: ${order.status}`,
            timestamp: order.created_at,
            customer_phone: order.customer_phone?.substring(0, 8) + '****'
          });
        });
      }

      // Agregar conversaciones a la actividad
      if (recentConversations?.data) {
        recentConversations.data.forEach(conv => {
          activity.push({
            type: 'conversation',
            id: conv.id,
            title: `Conversaci√≥n ${conv.id.substring(0, 8)}`,
            description: `Estado: ${conv.status} - Paso: ${conv.current_step}`,
            timestamp: conv.last_interaction_at,
            customer_phone: conv.customer_phone?.substring(0, 8) + '****'
          });
        });
      }

      // Ordenar por timestamp descendente
      activity.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

      res.json({
        success: true,
        data: {
          activity: activity.slice(0, limitNumber),
          total_items: activity.length
        }
      });

    } catch (error) {
      logger.error('Error obteniendo actividad:', error);
      res.status(500).json({
        success: false,
        error: 'Error obteniendo actividad'
      });
    }
  })
);

module.exports = router;


================================================
File: src/routes/menu.js
================================================
const express = require('express');
const MenuController = require('../controllers/menuController');
const AuthMiddleware = require('../middleware/auth');
const { apiTenantResolver, dashboardTenantResolver } = require('../middleware/tenantResolver');

const router = express.Router();

// ============================================
// RUTAS P√öBLICAS DEL MEN√ö
// ============================================

/**
 * Obtiene el men√∫ completo de un restaurante (p√∫blico)
 * URL: GET /api/menu/restaurant/:restaurantId
 */
router.get('/restaurant/:restaurantId',
  MenuController.getFullMenu
);

/**
 * Obtiene un item espec√≠fico del men√∫ (p√∫blico)
 * URL: GET /api/menu/item/:itemId
 */
router.get('/item/:itemId',
  MenuController.getMenuItem
);

/**
 * Busca items en el men√∫ de un restaurante (p√∫blico)
 * URL: GET /api/menu/restaurant/:restaurantId/search
 */
router.get('/restaurant/:restaurantId/search',
  MenuController.searchMenuItems
);

/**
 * Obtiene items populares de un restaurante (p√∫blico)
 * URL: GET /api/menu/restaurant/:restaurantId/popular
 */
router.get('/restaurant/:restaurantId/popular',
  MenuController.getPopularItems
);

// ============================================
// RUTAS ADMINISTRATIVAS (REQUIEREN AUTENTICACI√ìN)
// ============================================

// Middleware de autenticaci√≥n para rutas administrativas
router.use(AuthMiddleware.authenticateToken);

// ============================================
// GESTI√ìN DE CATEGOR√çAS
// ============================================

/**
 * Obtiene categor√≠as del restaurante actual
 * URL: GET /api/menu/categories
 */
router.get('/categories',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getCategories
);

/**
 * Crea una nueva categor√≠a
 * URL: POST /api/menu/categories
 */
router.post('/categories',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  MenuController.createCategory
);

/**
 * Actualiza una categor√≠a
 * URL: PUT /api/menu/categories/:categoryId
 */
router.put('/categories/:categoryId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.updateCategory
);

// ============================================
// GESTI√ìN DE ITEMS DEL MEN√ö
// ============================================

/**
 * Obtiene el men√∫ completo del restaurante actual
 * URL: GET /api/menu
 */
router.get('/',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getFullMenu
);

/**
 * Obtiene resumen del men√∫ del restaurante actual
 * URL: GET /api/menu/summary
 */
router.get('/summary',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getMenuSummary
);

/**
 * Busca items en el men√∫ del restaurante actual
 * URL: GET /api/menu/search
 */
router.get('/search',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.searchMenuItems
);

/**
 * Obtiene items populares del restaurante actual
 * URL: GET /api/menu/popular
 */
router.get('/popular',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getPopularItems
);

/**
 * Crea un nuevo item del men√∫
 * URL: POST /api/menu/items
 */
router.post('/items',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  MenuController.createMenuItem
);

/**
 * Obtiene un item espec√≠fico del men√∫ del restaurante actual
 * URL: GET /api/menu/items/:itemId
 */
router.get('/items/:itemId',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  MenuController.getMenuItem
);

/**
 * Actualiza un item del men√∫
 * URL: PUT /api/menu/items/:itemId
 */
router.put('/items/:itemId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.updateMenuItem
);

/**
 * Cambia disponibilidad de un item
 * URL: PATCH /api/menu/items/:itemId/availability
 */
router.patch('/items/:itemId/availability',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  MenuController.toggleItemAvailability
);

/**
 * Elimina un item del men√∫
 * URL: DELETE /api/menu/items/:itemId
 */
router.delete('/items/:itemId',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.deleteMenuItem
);

// ============================================
// OPERACIONES EN LOTE
// ============================================

/**
 * Actualiza orden de display de items
 * URL: PUT /api/menu/items/display-order
 */
router.put('/items/display-order',
  AuthMiddleware.requireRole(['admin', 'manager']),
  MenuController.updateDisplayOrder
);

/**
 * Actualizaci√≥n en lote de disponibilidad
 * URL: PATCH /api/menu/items/batch-availability
 */
router.patch('/items/batch-availability',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  MenuController.batchUpdateAvailability
);

// ============================================
// RUTAS ESPEC√çFICAS POR RESTAURANTE (PARA SUPER ADMIN)
// ============================================

/**
 * Obtiene categor√≠as de un restaurante espec√≠fico
 * URL: GET /api/menu/restaurant/:restaurantId/categories
 */
router.get('/restaurant/:restaurantId/categories',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.getCategories
);

/**
 * Crea categor√≠a en un restaurante espec√≠fico
 * URL: POST /api/menu/restaurant/:restaurantId/categories
 */
router.post('/restaurant/:restaurantId/categories',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.createCategory
);

/**
 * Crea item en un restaurante espec√≠fico
 * URL: POST /api/menu/restaurant/:restaurantId/items
 */
router.post('/restaurant/:restaurantId/items',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.createMenuItem
);

/**
 * Obtiene resumen del men√∫ de un restaurante espec√≠fico
 * URL: GET /api/menu/restaurant/:restaurantId/summary
 */
router.get('/restaurant/:restaurantId/summary',
  AuthMiddleware.requireRole('super_admin'),
  MenuController.getMenuSummary
);

module.exports = router;


================================================
File: src/routes/orders.js
================================================
const express = require('express');
const OrderController = require('../controllers/orderController');
const AuthMiddleware = require('../middleware/auth');
const { dashboardTenantResolver } = require('../middleware/tenantResolver');

const router = express.Router();

// ============================================
// TODAS LAS RUTAS REQUIEREN AUTENTICACI√ìN
// ============================================

router.use(AuthMiddleware.authenticateToken);

// ============================================
// RUTAS DEL RESTAURANTE ACTUAL
// ============================================

/**
 * Obtiene pedidos del restaurante actual
 * URL: GET /api/orders
 */
router.get('/',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrders
);

/**
 * Obtiene resumen de pedidos del restaurante actual
 * URL: GET /api/orders/summary
 */
router.get('/summary',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrdersSummary
);

/**
 * Obtiene pedidos activos del restaurante actual
 * URL: GET /api/orders/active
 */
router.get('/active',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getActiveOrders
);

/**
 * Busca pedidos del restaurante actual
 * URL: GET /api/orders/search
 */
router.get('/search',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.searchOrders
);

/**
 * Obtiene estad√≠sticas de pedidos del restaurante actual
 * URL: GET /api/orders/statistics
 */
router.get('/statistics',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrderStatistics
);

/**
 * Genera reporte de ventas del restaurante actual
 * URL: GET /api/orders/reports/sales
 */
router.get('/reports/sales',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.generateSalesReport
);

/**
 * Crea un nuevo pedido manual
 * URL: POST /api/orders
 */
router.post('/',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.createOrder
);

/**
 * Actualizaci√≥n en lote de pedidos
 * URL: PATCH /api/orders/batch
 */
router.patch('/batch',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  OrderController.batchUpdateOrders
);

// ============================================
// RUTAS DE PEDIDOS ESPEC√çFICOS
// ============================================

/**
 * Obtiene un pedido espec√≠fico
 * URL: GET /api/orders/:orderId
 */
router.get('/:orderId',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getOrderById
);

/**
 * Actualiza el estado de un pedido
 * URL: PATCH /api/orders/:orderId/status
 */
router.patch('/:orderId/status',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  OrderController.updateOrderStatus
);

/**
 * Cancela un pedido
 * URL: POST /api/orders/:orderId/cancel
 */
router.post('/:orderId/cancel',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  OrderController.cancelOrder
);

/**
 * Valida si un pedido puede ser modificado
 * URL: GET /api/orders/:orderId/validate-modification
 */
router.get('/:orderId/validate-modification',
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  OrderController.validateOrderModification
);

// ============================================
// RUTAS POR CLIENTE
// ============================================

/**
 * Obtiene pedidos de un cliente espec√≠fico
 * URL: GET /api/orders/customer/:customerPhone
 */
router.get('/customer/:customerPhone',
  dashboardTenantResolver,
  AuthMiddleware.requireRestaurantAccess,
  OrderController.getCustomerOrders
);

// ============================================
// RUTAS ESPEC√çFICAS POR RESTAURANTE (PARA SUPER ADMIN)
// ============================================

/**
 * Obtiene pedidos de un restaurante espec√≠fico
 * URL: GET /api/orders/restaurant/:restaurantId
 */
router.get('/restaurant/:restaurantId',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getOrders
);

/**
 * Obtiene pedidos activos de un restaurante espec√≠fico
 * URL: GET /api/orders/restaurant/:restaurantId/active
 */
router.get('/restaurant/:restaurantId/active',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getActiveOrders
);

/**
 * Obtiene estad√≠sticas de un restaurante espec√≠fico
 * URL: GET /api/orders/restaurant/:restaurantId/statistics
 */
router.get('/restaurant/:restaurantId/statistics',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getOrderStatistics
);

/**
 * Genera reporte de ventas de un restaurante espec√≠fico
 * URL: GET /api/orders/restaurant/:restaurantId/reports/sales
 */
router.get('/restaurant/:restaurantId/reports/sales',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.generateSalesReport
);

/**
 * Busca pedidos en un restaurante espec√≠fico
 * URL: GET /api/orders/restaurant/:restaurantId/search
 */
router.get('/restaurant/:restaurantId/search',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.searchOrders
);

/**
 * Obtiene resumen de pedidos de un restaurante espec√≠fico
 * URL: GET /api/orders/restaurant/:restaurantId/summary
 */
router.get('/restaurant/:restaurantId/summary',
  AuthMiddleware.requireRole('super_admin'),
  OrderController.getOrdersSummary
);

module.exports = router;


================================================
File: src/routes/restaurants.js
================================================
const express = require('express');
const RestaurantController = require('../controllers/restaurantController');
const AuthMiddleware = require('../middleware/auth');
const { apiTenantResolver, dashboardTenantResolver } = require('../middleware/tenantResolver');

const router = express.Router();

// ============================================
// RUTAS P√öBLICAS
// ============================================

/**
 * Obtiene un restaurante por slug
 * URL: GET /api/restaurants/slug/:slug
 */
router.get('/slug/:slug',
  RestaurantController.getRestaurantBySlug
);

/**
 * Verifica disponibilidad de slug
 * URL: GET /api/restaurants/check-slug/:slug
 */
router.get('/check-slug/:slug',
  RestaurantController.checkSlugAvailability
);

// ============================================
// RUTAS ADMINISTRATIVAS (REQUIEREN AUTENTICACI√ìN)
// ============================================

// Middleware de autenticaci√≥n para rutas administrativas
router.use(AuthMiddleware.authenticateToken);

/**
 * Obtiene lista de restaurantes (solo super admin)
 * URL: GET /api/restaurants
 */
router.get('/',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.getAllRestaurants
);

/**
 * Crea un nuevo restaurante (solo super admin)
 * URL: POST /api/restaurants
 */
router.post('/',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.createRestaurant
);

/**
 * Obtiene un restaurante por ID (super admin o propietario)
 * URL: GET /api/restaurants/:id
 */
router.get('/:id',
  AuthMiddleware.requireRole(['super_admin', 'admin', 'manager']),
  RestaurantController.getRestaurantById
);

/**
 * Actualiza un restaurante (super admin o propietario)
 * URL: PUT /api/restaurants/:id
 */
router.put('/:id',
  AuthMiddleware.requireRole(['super_admin', 'admin']),
  RestaurantController.updateRestaurant
);

/**
 * Actualiza configuraci√≥n de un restaurante
 * URL: PUT /api/restaurants/:id/settings
 */
router.put('/:id/settings',
  AuthMiddleware.requireRole(['super_admin', 'admin']),
  RestaurantController.updateRestaurantSettings
);

/**
 * Obtiene estad√≠sticas de un restaurante
 * URL: GET /api/restaurants/:id/stats
 */
router.get('/:id/stats',
  AuthMiddleware.requireRole(['super_admin', 'admin', 'manager']),
  RestaurantController.getRestaurantStats
);

/**
 * Activa un restaurante (solo super admin)
 * URL: POST /api/restaurants/:id/activate
 */
router.post('/:id/activate',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.activateRestaurant
);

/**
 * Desactiva un restaurante (solo super admin)
 * URL: POST /api/restaurants/:id/deactivate
 */
router.post('/:id/deactivate',
  AuthMiddleware.requireRole('super_admin'),
  RestaurantController.deactivateRestaurant
);

// ============================================
// RUTAS DEL RESTAURANTE ACTUAL
// ============================================

/**
 * Obtiene el restaurante actual (basado en el token/tenant)
 * URL: GET /api/restaurants/current
 */
router.get('/current',
  dashboardTenantResolver,
  RestaurantController.getCurrentRestaurant
);

/**
 * Actualiza el restaurante actual
 * URL: PUT /api/restaurants/current
 */
router.put('/current',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.updateCurrentRestaurant
);

/**
 * Obtiene estad√≠sticas del restaurante actual
 * URL: GET /api/restaurants/current/stats
 */
router.get('/current/stats',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.getCurrentRestaurantStats
);

/**
 * Obtiene resumen del dashboard del restaurante actual
 * URL: GET /api/restaurants/current/dashboard
 */
router.get('/current/dashboard',
  dashboardTenantResolver,
  AuthMiddleware.requireRole(['admin', 'manager', 'staff']),
  AuthMiddleware.requireRestaurantAccess,
  RestaurantController.getDashboardSummary
);

module.exports = router;


================================================
File: src/routes/webhook.js
================================================
const express = require('express');
const WebhookController = require('../controllers/webhookController');
const { webhookTenantResolver } = require('../middleware/tenantResolver');
const { webhookLimiter } = require('../middleware/rateLimiter');

const router = express.Router();

// ============================================
// RUTAS DE WEBHOOKS
// ============================================

// Aplicar rate limiting espec√≠fico para webhooks
router.use(webhookLimiter);

// ============================================
// WEBHOOKS DE WHATSAPP
// ============================================

/**
 * Webhook gen√©rico de WhatsApp
 * Maneja tanto Twilio como Meta WhatsApp
 * URL: /webhook/:restaurantSlug
 */
router.all('/:restaurantSlug', 
  webhookTenantResolver,
  WebhookController.handleWhatsAppWebhook
);

/**
 * Webhook espec√≠fico de Twilio
 * URL: /webhook/twilio/:restaurantSlug
 */
router.post('/twilio/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.handleTwilioWebhook
);

/**
 * Webhook espec√≠fico de Meta WhatsApp
 * Maneja tanto GET (verificaci√≥n) como POST (mensajes)
 * URL: /webhook/meta/:restaurantSlug
 */
router.all('/meta/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.handleMetaWebhook
);

// ============================================
// WEBHOOKS DE PRUEBA Y DESARROLLO
// ============================================

/**
 * Webhook de prueba para desarrollo
 * URL: /webhook/test/:restaurantSlug
 */
router.post('/test/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.handleTestWebhook
);

// ============================================
// OPERACIONES DE GESTI√ìN
// ============================================

/**
 * Reinicia una conversaci√≥n espec√≠fica
 * URL: POST /webhook/restart/:restaurantSlug
 */
router.post('/restart/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.restartConversation
);

/**
 * Env√≠a mensaje manual desde el dashboard
 * URL: POST /webhook/send/:restaurantSlug
 */
router.post('/send/:restaurantSlug',
  webhookTenantResolver,
  WebhookController.sendManualMessage
);

// ============================================
// ESTAD√çSTICAS Y MONITOREO
// ============================================

/**
 * Obtiene estad√≠sticas de webhooks
 * URL: GET /webhook/stats
 */
router.get('/stats',
  WebhookController.getWebhookStats
);

module.exports = router;


================================================
File: src/services/claudeService.js
================================================
const { getClaude3Response, buildContext } = require('../config/claude');
const logger = require('../utils/logger');
const { CONVERSATION_STEPS, DEFAULT_MESSAGES } = require('../utils/constants');
const Menu = require('../models/Menu');
const { query } = require('../config/database');

// ============================================
// SERVICIO CLAUDE AI
// ============================================

class ClaudeService {

  /**
   * Procesa un mensaje del usuario con Claude AI
   * @param {Object} params - Par√°metros del procesamiento
   * @returns {Promise<Object>} Respuesta procesada
   */
  static async processMessage(params) {
    const {
      restaurant,
      conversation,
      userMessage,
      customerData = null
    } = params;

    try {
      // Preparar datos del contexto
      const contextData = await this.prepareContextData(restaurant, conversation, customerData);
      
      // Llamar a Claude
      const claudeResponse = await getClaude3Response(
        contextData,
        userMessage,
        {
          model: restaurant.claude_model,
          temperature: 0.7,
          maxTokens: 500
        }
      );

      // Analizar la respuesta para detectar intenciones
      const analysis = await this.analyzeResponse(claudeResponse.response, conversation);

      return {
        success: true,
        response: claudeResponse.response,
        analysis,
        usage: claudeResponse.usage,
        model: claudeResponse.model,
        duration: claudeResponse.duration
      };

    } catch (error) {
      logger.error('Error procesando mensaje con Claude:', error);
      
      // Retornar respuesta de fallback
      return {
        success: false,
        response: restaurant.error_message || DEFAULT_MESSAGES.ERROR,
        analysis: {
          intent: 'error',
          confidence: 0,
          next_step: conversation.current_step
        },
        error: error.message
      };
    }
  }

  /**
   * Prepara los datos de contexto para Claude
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} conversation - Conversaci√≥n actual
   * @param {Object} customerData - Datos del cliente
   * @returns {Promise<Object>} Datos de contexto preparados
   */
  static async prepareContextData(restaurant, conversation, customerData = null) {
    try {
      // Obtener men√∫ completo si no est√° en los datos del restaurante
      if (!restaurant.menu) {
        const menuData = await Menu.getFullMenu(restaurant.id, true);
        restaurant.menu = this.flattenMenuForContext(menuData.categories);
      }

      // Obtener reglas de negocio si no est√°n incluidas
      if (!restaurant.business_rules) {
        const rulesResult = await query(
          'SELECT * FROM business_rules WHERE restaurant_id = $1 AND is_active = true',
          [restaurant.id],
          'get_business_rules_for_context'
        );
        restaurant.business_rules = rulesResult.rows;
      }

      // Parsear datos de la conversaci√≥n
      let orderState = null;
      let conversationHistory = [];

      try {
        orderState = JSON.parse(conversation.order_data || '{}');
        conversationHistory = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversaci√≥n:', e);
        orderState = { items: [], subtotal: 0, delivery_fee: 0, total: 0 };
        conversationHistory = [];
      }

      // Agregar informaci√≥n del cliente si est√° disponible
      let customerContext = '';
      if (customerData && customerData.name) {
        customerContext = `\nCLIENTE: ${customerData.name}`;
        if (customerData.total_orders > 0) {
          customerContext += ` (${customerData.total_orders} pedidos anteriores)`;
        }
        if (customerData.favorite_item) {
          customerContext += `\nItem favorito: ${customerData.favorite_item}`;
        }
      }

      return {
        restaurant: {
          ...restaurant,
          customer_context: customerContext
        },
        orderState,
        conversationHistory,
        currentStep: conversation.current_step || CONVERSATION_STEPS.GREETING
      };

    } catch (error) {
      logger.error('Error preparando contexto para Claude:', error);
      throw error;
    }
  }

  /**
   * Aplana el men√∫ para el contexto de Claude
   * @param {Array} categories - Categor√≠as del men√∫
   * @returns {Array} Men√∫ aplanado
   */
  static flattenMenuForContext(categories) {
    const flatMenu = [];
    
    categories.forEach(category => {
      category.items.forEach(item => {
        flatMenu.push({
          ...item,
          category_name: category.name,
          category_emoji: category.emoji
        });
      });
    });

    return flatMenu;
  }

  /**
   * Analiza la respuesta de Claude para detectar intenciones
   * @param {string} response - Respuesta de Claude
   * @param {Object} conversation - Conversaci√≥n actual
   * @returns {Promise<Object>} An√°lisis de la respuesta
   */
  static async analyzeResponse(response, conversation) {
    try {
      const analysis = {
        intent: 'chat',
        confidence: 0.5,
        next_step: conversation.current_step,
        actions: [],
        extracted_data: {}
      };

      const responseLower = response.toLowerCase();

      // Detectar intenciones comunes
      if (this.containsOrderingKeywords(responseLower)) {
        analysis.intent = 'ordering';
        analysis.confidence = 0.8;
        analysis.next_step = CONVERSATION_STEPS.ORDERING;
      }

      if (this.containsAddressKeywords(responseLower)) {
        analysis.intent = 'address_request';
        analysis.confidence = 0.9;
        analysis.next_step = CONVERSATION_STEPS.ADDRESS;
      }

      if (this.containsConfirmationKeywords(responseLower)) {
        analysis.intent = 'confirmation';
        analysis.confidence = 0.8;
        analysis.next_step = CONVERSATION_STEPS.CONFIRMING;
      }

      if (this.containsModificationKeywords(responseLower)) {
        analysis.intent = 'modify_order';
        analysis.confidence = 0.7;
        analysis.actions.push('modify_order');
      }

      // Extraer informaci√≥n espec√≠fica
      const extractedAddress = this.extractAddressInfo(response);
      if (extractedAddress) {
        analysis.extracted_data.address = extractedAddress;
        analysis.actions.push('save_address');
      }

      const extractedItems = this.extractOrderItems(response);
      if (extractedItems.length > 0) {
        analysis.extracted_data.items = extractedItems;
        analysis.actions.push('add_items');
      }

      return analysis;

    } catch (error) {
      logger.error('Error analizando respuesta de Claude:', error);
      
      return {
        intent: 'unknown',
        confidence: 0,
        next_step: conversation.current_step,
        actions: [],
        extracted_data: {}
      };
    }
  }

  /**
   * Detecta palabras clave relacionadas con pedidos
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de pedido
   */
  static containsOrderingKeywords(text) {
    const orderKeywords = [
      'quiero', 'pedir', 'ordenar', 'llevar', 'agregar',
      'menu', 'men√∫', 'carta', 'disponible', 'precio',
      'cuanto cuesta', 'alitas', 'hamburguesa', 'bebida'
    ];

    return orderKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Detecta palabras clave relacionadas con direcci√≥n
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de direcci√≥n
   */
  static containsAddressKeywords(text) {
    const addressKeywords = [
      'direcci√≥n', 'direccion', 'domicilio', 'entregar',
      'calle', 'colonia', 'n√∫mero', 'numero', 'referencias'
    ];

    return addressKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Detecta palabras clave de confirmaci√≥n
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de confirmaci√≥n
   */
  static containsConfirmationKeywords(text) {
    const confirmKeywords = [
      'confirmar', 'pedido listo', 'es todo', 'ser√≠a todo',
      'as√≠ est√° bien', 'perfecto', 'proceder'
    ];

    return confirmKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Detecta palabras clave de modificaci√≥n
   * @param {string} text - Texto a analizar
   * @returns {boolean} True si contiene palabras clave de modificaci√≥n
   */
  static containsModificationKeywords(text) {
    const modifyKeywords = [
      'cambiar', 'quitar', 'eliminar', 'modificar',
      'en lugar de', 'mejor', 'cancelar', 'ya no'
    ];

    return modifyKeywords.some(keyword => text.includes(keyword));
  }

  /**
   * Extrae informaci√≥n de direcci√≥n del texto
   * @param {string} text - Texto a analizar
   * @returns {Object|null} Informaci√≥n de direcci√≥n extra√≠da
   */
  static extractAddressInfo(text) {
    try {
      const addressInfo = {};

      // Patrones para extraer informaci√≥n
      const streetPattern = /(?:calle|avenida|av\.?|blvd\.?)\s+([^,\n]+)/i;
      const numberPattern = /(?:n√∫mero|numero|#|num\.?)\s*(\d+)/i;
      const neighborhoodPattern = /(?:colonia|col\.?)\s+([^,\n]+)/i;
      const referencesPattern = /(?:referencias?|entre|cerca de|enfrente de)\s+([^,\n]+)/i;

      const streetMatch = text.match(streetPattern);
      if (streetMatch) {
        addressInfo.street = streetMatch[1].trim();
      }

      const numberMatch = text.match(numberPattern);
      if (numberMatch) {
        addressInfo.number = numberMatch[1].trim();
      }

      const neighborhoodMatch = text.match(neighborhoodPattern);
      if (neighborhoodMatch) {
        addressInfo.neighborhood = neighborhoodMatch[1].trim();
      }

      const referencesMatch = text.match(referencesPattern);
      if (referencesMatch) {
        addressInfo.references = referencesMatch[1].trim();
      }

      // Retornar solo si se encontr√≥ al menos un campo
      return Object.keys(addressInfo).length > 0 ? addressInfo : null;

    } catch (error) {
      logger.error('Error extrayendo informaci√≥n de direcci√≥n:', error);
      return null;
    }
  }

  /**
   * Extrae items del pedido del texto
   * @param {string} text - Texto a analizar
   * @returns {Array} Items extra√≠dos
   */
  static extractOrderItems(text) {
    try {
      const items = [];
      const textLower = text.toLowerCase();

      // Patrones comunes para items
      const itemPatterns = [
        /(\d+)\s*(?:media orden|orden|pieza|piezas|pedazo|pedazos)\s+(?:de\s+)?([^,\n]+)/gi,
        /(?:quiero|pedir|llevar)\s+(?:una|un|dos|tres|cuatro|cinco)?\s*([^,\n]+)/gi,
        /(\d+)\s*([^,\n]*(?:alitas|hamburguesa|hotdog|bebida|refresco)[^,\n]*)/gi
      ];

      itemPatterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(textLower)) !== null) {
          const quantity = match[1] ? parseInt(match[1]) : 1;
          const itemName = (match[2] || match[1]).trim();
          
          if (itemName && itemName.length > 2) {
            items.push({
              name: itemName,
              quantity: quantity || 1,
              confidence: 0.6
            });
          }
        }
      });

      return items;

    } catch (error) {
      logger.error('Error extrayendo items del pedido:', error);
      return [];
    }
  }

  /**
   * Genera respuesta de bienvenida personalizada
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} customerData - Datos del cliente
   * @returns {Promise<string>} Mensaje de bienvenida
   */
  static async generateWelcomeMessage(restaurant, customerData = null) {
    try {
      let welcomeMessage = restaurant.welcome_message || DEFAULT_MESSAGES.WELCOME;

      // Personalizar si es cliente recurrente
      if (customerData && customerData.total_orders > 0) {
        const personalizedMessages = [
          `¬°Hola de nuevo${customerData.name ? `, ${customerData.name}` : ''}! üëã Es un placer verte otra vez.`,
          `¬°Bienvenido de vuelta${customerData.name ? `, ${customerData.name}` : ''}! üòä ¬øLo de siempre o algo diferente hoy?`,
          `¬°Hey${customerData.name ? `, ${customerData.name}` : ''}! üéâ Gracias por elegirnos nuevamente.`
        ];

        welcomeMessage = personalizedMessages[Math.floor(Math.random() * personalizedMessages.length)];

        // Agregar sugerencia del item favorito
        if (customerData.favorite_item) {
          welcomeMessage += `\n\n¬øTe gustar√≠a tu favorito: ${customerData.favorite_item}? üçó`;
        }
      }

      return welcomeMessage;

    } catch (error) {
      logger.error('Error generando mensaje de bienvenida:', error);
      return restaurant.welcome_message || DEFAULT_MESSAGES.WELCOME;
    }
  }

  /**
   * Valida la respuesta de Claude antes de enviarla
   * @param {string} response - Respuesta a validar
   * @param {Object} context - Contexto de la conversaci√≥n
   * @returns {Object} Respuesta validada
   */
  static validateResponse(response, context = {}) {
    try {
      let validatedResponse = response;
      const issues = [];

      // Verificar longitud
      if (response.length > 1000) {
        validatedResponse = response.substring(0, 997) + '...';
        issues.push('response_truncated');
      }

      // Verificar que no contenga informaci√≥n sensible
      const sensitivePatterns = [
        /api[_-]?key/i,
        /password/i,
        /secret/i,
        /token/i
      ];

      sensitivePatterns.forEach(pattern => {
        if (pattern.test(response)) {
          issues.push('sensitive_data_detected');
        }
      });

      // Verificar que la respuesta sea apropiada
      if (response.length < 10) {
        issues.push('response_too_short');
      }

      return {
        response: validatedResponse,
        isValid: issues.length === 0,
        issues
      };

    } catch (error) {
      logger.error('Error validando respuesta de Claude:', error);
      
      return {
        response: DEFAULT_MESSAGES.ERROR,
        isValid: false,
        issues: ['validation_error']
      };
    }
  }

  /**
   * Genera resumen de conversaci√≥n para logging
   * @param {Object} conversation - Conversaci√≥n a resumir
   * @returns {Promise<string>} Resumen generado
   */
  static async generateConversationSummary(conversation) {
    try {
      let aiContext = [];
      try {
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        return 'Error parseando contexto de conversaci√≥n';
      }

      if (aiContext.length === 0) {
        return 'Conversaci√≥n sin mensajes';
      }

      const messageCount = aiContext.length;
      const userMessages = aiContext.filter(msg => msg.role === 'user').length;
      const assistantMessages = aiContext.filter(msg => msg.role === 'assistant').length;

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        orderData = {};
      }

      const summary = [
        `Conversaci√≥n con ${messageCount} mensajes (${userMessages} del cliente, ${assistantMessages} del asistente)`,
        `Estado: ${conversation.status}`,
        `Paso actual: ${conversation.current_step}`
      ];

      if (orderData.items && orderData.items.length > 0) {
        summary.push(`Pedido: ${orderData.items.length} items, total: $${orderData.total || 0}`);
      }

      return summary.join(' | ');

    } catch (error) {
      logger.error('Error generando resumen de conversaci√≥n:', error);
      return 'Error generando resumen';
    }
  }

  /**
   * Obtiene estad√≠sticas de uso de Claude
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas de uso
   */
  static async getUsageStats(restaurantId, dateRange = {}) {
    try {
      // Esta funci√≥n requerir√≠a una tabla de logs de Claude
      // Por ahora retornamos un placeholder
      return {
        total_requests: 0,
        total_tokens: 0,
        avg_response_time: 0,
        error_rate: 0,
        cost_estimate: 0
      };

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de Claude:', error);
      throw error;
    }
  }
}

module.exports = ClaudeService;


================================================
File: src/services/conversationService.js
================================================
const Conversation = require('../models/Conversation');
const Customer = require('../models/Customer');
const Menu = require('../models/Menu');
const ClaudeService = require('./claudeService');
const WhatsAppService = require('./whatsappService');
const ValidationService = require('./validationService');
const logger = require('../utils/logger');
const { 
  CONVERSATION_STATUS, 
  CONVERSATION_STEPS, 
  TIME_LIMITS,
  DEFAULT_MESSAGES 
} = require('../utils/constants');
const { ValidationError, DatabaseError } = require('../middleware/errorHandler');

// ============================================
// SERVICIO DE CONVERSACIONES
// ============================================

class ConversationService {

  /**
   * Procesa un mensaje entrante y genera respuesta
   * @param {Object} params - Par√°metros del procesamiento
   * @returns {Promise<Object>} Resultado del procesamiento
   */
  static async processIncomingMessage(params) {
    const {
      restaurant,
      customerPhone,
      messageText,
      messageData = null
    } = params;

    try {
      // 1. Obtener o crear conversaci√≥n
      const conversation = await Conversation.getOrCreate(restaurant.id, customerPhone);
      
      // 2. Obtener datos del cliente
      const customer = await Customer.findOrCreate(customerPhone);
      
      // 3. Validar mensaje
      const validationResult = ValidationService.validateIncomingMessage(messageText, conversation);
      if (!validationResult.isValid) {
        return await this.handleInvalidMessage(conversation, restaurant, validationResult.error);
      }

      // 4. Agregar mensaje del usuario al contexto
      await Conversation.addToContext(conversation.id, 'user', messageText);

      // 5. Verificar si es mensaje multimedia
      if (messageData?.mediaUrl) {
        const mediaResult = await WhatsAppService.processMediaMessage(messageData);
        if (mediaResult && mediaResult.message) {
          return await this.sendResponse(customerPhone, mediaResult.message, restaurant);
        }
      }

      // 6. Procesar con Claude AI
      const claudeResult = await ClaudeService.processMessage({
        restaurant,
        conversation,
        userMessage: messageText,
        customerData: customer
      });

      // 7. Procesar acciones detectadas por la IA
      const updatedConversation = await this.processDetectedActions(
        conversation,
        claudeResult.analysis,
        messageText,
        restaurant
      );

      // 8. Agregar respuesta de la IA al contexto
      await Conversation.addToContext(updatedConversation.id, 'assistant', claudeResult.response);

      // 9. Enviar respuesta al cliente
      const sendResult = await this.sendResponse(customerPhone, claudeResult.response, restaurant);

      return {
        success: true,
        conversation: updatedConversation,
        claudeResult,
        sendResult,
        actions_processed: claudeResult.analysis.actions || []
      };

    } catch (error) {
      logger.error('Error procesando mensaje entrante:', error);
      
      // Enviar mensaje de error al cliente
      try {
        await this.sendResponse(
          customerPhone, 
          restaurant.error_message || DEFAULT_MESSAGES.ERROR, 
          restaurant
        );
      } catch (sendError) {
        logger.error('Error enviando mensaje de error:', sendError);
      }

      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Procesa las acciones detectadas por Claude AI
   * @param {Object} conversation - Conversaci√≥n actual
   * @param {Object} analysis - An√°lisis de Claude
   * @param {string} messageText - Texto del mensaje
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async processDetectedActions(conversation, analysis, messageText, restaurant) {
    try {
      let updatedConversation = conversation;
      const actions = analysis.actions || [];

      for (const action of actions) {
        switch (action) {
          case 'add_items':
            updatedConversation = await this.processAddItems(
              updatedConversation, 
              analysis.extracted_data.items || [],
              restaurant
            );
            break;

          case 'modify_order':
            updatedConversation = await this.processModifyOrder(
              updatedConversation,
              messageText,
              restaurant
            );
            break;

          case 'save_address':
            updatedConversation = await this.processSaveAddress(
              updatedConversation,
              analysis.extracted_data.address
            );
            break;

          case 'confirm_order':
            updatedConversation = await this.processConfirmOrder(
              updatedConversation,
              restaurant
            );
            break;

          default:
            logger.debug('Acci√≥n no reconocida:', action);
        }
      }

      // Actualizar paso de la conversaci√≥n si cambi√≥
      if (analysis.next_step && analysis.next_step !== conversation.current_step) {
        updatedConversation = await Conversation.update(updatedConversation.id, {
          current_step: analysis.next_step
        });
      }

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando acciones detectadas:', error);
      return conversation; // Retornar conversaci√≥n original si hay error
    }
  }

  /**
   * Procesa la adici√≥n de items al pedido
   * @param {Object} conversation - Conversaci√≥n actual
   * @param {Array} detectedItems - Items detectados por la IA
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async processAddItems(conversation, detectedItems, restaurant) {
    try {
      if (!detectedItems || detectedItems.length === 0) {
        return conversation;
      }

      // Obtener men√∫ del restaurante
      const menuData = await Menu.getFullMenu(restaurant.id, true);
      const flatMenu = this.flattenMenuItems(menuData.categories);

      let updatedConversation = conversation;

      for (const detectedItem of detectedItems) {
        // Buscar item en el men√∫ por nombre
        const menuItem = this.findMenuItemByName(detectedItem.name, flatMenu);
        
        if (menuItem) {
          const orderItem = {
            menu_item_id: menuItem.id,
            name: menuItem.name,
            base_price: menuItem.price,
            quantity: detectedItem.quantity || 1,
            customizations: [],
            customizations_cost: 0,
            notes: null
          };

          // Calcular total del item
          orderItem.item_total = orderItem.base_price * orderItem.quantity;

          // Agregar item al pedido
          updatedConversation = await Conversation.addItemToOrder(updatedConversation.id, orderItem);

          logger.info('Item agregado al pedido', {
            conversationId: conversation.id,
            itemName: menuItem.name,
            quantity: orderItem.quantity,
            total: orderItem.item_total
          });
        } else {
          logger.warn('Item no encontrado en men√∫', {
            conversationId: conversation.id,
            searchedItem: detectedItem.name
          });
        }
      }

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando adici√≥n de items:', error);
      return conversation;
    }
  }

  /**
   * Procesa modificaciones al pedido
   * @param {Object} conversation - Conversaci√≥n actual
   * @param {string} messageText - Texto del mensaje
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async processModifyOrder(conversation, messageText, restaurant) {
    try {
      const messageLower = messageText.toLowerCase();
      
      // Detectar tipo de modificaci√≥n
      if (messageLower.includes('quitar') || messageLower.includes('eliminar') || messageLower.includes('cancelar')) {
        return await this.processRemoveItems(conversation, messageText);
      }

      if (messageLower.includes('cambiar') || messageLower.includes('modificar')) {
        return await this.processChangeItems(conversation, messageText, restaurant);
      }

      return conversation;

    } catch (error) {
      logger.error('Error procesando modificaci√≥n de pedido:', error);
      return conversation;
    }
  }

  /**
   * Procesa la eliminaci√≥n de items del pedido
   * @param {Object} conversation - Conversaci√≥n actual
   * @param {string} messageText - Texto del mensaje
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async processRemoveItems(conversation, messageText) {
    try {
      let orderData = JSON.parse(conversation.order_data || '{}');
      
      if (!orderData.items || orderData.items.length === 0) {
        return conversation;
      }

      // Buscar √≠ndices de items a remover
      const itemsToRemove = [];
      const messageLower = messageText.toLowerCase();

      orderData.items.forEach((item, index) => {
        if (messageLower.includes(item.name.toLowerCase())) {
          itemsToRemove.push(index);
        }
      });

      // Si no se encuentra espec√≠ficamente, y hay indicaci√≥n num√©rica
      const numberMatch = messageText.match(/(\d+)/);
      if (itemsToRemove.length === 0 && numberMatch) {
        const itemIndex = parseInt(numberMatch[1]) - 1; // Convertir a √≠ndice base 0
        if (itemIndex >= 0 && itemIndex < orderData.items.length) {
          itemsToRemove.push(itemIndex);
        }
      }

      // Remover items (en orden descendente para no afectar √≠ndices)
      let updatedConversation = conversation;
      for (const index of itemsToRemove.sort((a, b) => b - a)) {
        updatedConversation = await Conversation.removeItemFromOrder(updatedConversation.id, index);
      }

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando eliminaci√≥n de items:', error);
      return conversation;
    }
  }

  /**
   * Procesa el guardado de direcci√≥n
   * @param {Object} conversation - Conversaci√≥n actual
   * @param {Object} addressData - Datos de direcci√≥n extra√≠dos
   * @returns {Promise<Object>} Conversaci√≥n actualizada
   */
  static async processSaveAddress(conversation, addressData) {
    try {
      if (!addressData || Object.keys(addressData).length === 0) {
        return conversation;
      }

      let orderData = JSON.parse(conversation.order_data || '{}');
      
      if (!orderData.delivery_address) {
        orderData.delivery_address = {};
      }

      // Fusionar datos de direcci√≥n
      Object.assign(orderData.delivery_address, addressData);

      const updatedConversation = await Conversation.updateOrderData(conversation.id, orderData);

      logger.info('Direcci√≥n guardada en pedido', {
        conversationId: conversation.id,
        addressFields: Object.keys(addressData)
      });

      return updatedConversation;

    } catch (error) {
      logger.error('Error procesando guardado de direcci√≥n:', error);
      return conversation;
    }
  }

  /**
   * Maneja mensajes inv√°lidos
   * @param {Object} conversation - Conversaci√≥n actual
   * @param {Object} restaurant - Datos del restaurante
   * @param {string} errorMessage - Mensaje de error
   * @returns {Promise<Object>} Resultado del manejo
   */
  static async handleInvalidMessage(conversation, restaurant, errorMessage) {
    try {
      const response = `${DEFAULT_MESSAGES.INVALID_INPUT}\n\n${errorMessage}`;
      
      const sendResult = await this.sendResponse(
        conversation.customer_phone, 
        response, 
        restaurant
      );

      return {
        success: false,
        error: errorMessage,
        sendResult
      };

    } catch (error) {
      logger.error('Error manejando mensaje inv√°lido:', error);
      throw error;
    }
  }

  /**
   * Env√≠a respuesta al cliente
   * @param {string} customerPhone - Tel√©fono del cliente
   * @param {string} message - Mensaje a enviar
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Resultado del env√≠o
   */
  static async sendResponse(customerPhone, message, restaurant) {
    try {
      return await WhatsAppService.sendMessageWithRetry(
        customerPhone,
        message,
        { 
          addEmojis: true,
          restaurantName: restaurant.name 
        },
        2 // m√°ximo 2 reintentos
      );

    } catch (error) {
      logger.error('Error enviando respuesta:', error);
      throw error;
    }
  }

  /**
   * Inicia una nueva conversaci√≥n con mensaje de bienvenida
   * @param {Object} restaurant - Datos del restaurante
   * @param {string} customerPhone - Tel√©fono del cliente
   * @returns {Promise<Object>} Resultado de la iniciaci√≥n
   */
  static async startConversation(restaurant, customerPhone) {
    try {
      // Obtener o crear cliente
      const customer = await Customer.findOrCreate(customerPhone);
      
      // Crear nueva conversaci√≥n
      const conversation = await Conversation.getOrCreate(restaurant.id, customerPhone);
      
      // Generar mensaje de bienvenida personalizado
      const welcomeMessage = await ClaudeService.generateWelcomeMessage(restaurant, customer);
      
      // Obtener men√∫ para incluir en bienvenida si es cliente nuevo
      let fullMessage = welcomeMessage;
      
      if (customer.total_orders === 0) {
        const menuData = await Menu.getFullMenu(restaurant.id, true);
        const menuMessage = WhatsAppService.generateMenuMessage(menuData.categories, restaurant);
        fullMessage = `${welcomeMessage}\n\n${menuMessage}`;
      }

      // Agregar mensaje de bienvenida al contexto
      await Conversation.addToContext(conversation.id, 'assistant', fullMessage);
      
      // Enviar mensaje
      const sendResult = await this.sendResponse(customerPhone, fullMessage, restaurant);

      return {
        success: true,
        conversation,
        customer,
        sendResult
      };

    } catch (error) {
      logger.error('Error iniciando conversaci√≥n:', error);
      throw error;
    }
  }

  /**
   * Limpia conversaciones inactivas
   * @param {number} maxInactiveHours - Horas m√°ximas de inactividad
   * @returns {Promise<number>} N√∫mero de conversaciones limpiadas
   */
  static async cleanupInactiveConversations(maxInactiveHours = 2) {
    try {
      const cleanedCount = await Conversation.cleanupInactive(maxInactiveHours);
      
      if (cleanedCount > 0) {
        logger.info('Conversaciones inactivas limpiadas', {
          count: cleanedCount,
          maxInactiveHours
        });
      }

      return cleanedCount;

    } catch (error) {
      logger.error('Error limpiando conversaciones inactivas:', error);
      throw error;
    }
  }

  /**
   * Obtiene el estado actual de una conversaci√≥n
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Tel√©fono del cliente
   * @returns {Promise<Object|null>} Estado de la conversaci√≥n
   */
  static async getConversationStatus(restaurantId, customerPhone) {
    try {
      const conversation = await Conversation.getActive(restaurantId, customerPhone);
      
      if (!conversation) {
        return null;
      }

      let orderData = {};
      let aiContext = [];

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
        aiContext = JSON.parse(conversation.ai_context || '[]');
      } catch (e) {
        logger.warn('Error parseando datos de conversaci√≥n para status:', e);
      }

      return {
        id: conversation.id,
        status: conversation.status,
        current_step: conversation.current_step,
        last_interaction: conversation.last_interaction_at,
        items_count: orderData.items ? orderData.items.length : 0,
        total: orderData.total || 0,
        messages_count: aiContext.length,
        created_at: conversation.created_at
      };

    } catch (error) {
      logger.error('Error obteniendo estado de conversaci√≥n:', error);
      throw error;
    }
  }

  /**
   * Reinicia una conversaci√≥n abandonada
   * @param {string} restaurantId - ID del restaurante
   * @param {string} customerPhone - Tel√©fono del cliente
   * @returns {Promise<Object>} Nueva conversaci√≥n iniciada
   */
  static async restartConversation(restaurantId, customerPhone) {
    try {
      // Marcar conversaci√≥n actual como abandonada si existe
      const existingConversation = await Conversation.getActive(restaurantId, customerPhone);
      if (existingConversation) {
        await Conversation.abandon(existingConversation.id);
      }

      // Obtener datos del restaurante
      const Restaurant = require('../models/Restaurant');
      const restaurant = await Restaurant.findById(restaurantId);
      
      if (!restaurant) {
        throw new ValidationError('Restaurante no encontrado');
      }

      // Iniciar nueva conversaci√≥n
      return await this.startConversation(restaurant, customerPhone);

    } catch (error) {
      logger.error('Error reiniciando conversaci√≥n:', error);
      throw error;
    }
  }

  /**
   * Obtiene estad√≠sticas de conversaciones
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas
   */
  static async getConversationStats(restaurantId, dateRange = {}) {
    try {
      const stats = await Conversation.getStats(restaurantId, dateRange);
      
      // Agregar m√©tricas adicionales
      const additionalStats = await this.calculateAdditionalStats(restaurantId, dateRange);
      
      return {
        ...stats,
        ...additionalStats
      };

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de conversaciones:', error);
      throw error;
    }
  }

  /**
   * Calcula estad√≠sticas adicionales
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas adicionales
   */
  static async calculateAdditionalStats(restaurantId, dateRange) {
    try {
      // Aqu√≠ se podr√≠an calcular m√°s m√©tricas espec√≠ficas
      return {
        peak_hours: [],
        avg_items_per_order: 0,
        most_common_step: CONVERSATION_STEPS.GREETING,
        customer_satisfaction: 0
      };

    } catch (error) {
      logger.error('Error calculando estad√≠sticas adicionales:', error);
      return {};
    }
  }

  // ============================================
  // M√âTODOS AUXILIARES
  // ============================================

  /**
   * Aplana los items del men√∫ para b√∫squeda
   * @param {Array} categories - Categor√≠as del men√∫
   * @returns {Array} Items aplanados
   */
  static flattenMenuItems(categories) {
    const flatItems = [];
    
    categories.forEach(category => {
      category.items.forEach(item => {
        flatItems.push({
          ...item,
          category_name: category.name
        });
      });
    });

    return flatItems;
  }

  /**
   * Busca un item del men√∫ por nombre
   * @param {string} searchName - Nombre a buscar
   * @param {Array} menuItems - Items del men√∫
   * @returns {Object|null} Item encontrado
   */
  static findMenuItemByName(searchName, menuItems) {
    const searchLower = searchName.toLowerCase();
    
    // B√∫squeda exacta primero
    let found = menuItems.find(item => 
      item.name.toLowerCase() === searchLower
    );

    // B√∫squeda parcial si no se encuentra exacta
    if (!found) {
      found = menuItems.find(item => 
        item.name.toLowerCase().includes(searchLower) ||
        searchLower.includes(item.name.toLowerCase())
      );
    }

    // B√∫squeda por palabras clave
    if (!found) {
      const keywords = searchLower.split(' ');
      found = menuItems.find(item => {
        const itemWords = item.name.toLowerCase().split(' ');
        return keywords.some(keyword => 
          itemWords.some(word => word.includes(keyword))
        );
      });
    }

    return found || null;
  }

  /**
   * Valida si una conversaci√≥n puede proceder al siguiente paso
   * @param {Object} conversation - Conversaci√≥n a validar
   * @param {string} nextStep - Siguiente paso propuesto
   * @returns {boolean} True si puede proceder
   */
  static canProceedToStep(conversation, nextStep) {
    try {
      const currentStep = conversation.current_step;
      let orderData = {};

      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        orderData = { items: [] };
      }

      switch (nextStep) {
        case CONVERSATION_STEPS.ORDERING:
          return true; // Siempre se puede empezar a ordenar

        case CONVERSATION_STEPS.ADDRESS:
          return orderData.items && orderData.items.length > 0;

        case CONVERSATION_STEPS.CONFIRMING:
          return orderData.items && 
                 orderData.items.length > 0 && 
                 orderData.delivery_address &&
                 orderData.delivery_address.street &&
                 orderData.delivery_address.number &&
                 orderData.delivery_address.neighborhood;

        case CONVERSATION_STEPS.COMPLETED:
          return currentStep === CONVERSATION_STEPS.CONFIRMING;

        default:
          return true;
      }

    } catch (error) {
      logger.error('Error validando paso de conversaci√≥n:', error);
      return false;
    }
  }
}

module.exports = ConversationService;


================================================
File: src/services/orderService.js
================================================
const Order = require('../models/Order');
const Customer = require('../models/Customer');
const Conversation = require('../models/Conversation');
const WhatsAppService = require('./whatsappService');
const ValidationService = require('./validationService');
const logger = require('../utils/logger');
const { 
  ORDER_STATUS, 
  CONVERSATION_STATUS,
  DEFAULT_MESSAGES,
  BUSINESS_CONFIG 
} = require('../utils/constants');
const { ValidationError, DatabaseError } = require('../middleware/errorHandler');

// ============================================
// SERVICIO DE PEDIDOS
// ============================================

class OrderService {

  /**
   * Crea un pedido desde una conversaci√≥n
   * @param {Object} conversation - Conversaci√≥n con el pedido
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<Object>} Pedido creado
   */
  static async createFromConversation(conversation, restaurant) {
    try {
      // Validar conversaci√≥n
      const validationResult = ValidationService.validateOrderFromConversation(conversation);
      if (!validationResult.isValid) {
        throw new ValidationError(validationResult.error);
      }

      // Parsear datos del pedido
      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || '{}');
      } catch (e) {
        throw new ValidationError('Error parseando datos del pedido');
      }

      // Obtener o crear cliente
      const customer = await Customer.findOrCreate(conversation.customer_phone);

      // Calcular tiempo estimado de entrega
      const estimatedTime = await Order.calculateDeliveryTime(
        restaurant.id,
        orderData.delivery_address?.neighborhood
      );

      // Preparar datos del pedido
      const orderPayload = {
        restaurant_id: restaurant.id,
        customer_id: customer.id,
        conversation_id: conversation.id,
        customer_phone: conversation.customer_phone,
        customer_name: customer.name,
        delivery_street: orderData.delivery_address.street,
        delivery_number: orderData.delivery_address.number,
        delivery_neighborhood: orderData.delivery_address.neighborhood,
        delivery_references: orderData.delivery_address.references,
        delivery_postal_code: orderData.delivery_address.postal_code,
        items: orderData.items || [],
        subtotal: orderData.subtotal || 0,
        delivery_fee: this.calculateDeliveryFee(restaurant, orderData),
        total: (orderData.subtotal || 0) + this.calculateDeliveryFee(restaurant, orderData),
        estimated_delivery_time: estimatedTime,
        special_instructions: orderData.special_instructions
      };

      // Crear pedido
      const order = await Order.create(orderPayload);

      // Marcar conversaci√≥n como completada
      await Conversation.complete(conversation.id, order.id);

      // Actualizar estad√≠sticas del cliente
      await Customer.updateOrderStats(customer.id, order.total);

      // Enviar confirmaci√≥n al cliente
      await this.sendOrderConfirmation(order, restaurant, customer);

      // Notificar al restaurante si est√° configurado
      await this.notifyRestaurant(order, restaurant);

      logger.info('Pedido creado exitosamente', {
        orderId: order.id,
        restaurantId: restaurant.id,
        customerPhone: customer.phone.substring(0, 8) + '****',
        total: order.total,
        itemsCount: orderPayload.items.length
      });

      return order;

    } catch (error) {
      logger.error('Error creando pedido desde conversaci√≥n:', error);
      throw error;
    }
  }

  /**
   * Actualiza el estado de un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} newStatus - Nuevo estado
   * @param {Object} options - Opciones adicionales
   * @returns {Promise<Object>} Pedido actualizado
   */
  static async updateOrderStatus(orderId, newStatus, options = {}) {
    try {
      const { 
        internal_notes = null,
        estimated_delivery_time = null,
        notify_customer = true,
        restaurant = null
      } = options;

      // Actualizar estado en base de datos
      const updatedOrder = await Order.updateStatus(orderId, newStatus, {
        internal_notes,
        estimated_delivery_time
      });

      // Obtener datos completos del pedido
      const fullOrder = await Order.findById(orderId);

      // Notificar al cliente si est√° habilitado
      if (notify_customer && fullOrder) {
        await this.notifyCustomerStatusChange(fullOrder, newStatus);
      }

      // Log del cambio de estado
      logger.info('Estado de pedido actualizado', {
        orderId,
        newStatus,
        previousStatus: updatedOrder.status,
        notifyCustomer: notify_customer
      });

      return fullOrder;

    } catch (error) {
      logger.error('Error actualizando estado de pedido:', error);
      throw error;
    }
  }

  /**
   * Cancela un pedido
   * @param {string} orderId - ID del pedido
   * @param {string} reason - Raz√≥n de cancelaci√≥n
   * @param {Object} options - Opciones adicionales
   * @returns {Promise<Object>} Pedido cancelado
   */
  static async cancelOrder(orderId, reason, options = {}) {
    try {
      const { notify_customer = true, cancelled_by = 'restaurant' } = options;

      // Cancelar pedido
      const cancelledOrder = await Order.cancel(orderId, reason);

      // Obtener datos completos
      const fullOrder = await Order.findById(orderId);

      // Notificar al cliente
      if (notify_customer && fullOrder) {
        await this.notifyCustomerCancellation(fullOrder, reason, cancelled_by);
      }

      logger.info('Pedido cancelado', {
        orderId,
        reason,
        cancelledBy: cancelled_by
      });

      return fullOrder;

    } catch (error) {
      logger.error('Error cancelando pedido:', error);
      throw error;
    }
  }

  /**
   * Calcula el costo de env√≠o
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} orderData - Datos del pedido
   * @returns {number} Costo de env√≠o
   */
  static calculateDeliveryFee(restaurant, orderData) {
    try {
      let deliveryFee = restaurant.delivery_fee || 0;

      // Verificar si hay costo extra por zona
      const neighborhood = orderData.delivery_address?.neighborhood;
      
      // Aqu√≠ se podr√≠a consultar la tabla delivery_zones
      // Por ahora usamos el fee base del restaurante

      // Env√≠o gratis si supera el m√≠nimo (si est√° configurado)
      if (restaurant.free_delivery_minimum && 
          orderData.subtotal >= restaurant.free_delivery_minimum) {
        deliveryFee = 0;
      }

      return deliveryFee;

    } catch (error) {
      logger.error('Error calculando costo de env√≠o:', error);
      return restaurant.delivery_fee || 0;
    }
  }

  /**
   * Env√≠a confirmaci√≥n de pedido al cliente
   * @param {Object} order - Datos del pedido
   * @param {Object} restaurant - Datos del restaurante
   * @param {Object} customer - Datos del cliente
   * @returns {Promise<void>}
   */
  static async sendOrderConfirmation(order, restaurant, customer) {
    try {
      // Preparar datos para el mensaje
      const orderData = {
        items: [],
        subtotal: order.subtotal,
        delivery_fee: order.delivery_fee,
        total: order.total,
        estimated_delivery_time: order.estimated_delivery_time,
        delivery_address: {
          street: order.delivery_street,
          number: order.delivery_number,
          neighborhood: order.delivery_neighborhood,
          references: order.delivery_references
        }
      };

      // Obtener items del pedido
      const fullOrder = await Order.findById(order.id);
      if (fullOrder && fullOrder.items) {
        orderData.items = fullOrder.items;
      }

      // Generar mensaje de confirmaci√≥n
      const confirmationMessage = WhatsAppService.generateOrderConfirmation(orderData, restaurant);

      // Enviar mensaje
      await WhatsAppService.sendMessage(order.customer_phone, confirmationMessage);

      logger.info('Confirmaci√≥n de pedido enviada', {
        orderId: order.id,
        customerPhone: order.customer_phone.substring(0, 8) + '****'
      });

    } catch (error) {
      logger.error('Error enviando confirmaci√≥n de pedido:', error);
      // No lanzar error para no afectar la creaci√≥n del pedido
    }
  }

  /**
   * Notifica cambio de estado al cliente
   * @param {Object} order - Datos del pedido
   * @param {string} newStatus - Nuevo estado
   * @returns {Promise<void>}
   */
  static async notifyCustomerStatusChange(order, newStatus) {
    try {
      const statusMessages = {
        [ORDER_STATUS.CONFIRMED]: `‚úÖ Tu pedido ha sido confirmado y est√° siendo preparado. Tiempo estimado: ${order.estimated_delivery_time || 30} minutos.`,
        [ORDER_STATUS.PREPARING]: `üë®‚Äçüç≥ Tu pedido est√° siendo preparado con mucho cari√±o. ¬°Ya casi est√° listo!`,
        [ORDER_STATUS.READY]: `üõµ ¬°Tu pedido est√° listo! El repartidor saldr√° en breve.`,
        [ORDER_STATUS.OUT_FOR_DELIVERY]: `üöó ¬°Tu pedido est√° en camino! El repartidor llegar√° pronto.`,
        [ORDER_STATUS.DELIVERED]: `‚úÖ ¬°Pedido entregado! Gracias por tu preferencia. ¬°Esperamos verte pronto! üôè`
      };

      const message = statusMessages[newStatus];
      
      if (message) {
        await WhatsAppService.sendMessage(order.customer_phone, message);
        
        logger.info('Notificaci√≥n de estado enviada', {
          orderId: order.id,
          newStatus,
          customerPhone: order.customer_phone.substring(0, 8) + '****'
        });
      }

    } catch (error) {
      logger.error('Error notificando cambio de estado:', error);
      // No lanzar error para no afectar la actualizaci√≥n
    }
  }

  /**
   * Notifica cancelaci√≥n al cliente
   * @param {Object} order - Datos del pedido
   * @param {string} reason - Raz√≥n de cancelaci√≥n
   * @param {string} cancelledBy - Qui√©n cancel√≥
   * @returns {Promise<void>}
   */
  static async notifyCustomerCancellation(order, reason, cancelledBy) {
    try {
      let message = `‚ùå Lamentamos informarte que tu pedido ha sido cancelado.`;
      
      if (reason) {
        message += `\n\nMotivo: ${reason}`;
      }

      if (cancelledBy === 'restaurant') {
        message += `\n\nNos disculpamos por las molestias. Te invitamos a realizar un nuevo pedido cuando gustes. üôè`;
      }

      message += `\n\n¬øHay algo m√°s en lo que podamos ayudarte?`;

      await WhatsAppService.sendMessage(order.customer_phone, message);

      logger.info('Notificaci√≥n de cancelaci√≥n enviada', {
        orderId: order.id,
        reason,
        cancelledBy,
        customerPhone: order.customer_phone.substring(0, 8) + '****'
      });

    } catch (error) {
      logger.error('Error notificando cancelaci√≥n:', error);
      // No lanzar error para no afectar la cancelaci√≥n
    }
  }

  /**
   * Notifica al restaurante sobre nuevo pedido
   * @param {Object} order - Datos del pedido
   * @param {Object} restaurant - Datos del restaurante
   * @returns {Promise<void>}
   */
  static async notifyRestaurant(order, restaurant) {
    try {
      // Notificaci√≥n por WhatsApp si est√° configurado
      if (restaurant.notification_phone) {
        const message = this.generateRestaurantNotification(order);
        await WhatsAppService.sendMessage(restaurant.notification_phone, message);
      }

      // Notificaci√≥n por email (se implementar√≠a en el futuro)
      if (restaurant.notification_email) {
        // TODO: Implementar notificaci√≥n por email
        logger.info('Email notification would be sent to:', restaurant.notification_email);
      }

      logger.info('Restaurante notificado sobre nuevo pedido', {
        orderId: order.id,
        restaurantId: restaurant.id,
        notificationMethods: {
          whatsapp: !!restaurant.notification_phone,
          email: !!restaurant.notification_email
        }
      });

    } catch (error) {
      logger.error('Error notificando al restaurante:', error);
      // No lanzar error para no afectar la creaci√≥n del pedido
    }
  }

  /**
   * Genera mensaje de notificaci√≥n para el restaurante
   * @param {Object} order - Datos del pedido
   * @returns {string} Mensaje de notificaci√≥n
   */
  static generateRestaurantNotification(order) {
    try {
      let message = `üîî *NUEVO PEDIDO*\n\n`;
      message += `*ID:* ${order.id.substring(0, 8)}\n`;
      message += `*Cliente:* ${order.customer_phone}\n`;
      
      if (order.customer_name) {
        message += `*Nombre:* ${order.customer_name}\n`;
      }

      message += `*Total:* $${order.total}\n`;
      message += `*Direcci√≥n:* ${order.delivery_street} ${order.delivery_number}, ${order.delivery_neighborhood}\n`;
      
      if (order.delivery_references) {
        message += `*Referencias:* ${order.delivery_references}\n`;
      }

      if (order.special_instructions) {
        message += `*Instrucciones:* ${order.special_instructions}\n`;
      }

      message += `\n*Items:*\n`;
      
      // Si tenemos los items detallados
      if (order.items && order.items.length > 0) {
        order.items.forEach((item, index) => {
          message += `${index + 1}. ${item.item_name} (${item.quantity}x)\n`;
          
          if (item.customizations && item.customizations.length > 0) {
            const customizations = JSON.parse(item.customizations);
            customizations.forEach(custom => {
              message += `   ‚Ä¢ ${custom.name}\n`;
            });
          }
        });
      }

      message += `\n‚è∞ Tiempo estimado: ${order.estimated_delivery_time || 30} min`;
      message += `\nüìÖ ${new Date(order.created_at).toLocaleString('es-MX')}`;

      return message;

    } catch (error) {
      logger.error('Error generando notificaci√≥n para restaurante:', error);
      return `üîî Nuevo pedido recibido. ID: ${order.id.substring(0, 8)}, Total: $${order.total}`;
    }
  }

  /**
   * Obtiene pedidos activos de un restaurante
   * @param {string} restaurantId - ID del restaurante
   * @returns {Promise<Array>} Pedidos activos
   */
  static async getActiveOrders(restaurantId) {
    try {
      const activeOrders = await Order.getActiveOrders(restaurantId);
      
      // Agregar tiempo transcurrido y alertas
      const ordersWithAlerts = activeOrders.map(order => {
        const minutesSinceOrder = parseFloat(order.minutes_since_order || 0);
        const estimatedTime = order.estimated_delivery_time || 30;
        
        return {
          ...order,
          is_delayed: minutesSinceOrder > estimatedTime + 10, // 10 minutos de gracia
          is_urgent: minutesSinceOrder > estimatedTime - 5,   // Falta poco para el tiempo estimado
          minutes_since_order: Math.round(minutesSinceOrder)
        };
      });

      return ordersWithAlerts;

    } catch (error) {
      logger.error('Error obteniendo pedidos activos:', error);
      throw error;
    }
  }

  /**
   * Obtiene estad√≠sticas de pedidos
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas detalladas
   */
  static async getOrderStatistics(restaurantId, dateRange = {}) {
    try {
      // Estad√≠sticas b√°sicas
      const basicStats = await Order.getStats(restaurantId, dateRange);
      
      // Items m√°s vendidos
      const topItems = await Order.getTopItems(restaurantId, dateRange, 10);
      
      // Resumen por per√≠odos
      const dailySummary = await Order.getSalesSummary(restaurantId, 'today');
      const weeklySummary = await Order.getSalesSummary(restaurantId, 'week');
      const monthlySummary = await Order.getSalesSummary(restaurantId, 'month');

      return {
        basic: basicStats,
        top_items: topItems,
        summaries: {
          today: dailySummary,
          week: weeklySummary,
          month: monthlySummary
        },
        generated_at: new Date().toISOString()
      };

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de pedidos:', error);
      throw error;
    }
  }

  /**
   * Busca pedidos con filtros avanzados
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} filters - Filtros de b√∫squeda
   * @returns {Promise<Object>} Resultados de b√∫squeda
   */
  static async searchOrders(restaurantId, filters = {}) {
    try {
      const {
        customer_phone = null,
        status = null,
        start_date = null,
        end_date = null,
        min_total = null,
        max_total = null,
        neighborhood = null,
        page = 1,
        limit = 20,
        sort_by = 'created_at',
        sort_order = 'DESC'
      } = filters;

      // Preparar opciones para el modelo
      const searchOptions = {
        page: parseInt(page),
        limit: parseInt(limit),
        sortBy: sort_by,
        sortOrder: sort_order.toUpperCase()
      };

      // Agregar filtros
      if (status) searchOptions.status = status;
      if (customer_phone) searchOptions.customerPhone = customer_phone;
      if (start_date) searchOptions.startDate = start_date;
      if (end_date) searchOptions.endDate = end_date;

      const results = await Order.findByRestaurant(restaurantId, searchOptions);

      // Filtros adicionales que no est√°n en el modelo base
      if (min_total || max_total || neighborhood) {
        results.orders = results.orders.filter(order => {
          if (min_total && order.total < min_total) return false;
          if (max_total && order.total > max_total) return false;
          if (neighborhood && !order.delivery_neighborhood?.toLowerCase().includes(neighborhood.toLowerCase())) return false;
          return true;
        });

        // Recalcular paginaci√≥n despu√©s del filtro
        results.pagination.total_items = results.orders.length;
        results.pagination.total_pages = Math.ceil(results.orders.length / limit);
      }

      return results;

    } catch (error) {
      logger.error('Error buscando pedidos:', error);
      throw error;
    }
  }

  /**
   * Valida si un pedido puede ser modificado
   * @param {string} orderId - ID del pedido
   * @returns {Promise<Object>} Resultado de validaci√≥n
   */
  static async validateOrderModification(orderId) {
    try {
      const order = await Order.findById(orderId);
      
      if (!order) {
        return {
          canModify: false,
          reason: 'Pedido no encontrado'
        };
      }

      // No se puede modificar si ya est√° entregado o cancelado
      if ([ORDER_STATUS.DELIVERED, ORDER_STATUS.CANCELLED].includes(order.status)) {
        return {
          canModify: false,
          reason: `No se puede modificar un pedido ${order.status}`
        };
      }

      // No se puede modificar si ya est√° en camino
      if (order.status === ORDER_STATUS.OUT_FOR_DELIVERY) {
        return {
          canModify: false,
          reason: 'El pedido ya est√° en camino'
        };
      }

      // Verificar tiempo transcurrido
      const minutesSinceOrder = (Date.now() - new Date(order.created_at).getTime()) / (1000 * 60);
      
      if (minutesSinceOrder > 10) { // 10 minutos l√≠mite para modificaciones
        return {
          canModify: false,
          reason: 'Tiempo l√≠mite para modificaciones excedido'
        };
      }

      return {
        canModify: true,
        order
      };

    } catch (error) {
      logger.error('Error validando modificaci√≥n de pedido:', error);
      return {
        canModify: false,
        reason: 'Error interno'
      };
    }
  }

  /**
   * Genera reporte de ventas
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} options - Opciones del reporte
   * @returns {Promise<Object>} Reporte generado
   */
  static async generateSalesReport(restaurantId, options = {}) {
    try {
      const {
        start_date = null,
        end_date = null,
        group_by = 'day', // day, week, month
        include_items = false
      } = options;

      const dateRange = {};
      if (start_date) dateRange.startDate = start_date;
      if (end_date) dateRange.endDate = end_date;

      const report = {
        restaurant_id: restaurantId,
        period: { start_date, end_date },
        generated_at: new Date().toISOString(),
        summary: await Order.getStats(restaurantId, dateRange)
      };

      if (include_items) {
        report.top_items = await Order.getTopItems(restaurantId, dateRange, 20);
      }

      // Agregar agrupaci√≥n por per√≠odo (esto requerir√≠a consultas adicionales)
      report.group_by = group_by;
      report.grouped_data = []; // Placeholder para datos agrupados

      return report;

    } catch (error) {
      logger.error('Error generando reporte de ventas:', error);
      throw error;
    }
  }
}

module.exports = OrderService;


================================================
File: src/services/validationService.js
================================================
const Joi = require("joi");
const logger = require("../utils/logger");
const {
  VALIDATION_PATTERNS,
  BUSINESS_CONFIG,
  FILE_LIMITS,
  ORDER_STATUS,
  CONVERSATION_STATUS,
} = require("../utils/constants");

// ============================================
// SERVICIO DE VALIDACI√ìN
// ============================================

class ValidationService {
  // ============================================
  // VALIDACIONES DE RESTAURANTE
  // ============================================

  /**
   * Valida datos de creaci√≥n de restaurante
   * @param {Object} data - Datos del restaurante
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateRestaurantCreation(data) {
    const schema = Joi.object({
      name: Joi.string().min(2).max(100).required().messages({
        "string.empty": "El nombre del restaurante es requerido",
        "string.min": "El nombre debe tener al menos 2 caracteres",
        "string.max": "El nombre no puede exceder 100 caracteres",
      }),

      slug: Joi.string().pattern(VALIDATION_PATTERNS.SLUG).required().messages({
        "string.pattern.base":
          "El slug solo puede contener letras min√∫sculas, n√∫meros y guiones",
        "string.empty": "El slug es requerido",
      }),

      phone: Joi.string()
        .pattern(VALIDATION_PATTERNS.PHONE_NUMBER)
        .required()
        .messages({
          "string.pattern.base": "Formato de tel√©fono inv√°lido",
          "string.empty": "El tel√©fono es requerido",
        }),

      email: Joi.string().email().optional().allow(""),

      address: Joi.string().max(255).optional().allow(""),

      logo_url: Joi.string().uri().optional().allow(""),

      opens_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional()
        .messages({
          "string.pattern.base": "Formato de hora inv√°lido (HH:mm:ss)",
        }),

      closes_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional()
        .messages({
          "string.pattern.base": "Formato de hora inv√°lido (HH:mm:ss)",
        }),

      delivery_time_min: Joi.number().integer().min(5).max(120).optional(),
      delivery_time_max: Joi.number().integer().min(10).max(180).optional(),
      delivery_fee: Joi.number().min(0).max(500).optional(),
      minimum_order: Joi.number().min(0).max(10000).optional(),

      whatsapp_phone_id: Joi.string().max(50).optional().allow(""),
      twilio_phone_number: Joi.string().max(20).optional().allow(""),

      // En validateRestaurantCreation agregar:
      country_code: Joi.string()
        .valid("MX", "CO", "AR", "PE", "EC", "CL", "US")
        .optional(),
      currency: Joi.string()
        .valid("MXN", "COP", "ARS", "PEN", "USD", "CLP")
        .optional(),
      timezone: Joi.string().max(50).optional(),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida actualizaci√≥n de restaurante
   * @param {Object} data - Datos a actualizar
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateRestaurantUpdate(data) {
    const schema = Joi.object({
      name: Joi.string().min(2).max(100).optional(),
      phone: Joi.string().pattern(VALIDATION_PATTERNS.PHONE_NUMBER).optional(),
      email: Joi.string().email().optional().allow(""),
      address: Joi.string().max(255).optional().allow(""),
      logo_url: Joi.string().uri().optional().allow(""),
      is_active: Joi.boolean().optional(),
      opens_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional(),
      closes_at: Joi.string()
        .pattern(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/)
        .optional(),
      delivery_time_min: Joi.number().integer().min(5).max(120).optional(),
      delivery_time_max: Joi.number().integer().min(10).max(180).optional(),
      delivery_fee: Joi.number().min(0).max(500).optional(),
      minimum_order: Joi.number().min(0).max(10000).optional(),
      whatsapp_phone_id: Joi.string().max(50).optional().allow(""),
      twilio_phone_number: Joi.string().max(20).optional().allow(""),
    }).min(1);

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // VALIDACIONES DE MEN√ö
  // ============================================

  /**
   * Valida creaci√≥n de categor√≠a de men√∫
   * @param {Object} data - Datos de la categor√≠a
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateMenuCategoryCreation(data) {
    const schema = Joi.object({
      name: Joi.string().min(1).max(50).required().messages({
        "string.empty": "El nombre de la categor√≠a es requerido",
        "string.max": "El nombre no puede exceder 50 caracteres",
      }),

      description: Joi.string().max(255).optional().allow(""),
      display_order: Joi.number().integer().min(0).optional(),
      emoji: Joi.string().max(10).optional().allow(""),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida creaci√≥n de item de men√∫
   * @param {Object} data - Datos del item
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateMenuItemCreation(data) {
    const schema = Joi.object({
      category_id: Joi.string().uuid().required().messages({
        "string.empty": "La categor√≠a es requerida",
        "string.guid": "ID de categor√≠a inv√°lido",
      }),

      name: Joi.string().min(1).max(100).required().messages({
        "string.empty": "El nombre del producto es requerido",
        "string.max": "El nombre no puede exceder 100 caracteres",
      }),

      description: Joi.string().max(500).optional().allow(""),

      price: Joi.number().positive().max(10000).required().messages({
        "number.positive": "El precio debe ser mayor a 0",
        "number.base": "El precio debe ser un n√∫mero v√°lido",
        "any.required": "El precio es requerido",
      }),

      preparation_time: Joi.number().integer().min(1).max(180).optional(),
      display_order: Joi.number().integer().min(0).optional(),

      ingredients: Joi.array().items(Joi.string().max(50)).max(20).optional(),
      allergens: Joi.array().items(Joi.string().max(30)).max(10).optional(),
      calories: Joi.number().integer().min(0).max(5000).optional(),

      image_url: Joi.string().uri().optional().allow(""),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida actualizaci√≥n de item de men√∫
   * @param {Object} data - Datos a actualizar
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateMenuItemUpdate(data) {
    const schema = Joi.object({
      category_id: Joi.string().uuid().optional(),
      name: Joi.string().min(1).max(100).optional(),
      description: Joi.string().max(500).optional().allow(""),
      price: Joi.number().positive().max(10000).optional(),
      is_available: Joi.boolean().optional(),
      preparation_time: Joi.number().integer().min(1).max(180).optional(),
      display_order: Joi.number().integer().min(0).optional(),
      ingredients: Joi.array().items(Joi.string().max(50)).max(20).optional(),
      allergens: Joi.array().items(Joi.string().max(30)).max(10).optional(),
      calories: Joi.number().integer().min(0).max(5000).optional(),
      image_url: Joi.string().uri().optional().allow(""),
    }).min(1);

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // VALIDACIONES DE PEDIDOS
  // ============================================

  /**
   * Valida datos de direcci√≥n de entrega
   * @param {Object} address - Datos de direcci√≥n
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateDeliveryAddress(address) {
    const schema = Joi.object({
      street: Joi.string().min(3).max(100).required().messages({
        "string.empty": "La calle es requerida",
        "string.min": "La calle debe tener al menos 3 caracteres",
      }),

      number: Joi.string().min(1).max(20).required().messages({
        "string.empty": "El n√∫mero es requerido",
      }),

      neighborhood: Joi.string().min(3).max(100).required().messages({
        "string.empty": "La colonia es requerida",
        "string.min": "La colonia debe tener al menos 3 caracteres",
      }),

      references: Joi.string().max(255).optional().allow(""),
      postal_code: Joi.string()
        .pattern(VALIDATION_PATTERNS.POSTAL_CODE)
        .optional()
        .messages({
          "string.pattern.base": "C√≥digo postal inv√°lido",
        }),
    });

    return this.validateWithSchema(schema, address);
  }

  /**
   * Valida creaci√≥n de pedido
   * @param {Object} data - Datos del pedido
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateOrderCreation(data) {
    const schema = Joi.object({
      restaurant_id: Joi.string().uuid().required(),
      customer_phone: Joi.string()
        .pattern(VALIDATION_PATTERNS.PHONE_NUMBER)
        .required(),
      customer_name: Joi.string().max(100).optional().allow(""),

      delivery_address: Joi.object({
        street: Joi.string().min(3).max(100).required(),
        number: Joi.string().min(1).max(20).required(),
        neighborhood: Joi.string().min(3).max(100).required(),
        references: Joi.string().max(255).optional().allow(""),
        postal_code: Joi.string()
          .pattern(VALIDATION_PATTERNS.POSTAL_CODE)
          .optional(),
      }).required(),

      items: Joi.array()
        .items(
          Joi.object({
            menu_item_id: Joi.string().uuid().required(),
            name: Joi.string().max(100).required(),
            base_price: Joi.number().positive().required(),
            quantity: Joi.number().integer().min(1).max(20).required(),
            customizations: Joi.array()
              .items(
                Joi.object({
                  type: Joi.string().max(20).required(),
                  name: Joi.string().max(50).required(),
                  extra_cost: Joi.number().min(0).required(),
                })
              )
              .optional(),
            notes: Joi.string().max(255).optional().allow(""),
          })
        )
        .min(1)
        .max(BUSINESS_CONFIG.MAX_ITEMS_PER_ORDER)
        .required(),

      subtotal: Joi.number()
        .positive()
        .max(BUSINESS_CONFIG.MAX_ORDER_AMOUNT)
        .required(),
      delivery_fee: Joi.number().min(0).optional(),
      total: Joi.number()
        .positive()
        .max(BUSINESS_CONFIG.MAX_ORDER_AMOUNT)
        .required(),
      special_instructions: Joi.string().max(500).optional().allow(""),
    });

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida actualizaci√≥n de estado de pedido
   * @param {Object} data - Datos de actualizaci√≥n
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateOrderStatusUpdate(data) {
    const validStatuses = Object.values(ORDER_STATUS);

    const schema = Joi.object({
      status: Joi.string()
        .valid(...validStatuses)
        .required()
        .messages({
          "any.only": `Estado debe ser uno de: ${validStatuses.join(", ")}`,
        }),

      internal_notes: Joi.string().max(500).optional().allow(""),
      estimated_delivery_time: Joi.number()
        .integer()
        .min(5)
        .max(180)
        .optional(),
    });

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // VALIDACIONES DE CONVERSACI√ìN
  // ============================================

  /**
   * Valida mensaje entrante
   * @param {string} message - Mensaje a validar
   * @param {Object} conversation - Conversaci√≥n actual
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateIncomingMessage(message, conversation) {
    try {
      // Validaciones b√°sicas
      if (!message || typeof message !== "string") {
        return {
          isValid: false,
          error: "Mensaje inv√°lido",
        };
      }

      // Limpiar y validar longitud
      const cleanMessage = message.trim();

      if (cleanMessage.length === 0) {
        return {
          isValid: false,
          error: "Mensaje vac√≠o",
        };
      }

      if (cleanMessage.length > 1000) {
        return {
          isValid: false,
          error: "Mensaje demasiado largo (m√°ximo 1000 caracteres)",
        };
      }

      // Validar caracteres problem√°ticos
      if (this.containsMaliciousContent(cleanMessage)) {
        return {
          isValid: false,
          error: "Contenido no permitido",
        };
      }

      // Validar estado de conversaci√≥n
      if (
        conversation &&
        conversation.status === CONVERSATION_STATUS.COMPLETED
      ) {
        return {
          isValid: false,
          error: "La conversaci√≥n ya ha sido completada",
        };
      }

      return {
        isValid: true,
        cleanMessage,
      };
    } catch (error) {
      logger.error("Error validando mensaje entrante:", error);
      return {
        isValid: false,
        error: "Error de validaci√≥n",
      };
    }
  }

  /**
   * Valida pedido desde conversaci√≥n
   * @param {Object} conversation - Conversaci√≥n con pedido
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateOrderFromConversation(conversation) {
    try {
      if (!conversation) {
        return {
          isValid: false,
          error: "Conversaci√≥n no encontrada",
        };
      }

      let orderData = {};
      try {
        orderData = JSON.parse(conversation.order_data || "{}");
      } catch (e) {
        return {
          isValid: false,
          error: "Datos de pedido corruptos",
        };
      }

      // Validar items
      if (
        !orderData.items ||
        !Array.isArray(orderData.items) ||
        orderData.items.length === 0
      ) {
        return {
          isValid: false,
          error: "El pedido debe tener al menos un item",
        };
      }

      if (orderData.items.length > BUSINESS_CONFIG.MAX_ITEMS_PER_ORDER) {
        return {
          isValid: false,
          error: `M√°ximo ${BUSINESS_CONFIG.MAX_ITEMS_PER_ORDER} items por pedido`,
        };
      }

      // Validar direcci√≥n
      const address = orderData.delivery_address;
      if (
        !address ||
        !address.street ||
        !address.number ||
        !address.neighborhood
      ) {
        return {
          isValid: false,
          error: "Direcci√≥n de entrega incompleta",
        };
      }

      // Validar montos
      if (!orderData.total || orderData.total <= 0) {
        return {
          isValid: false,
          error: "Total del pedido inv√°lido",
        };
      }

      if (orderData.total > BUSINESS_CONFIG.MAX_ORDER_AMOUNT) {
        return {
          isValid: false,
          error: `Monto m√°ximo de pedido: $${BUSINESS_CONFIG.MAX_ORDER_AMOUNT}`,
        };
      }

      // Validar cada item
      for (const item of orderData.items) {
        if (
          !item.menu_item_id ||
          !item.name ||
          !item.base_price ||
          !item.quantity
        ) {
          return {
            isValid: false,
            error: "Item de pedido incompleto",
          };
        }

        if (item.quantity <= 0 || item.quantity > 20) {
          return {
            isValid: false,
            error: "Cantidad de item inv√°lida",
          };
        }
      }

      return {
        isValid: true,
        orderData,
      };
    } catch (error) {
      logger.error("Error validando pedido desde conversaci√≥n:", error);
      return {
        isValid: false,
        error: "Error de validaci√≥n",
      };
    }
  }

  // ============================================
  // VALIDACIONES DE ARCHIVOS
  // ============================================

  /**
   * Valida archivo subido
   * @param {Object} file - Archivo a validar
   * @param {string} type - Tipo esperado ('image', 'document')
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateFileUpload(file, type = "image") {
    try {
      if (!file) {
        return {
          isValid: false,
          error: "Archivo no encontrado",
        };
      }

      // Validar tama√±o
      if (file.size > FILE_LIMITS.MAX_FILE_SIZE) {
        return {
          isValid: false,
          error: `Archivo demasiado grande. M√°ximo: ${FILE_LIMITS.MAX_FILE_SIZE / 1024 / 1024}MB`,
        };
      }

      // Validar tipo MIME
      let allowedTypes = [];

      switch (type) {
        case "image":
          allowedTypes = FILE_LIMITS.ALLOWED_IMAGE_TYPES;
          break;
        case "document":
          allowedTypes = FILE_LIMITS.ALLOWED_DOCUMENT_TYPES;
          break;
        default:
          allowedTypes = [
            ...FILE_LIMITS.ALLOWED_IMAGE_TYPES,
            ...FILE_LIMITS.ALLOWED_DOCUMENT_TYPES,
          ];
      }

      if (!allowedTypes.includes(file.mimetype)) {
        return {
          isValid: false,
          error: `Tipo de archivo no permitido. Permitidos: ${allowedTypes.join(", ")}`,
        };
      }

      return {
        isValid: true,
        file,
      };
    } catch (error) {
      logger.error("Error validando archivo:", error);
      return {
        isValid: false,
        error: "Error de validaci√≥n de archivo",
      };
    }
  }

  // ============================================
  // VALIDACIONES DE PAR√ÅMETROS DE CONSULTA
  // ============================================

  /**
   * Valida par√°metros de paginaci√≥n
   * @param {Object} params - Par√°metros de consulta
   * @returns {Object} Resultado de validaci√≥n
   */
  static validatePaginationParams(params) {
    const schema = Joi.object({
      page: Joi.number().integer().min(1).max(1000).optional().default(1),
      limit: Joi.number().integer().min(1).max(100).optional().default(20),
      sort_by: Joi.string().max(50).optional().default("created_at"),
      sort_order: Joi.string()
        .valid("ASC", "DESC", "asc", "desc")
        .optional()
        .default("DESC"),
    });

    return this.validateWithSchema(schema, params);
  }

  /**
   * Valida par√°metros de filtros de fecha
   * @param {Object} params - Par√°metros de fecha
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateDateRangeParams(params) {
    const schema = Joi.object({
      start_date: Joi.date().iso().optional(),
      end_date: Joi.date().iso().min(Joi.ref("start_date")).optional(),
      period: Joi.string().valid("today", "week", "month", "year").optional(),
    });

    return this.validateWithSchema(schema, params);
  }

  // ============================================
  // VALIDACIONES DE WEBHOOK
  // ============================================

  /**
   * Valida datos de webhook de WhatsApp
   * @param {Object} data - Datos del webhook
   * @param {string} provider - Proveedor (twilio/meta)
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateWhatsAppWebhook(data, provider) {
    try {
      if (!data || typeof data !== "object") {
        return {
          isValid: false,
          error: "Datos de webhook inv√°lidos",
        };
      }

      switch (provider.toLowerCase()) {
        case "twilio":
          return this.validateTwilioWebhook(data);
        case "meta":
          return this.validateMetaWebhook(data);
        default:
          return {
            isValid: false,
            error: "Proveedor no soportado",
          };
      }
    } catch (error) {
      logger.error("Error validando webhook de WhatsApp:", error);
      return {
        isValid: false,
        error: "Error de validaci√≥n de webhook",
      };
    }
  }

  /**
   * Valida webhook de Twilio
   * @param {Object} data - Datos del webhook
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateTwilioWebhook(data) {
    const schema = Joi.object({
      MessageSid: Joi.string().required(),
      From: Joi.string().required(),
      To: Joi.string().required(),
      Body: Joi.string().allow("").optional(),
      MediaUrl0: Joi.string().uri().optional(),
      MediaContentType0: Joi.string().optional(),
    }).unknown(true); // Permitir campos adicionales

    return this.validateWithSchema(schema, data);
  }

  /**
   * Valida webhook de Meta
   * @param {Object} data - Datos del webhook
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateMetaWebhook(data) {
    const schema = Joi.object({
      entry: Joi.array()
        .items(
          Joi.object({
            changes: Joi.array()
              .items(
                Joi.object({
                  value: Joi.object({
                    messages: Joi.array()
                      .items(
                        Joi.object({
                          id: Joi.string().required(),
                          from: Joi.string().required(),
                          text: Joi.object({
                            body: Joi.string().required(),
                          }).optional(),
                          timestamp: Joi.string().required(),
                        }).unknown(true)
                      )
                      .optional(),
                    metadata: Joi.object({
                      phone_number_id: Joi.string().required(),
                    })
                      .unknown(true)
                      .required(),
                  })
                    .unknown(true)
                    .required(),
                }).unknown(true)
              )
              .required(),
          }).unknown(true)
        )
        .required(),
    }).unknown(true);

    return this.validateWithSchema(schema, data);
  }

  // ============================================
  // M√âTODOS AUXILIARES
  // ============================================

  /**
   * Ejecuta validaci√≥n con esquema de Joi
   * @param {Object} schema - Esquema de Joi
   * @param {Object} data - Datos a validar
   * @returns {Object} Resultado de validaci√≥n
   */
  static validateWithSchema(schema, data) {
    try {
      const { error, value } = schema.validate(data, {
        abortEarly: false, // Mostrar todos los errores
        stripUnknown: true, // Remover campos desconocidos
        convert: true, // Convertir tipos autom√°ticamente
      });

      if (error) {
        const errorMessages = error.details.map((detail) => detail.message);

        return {
          isValid: false,
          error: errorMessages.join("; "),
          details: error.details,
        };
      }

      return {
        isValid: true,
        data: value,
      };
    } catch (validationError) {
      logger.error("Error en validaci√≥n con esquema:", validationError);
      return {
        isValid: false,
        error: "Error interno de validaci√≥n",
      };
    }
  }

  /**
   * Verifica si el contenido es malicioso
   * @param {string} content - Contenido a verificar
   * @returns {boolean} True si es malicioso
   */
  static containsMaliciousContent(content) {
    try {
      const maliciousPatterns = [
        /<script/i,
        /javascript:/i,
        /vbscript:/i,
        /onload=/i,
        /onerror=/i,
        /eval\(/i,
        /document\.cookie/i,
        /document\.write/i,
        /<iframe/i,
        /<object/i,
        /<embed/i,
      ];

      return maliciousPatterns.some((pattern) => pattern.test(content));
    } catch (error) {
      logger.error("Error verificando contenido malicioso:", error);
      return false; // En caso de error, permitir el contenido
    }
  }

  /**
   * Valida formato de tel√©fono mexicano
   * @param {string} phone - N√∫mero de tel√©fono
   * @returns {boolean} True si es v√°lido
   */
  static isValidMexicanPhone(phone) {
    try {
      return VALIDATION_PATTERNS.MEXICAN_PHONE.test(phone);
    } catch (error) {
      return false;
    }
  }

  /**
   * Valida formato de email
   * @param {string} email - Email a validar
   * @returns {boolean} True si es v√°lido
   */
  static isValidEmail(email) {
    try {
      return VALIDATION_PATTERNS.EMAIL.test(email);
    } catch (error) {
      return false;
    }
  }

  /**
   * Sanitiza texto de entrada
   * @param {string} text - Texto a sanitizar
   * @returns {string} Texto sanitizado
   */
  static sanitizeText(text) {
    if (!text || typeof text !== "string") {
      return "";
    }

    try {
      return text
        .trim()
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#x27;")
        .replace(/\//g, "&#x2F;");
    } catch (error) {
      logger.error("Error sanitizando texto:", error);
      return text;
    }
  }

  /**
   * Valida UUID
   * @param {string} uuid - UUID a validar
   * @returns {boolean} True si es v√°lido
   */
  static isValidUUID(uuid) {
    const uuidPattern =
      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidPattern.test(uuid);
  }
}

module.exports = ValidationService;



================================================
File: src/services/whatsappService.js
================================================
const {
  sendWhatsAppMessage,
  processTwilioIncomingMessage,
  processMetaIncomingMessage,
  validateTwilioWebhook,
  validateMetaWebhook,
  formatPhoneNumber,
  checkWhatsAppStatus
} = require('../config/whatsapp');

const logger = require('../utils/logger');
const { DEFAULT_MESSAGES, EMOJIS } = require('../utils/constants');
const { ValidationError, ExternalServiceError } = require('../middleware/errorHandler');

// ============================================
// SERVICIO WHATSAPP
// ============================================

class WhatsAppService {

  /**
   * Env√≠a un mensaje de WhatsApp a un cliente
   * @param {string} to - N√∫mero de tel√©fono destino
   * @param {string} message - Mensaje a enviar
   * @param {Object} options - Opciones adicionales
   * @returns {Promise<Object>} Resultado del env√≠o
   */
  static async sendMessage(to, message, options = {}) {
    try {
      const formattedPhone = formatPhoneNumber(to);
      
      // Validar mensaje
      if (!message || message.trim().length === 0) {
        throw new ValidationError('Mensaje vac√≠o');
      }

      // Procesar mensaje (agregar emojis, formatear, etc.)
      const processedMessage = this.processOutgoingMessage(message, options);

      // Enviar mensaje
      const result = await sendWhatsAppMessage(formattedPhone, processedMessage, options);

      logger.logWhatsApp('send', formattedPhone, result.provider, {
        success: result.success,
        messageId: result.messageId,
        messageLength: processedMessage.length
      });

      return result;

    } catch (error) {
      logger.error('Error enviando mensaje de WhatsApp:', error);
      throw new ExternalServiceError('WhatsApp', error.message);
    }
  }

  /**
   * Procesa un mensaje entrante de WhatsApp
   * @param {Object} webhookData - Datos del webhook
   * @param {string} provider - Proveedor (twilio/meta)
   * @returns {Object} Mensaje procesado
   */
  static processIncomingMessage(webhookData, provider) {
    try {
      let processedMessage;

      switch (provider.toLowerCase()) {
        case 'twilio':
          processedMessage = processTwilioIncomingMessage(webhookData);
          break;
        case 'meta':
          processedMessage = processMetaIncomingMessage(webhookData);
          break;
        default:
          throw new ValidationError('Proveedor de WhatsApp no soportado');
      }

      if (!processedMessage) {
        return null;
      }

      // Procesar mensaje entrante (limpiar, validar, etc.)
      processedMessage.body = this.processIncomingMessageText(processedMessage.body);

      logger.logWhatsApp('receive', processedMessage.from, provider, {
        messageId: processedMessage.messageId,
        messageLength: processedMessage.body.length,
        hasMedia: !!processedMessage.mediaUrl
      });

      return processedMessage;

    } catch (error) {
      logger.error('Error procesando mensaje entrante:', error);
      throw error;
    }
  }

  /**
   * Valida un webhook de WhatsApp
   * @param {Object} req - Request object
   * @param {string} provider - Proveedor (twilio/meta)
   * @returns {boolean|string} True/challenge si es v√°lido, false si no
   */
  static validateWebhook(req, provider) {
    try {
      switch (provider.toLowerCase()) {
        case 'twilio':
          const signature = req.headers['x-twilio-signature'];
          const url = `${req.protocol}://${req.get('host')}${req.originalUrl}`;
          return validateTwilioWebhook(signature, url, req.body);

        case 'meta':
          const mode = req.query['hub.mode'];
          const token = req.query['hub.verify_token'];
          const challenge = req.query['hub.challenge'];
          return validateMetaWebhook(mode, token, challenge);

        default:
          return false;
      }

    } catch (error) {
      logger.error('Error validando webhook:', error);
      return false;
    }
  }

  /**
   * Procesa mensaje saliente (agregar formato, emojis, etc.)
   * @param {string} message - Mensaje original
   * @param {Object} options - Opciones de procesamiento
   * @returns {string} Mensaje procesado
   */
  static processOutgoingMessage(message, options = {}) {
    try {
      let processedMessage = message;

      // Aplicar formato b√°sico
      if (options.addGreeting && !this.hasGreeting(message)) {
        processedMessage = `¬°Hola! üëã\n\n${processedMessage}`;
      }

      // Agregar emojis contextualmente
      if (options.addEmojis !== false) {
        processedMessage = this.addContextualEmojis(processedMessage);
      }

      // Formatear listas si las hay
      processedMessage = this.formatLists(processedMessage);

      // Formatear precios
      processedMessage = this.formatPrices(processedMessage);

      // Asegurar que no sea demasiado largo
      if (processedMessage.length > 1600) {
        processedMessage = processedMessage.substring(0, 1597) + '...';
      }

      return processedMessage;

    } catch (error) {
      logger.error('Error procesando mensaje saliente:', error);
      return message; // Retornar mensaje original si hay error
    }
  }

  /**
   * Procesa mensaje entrante (limpiar texto, etc.)
   * @param {string} messageText - Texto del mensaje
   * @returns {string} Texto procesado
   */
  static processIncomingMessageText(messageText) {
    if (!messageText) return '';

    try {
      let processed = messageText;

      // Limpiar espacios extra
      processed = processed.trim().replace(/\s+/g, ' ');

      // Normalizar caracteres especiales
      processed = processed.normalize('NFD').replace(/[\u0300-\u036f]/g, '');

      // Convertir a min√∫scula para an√°lisis (pero mantener original para respuesta)
      const normalized = processed.toLowerCase();

      // Expandir abreviaciones comunes
      const abbreviations = {
        'q': 'que',
        'x': 'por',
        'xq': 'porque',
        'pq': 'porque',
        'tmb': 'tambien',
        'tb': 'tambien',
        'bn': 'bien',
        'ok': 'esta bien',
        'si': 's√≠'
      };

      Object.keys(abbreviations).forEach(abbrev => {
        const regex = new RegExp(`\\b${abbrev}\\b`, 'gi');
        processed = processed.replace(regex, abbreviations[abbrev]);
      });

      return processed;

    } catch (error) {
      logger.error('Error procesando texto entrante:', error);
      return messageText;
    }
  }

  /**
   * Verifica si el mensaje ya tiene saludo
   * @param {string} message - Mensaje a verificar
   * @returns {boolean} True si tiene saludo
   */
  static hasGreeting(message) {
    const greetings = ['hola', 'buenas', 'saludos', 'que tal', 'hello', 'hi'];
    const messageLower = message.toLowerCase();
    return greetings.some(greeting => messageLower.includes(greeting));
  }

  /**
   * Agrega emojis contextualmente al mensaje
   * @param {string} message - Mensaje original
   * @returns {string} Mensaje con emojis
   */
  static addContextualEmojis(message) {
    try {
      let processedMessage = message;
      const messageLower = message.toLowerCase();

      // Solo agregar si no tiene muchos emojis ya
      const emojiCount = (message.match(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]/gu) || []).length;
      
      if (emojiCount > 3) {
        return processedMessage; // Ya tiene suficientes emojis
      }

      // Emojis por contexto
      if (messageLower.includes('gracias') || messageLower.includes('thank')) {
        processedMessage = processedMessage.replace(/gracias/gi, `gracias ${EMOJIS.GENERAL.THANKS}`);
      }

      if (messageLower.includes('pedido') && messageLower.includes('listo')) {
        processedMessage += ` ${EMOJIS.STATUS.SUCCESS}`;
      }

      if (messageLower.includes('error') || messageLower.includes('problema')) {
        processedMessage += ` ${EMOJIS.STATUS.ERROR}`;
      }

      if (messageLower.includes('dinero') || messageLower.includes('total') || messageLower.includes('$')) {
        processedMessage = processedMessage.replace(/total/gi, `total ${EMOJIS.STATUS.MONEY}`);
      }

      if (messageLower.includes('tiempo') || messageLower.includes('minutos')) {
        processedMessage = processedMessage.replace(/minutos/gi, `minutos ${EMOJIS.GENERAL.TIME}`);
      }

      if (messageLower.includes('direcci√≥n') || messageLower.includes('direccion') || messageLower.includes('entrega')) {
        processedMessage = processedMessage.replace(/(direcci√≥n|direccion|entrega)/gi, `$1 ${EMOJIS.GENERAL.LOCATION}`);
      }

      return processedMessage;

    } catch (error) {
      logger.error('Error agregando emojis contextuales:', error);
      return message;
    }
  }

  /**
   * Formatea listas en el mensaje
   * @param {string} message - Mensaje con listas
   * @returns {string} Mensaje con listas formateadas
   */
  static formatLists(message) {
    try {
      let processedMessage = message;

      // Detectar y formatear listas numericas
      const listPattern = /(\d+[\.\)]?\s*[^\n]+)/g;
      const matches = message.match(listPattern);

      if (matches && matches.length > 1) {
        matches.forEach(match => {
          const formatted = match.replace(/^(\d+)[\.\)]*\s*/, '$1Ô∏è‚É£ ');
          processedMessage = processedMessage.replace(match, formatted);
        });
      }

      // Formatear listas con guiones
      processedMessage = processedMessage.replace(/^-\s+/gm, '‚Ä¢ ');
      
      return processedMessage;

    } catch (error) {
      logger.error('Error formateando listas:', error);
      return message;
    }
  }

  /**
   * Formatea precios en el mensaje
   * @param {string} message - Mensaje con precios
   * @returns {string} Mensaje con precios formateados
   */
  static formatPrices(message) {
    try {
      // Formatear precios ($XX.XX o $XX)
      let processedMessage = message.replace(/\$(\d+(?:\.\d{2})?)/g, 'üí∞$$$1');
      
      // Pero no duplicar si ya tiene emoji
      processedMessage = processedMessage.replace(/üí∞üí∞/g, 'üí∞');
      
      return processedMessage;

    } catch (error) {
      logger.error('Error formateando precios:', error);
      return message;
    }
  }

  /**
   * Genera mensaje de confirmaci√≥n de pedido
   * @param {Object} orderData - Datos del pedido
   * @param {Object} restaurant - Datos del restaurante
   * @returns {string} Mensaje de confirmaci√≥n
   */
  static generateOrderConfirmation(orderData, restaurant) {
    try {
      const items = orderData.items || [];
      const deliveryTime = orderData.estimated_delivery_time || restaurant.delivery_time_max || 35;

      let message = `${EMOJIS.STATUS.SUCCESS} *PEDIDO CONFIRMADO*\n\n`;
      
      message += `*Restaurante:* ${restaurant.name}\n`;
      message += `*Pedido:*\n`;

      items.forEach((item, index) => {
        message += `${index + 1}Ô∏è‚É£ ${item.name} (${item.quantity}x) - $${item.item_total}\n`;
        
        if (item.customizations && item.customizations.length > 0) {
          item.customizations.forEach(custom => {
            message += `   ‚Ä¢ ${custom.name}${custom.extra_cost > 0 ? ` (+$${custom.extra_cost})` : ''}\n`;
          });
        }
        
        if (item.notes) {
          message += `   üìù ${item.notes}\n`;
        }
      });

      message += `\n*Subtotal:* $${orderData.subtotal}`;
      
      if (orderData.delivery_fee > 0) {
        message += `\n*Env√≠o:* $${orderData.delivery_fee}`;
      }
      
      message += `\n*TOTAL:* üí∞$${orderData.total}`;

      message += `\n\n*Direcci√≥n de entrega:*\n`;
      message += `${EMOJIS.GENERAL.LOCATION} ${orderData.delivery_address?.street} ${orderData.delivery_address?.number}\n`;
      message += `${orderData.delivery_address?.neighborhood}`;
      
      if (orderData.delivery_address?.references) {
        message += `\nüìç *Referencias:* ${orderData.delivery_address.references}`;
      }

      message += `\n\n${EMOJIS.GENERAL.TIME} *Tiempo estimado:* ${deliveryTime} minutos`;
      
      if (restaurant.phone) {
        message += `\n${EMOJIS.GENERAL.PHONE} *Tel√©fono:* ${restaurant.phone}`;
      }

      message += `\n\n¬°Gracias por tu preferencia! ${EMOJIS.GENERAL.THANKS}`;

      return message;

    } catch (error) {
      logger.error('Error generando confirmaci√≥n de pedido:', error);
      return DEFAULT_MESSAGES.ORDER_CONFIRMED.replace('{delivery_time}', '30-35');
    }
  }

  /**
   * Genera mensaje de men√∫ formateado
   * @param {Array} menuCategories - Categor√≠as del men√∫
   * @param {Object} restaurant - Datos del restaurante
   * @returns {string} Mensaje del men√∫
   */
  static generateMenuMessage(menuCategories, restaurant) {
    try {
      let message = `üçΩÔ∏è *MEN√ö - ${restaurant.name.toUpperCase()}*\n\n`;

      menuCategories.forEach((category, categoryIndex) => {
        if (category.items.length === 0) return;

        const emoji = category.emoji || 'üçΩÔ∏è';
        message += `${emoji} *${category.name.toUpperCase()}*\n`;
        
        if (category.description) {
          message += `_${category.description}_\n`;
        }

        category.items.forEach((item, itemIndex) => {
          message += `${itemIndex + 1}. *${item.name}* - $${item.price}\n`;
          
          if (item.description) {
            message += `   _${item.description}_\n`;
          }
        });

        message += '\n';
      });

      // Agregar informaci√≥n adicional
      if (restaurant.delivery_fee > 0) {
        message += `üöö *Costo de env√≠o:* $${restaurant.delivery_fee}\n`;
      }

      if (restaurant.minimum_order > 0) {
        message += `üì¶ *Pedido m√≠nimo:* $${restaurant.minimum_order}\n`;
      }

      message += `${EMOJIS.GENERAL.TIME} *Tiempo de entrega:* ${restaurant.delivery_time_min}-${restaurant.delivery_time_max} min\n\n`;

      message += `¬øQu√© te gustar√≠a ordenar? üòä`;

      return message;

    } catch (error) {
      logger.error('Error generando mensaje de men√∫:', error);
      return 'Error generando men√∫. Por favor intenta m√°s tarde.';
    }
  }

  /**
   * Genera mensaje de estado del pedido
   * @param {Object} order - Datos del pedido
   * @returns {string} Mensaje de estado
   */
  static generateOrderStatusMessage(order) {
    try {
      const statusEmojis = {
        'confirmed': '‚úÖ',
        'preparing': 'üë®‚Äçüç≥',
        'ready': 'üõµ',
        'out_for_delivery': 'üöó',
        'delivered': '‚úÖ',
        'cancelled': '‚ùå'
      };

      const statusNames = {
        'confirmed': 'Confirmado',
        'preparing': 'En preparaci√≥n',
        'ready': 'Listo para entregar',
        'out_for_delivery': 'En camino',
        'delivered': 'Entregado',
        'cancelled': 'Cancelado'
      };

      const emoji = statusEmojis[order.status] || 'üìã';
      const statusName = statusNames[order.status] || order.status;

      let message = `${emoji} *ESTADO DE TU PEDIDO*\n\n`;
      message += `*Estado:* ${statusName}\n`;
      message += `*Total:* $${order.total}\n`;

      if (order.estimated_delivery_time && order.status !== 'delivered') {
        message += `*Tiempo estimado:* ${order.estimated_delivery_time} min\n`;
      }

      if (order.delivered_at) {
        const deliveredDate = new Date(order.delivered_at);
        message += `*Entregado:* ${deliveredDate.toLocaleString('es-MX')}\n`;
      }

      return message;

    } catch (error) {
      logger.error('Error generando mensaje de estado:', error);
      return 'Error obteniendo estado del pedido.';
    }
  }

  /**
   * Env√≠a mensaje con reintentos autom√°ticos
   * @param {string} to - N√∫mero destino
   * @param {string} message - Mensaje a enviar
   * @param {Object} options - Opciones adicionales
   * @param {number} maxRetries - N√∫mero m√°ximo de reintentos
   * @returns {Promise<Object>} Resultado del env√≠o
   */
  static async sendMessageWithRetry(to, message, options = {}, maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.sendMessage(to, message, options);
        
        if (result.success) {
          if (attempt > 1) {
            logger.info('Mensaje enviado exitosamente despu√©s de reintentos', {
              phone: to.substring(0, 8) + '****',
              attempt,
              maxRetries
            });
          }
          return result;
        }

      } catch (error) {
        lastError = error;
        
        logger.warn(`Intento ${attempt}/${maxRetries} fallido enviando mensaje`, {
          phone: to.substring(0, 8) + '****',
          error: error.message,
          attempt
        });

        if (attempt < maxRetries) {
          // Esperar antes del siguiente intento (backoff exponencial)
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // Si todos los intentos fallaron
    logger.error('Todos los intentos de env√≠o fallaron', {
      phone: to.substring(0, 8) + '****',
      maxRetries,
      finalError: lastError?.message
    });

    throw lastError || new Error('Env√≠o fallido despu√©s de todos los reintentos');
  }

  /**
   * Verifica el estado de los servicios de WhatsApp
   * @returns {Promise<Object>} Estado de los servicios
   */
  static async checkServicesStatus() {
    try {
      const status = await checkWhatsAppStatus();
      
      logger.info('Estado de servicios WhatsApp verificado', status);
      
      return {
        ...status,
        timestamp: new Date().toISOString(),
        healthy: status.activeProvider !== null
      };

    } catch (error) {
      logger.error('Error verificando estado de servicios WhatsApp:', error);
      
      return {
        twilio: false,
        meta: false,
        activeProvider: null,
        healthy: false,
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Procesa mensajes multimedia (im√°genes, documentos)
   * @param {Object} messageData - Datos del mensaje
   * @returns {Promise<Object>} Informaci√≥n del archivo procesado
   */
  static async processMediaMessage(messageData) {
    try {
      const { mediaUrl, mediaType } = messageData;
      
      if (!mediaUrl) {
        return null;
      }

      // Por ahora solo loggear, en el futuro se podr√≠a descargar y procesar
      logger.info('Mensaje multimedia recibido', {
        mediaType,
        mediaUrl: mediaUrl.substring(0, 100) + '...',
        from: messageData.from?.substring(0, 8) + '****'
      });

      return {
        type: mediaType,
        url: mediaUrl,
        processed: false,
        message: 'Los archivos multimedia no est√°n soportados en este momento, pero hemos recibido tu mensaje. ¬øPodr√≠as escribir tu pedido por texto? üòä'
      };

    } catch (error) {
      logger.error('Error procesando mensaje multimedia:', error);
      return {
        processed: false,
        error: error.message,
        message: 'Hubo un problema procesando tu archivo. ¬øPodr√≠as enviar tu pedido por texto? üòä'
      };
    }
  }

  /**
   * Obtiene estad√≠sticas de mensajes
   * @param {string} restaurantId - ID del restaurante
   * @param {Object} dateRange - Rango de fechas
   * @returns {Promise<Object>} Estad√≠sticas de mensajer√≠a
   */
  static async getMessagingStats(restaurantId, dateRange = {}) {
    try {
      // Esta funci√≥n requerir√≠a una tabla de logs de mensajes
      // Por ahora retornamos un placeholder
      return {
        total_sent: 0,
        total_received: 0,
        success_rate: 100,
        avg_response_time: 0,
        failed_messages: 0
      };

    } catch (error) {
      logger.error('Error obteniendo estad√≠sticas de mensajer√≠a:', error);
      throw error;
    }
  }
}

module.exports = WhatsAppService;


================================================
File: src/utils/constants.js
================================================
// ============================================
// CONSTANTES DEL SISTEMA - CHATBOT CHING√ìN
// ============================================

/**
 * Estados de conversaci√≥n
 */
const CONVERSATION_STATUS = {
  ACTIVE: 'active',
  COMPLETING_ORDER: 'completing_order',
  COMPLETED: 'completed',
  ABANDONED: 'abandoned'
};

/**
 * Pasos de la conversaci√≥n
 */
const CONVERSATION_STEPS = {
  GREETING: 'greeting',
  ORDERING: 'ordering',
  CUSTOMIZING: 'customizing',
  REVIEWING: 'reviewing',
  ADDRESS: 'address',
  CONFIRMING: 'confirming',
  COMPLETED: 'completed'
};

/**
 * Estados de pedidos
 */
const ORDER_STATUS = {
  CONFIRMED: 'confirmed',
  PREPARING: 'preparing',
  READY: 'ready',
  OUT_FOR_DELIVERY: 'out_for_delivery',
  DELIVERED: 'delivered',
  CANCELLED: 'cancelled'
};

/**
 * Tipos de reglas de negocio
 */
const BUSINESS_RULE_TYPES = {
  SAUCE_LIMIT: 'sauce_limit',
  EXTRA_COST: 'extra_cost',
  COMBO_RULE: 'combo_rule',
  SIZE_OPTION: 'size_option',
  QUANTITY_LIMIT: 'quantity_limit',
  TIME_RESTRICTION: 'time_restriction',
  AVAILABILITY: 'availability'
};

/**
 * Tipos de customizaci√≥n
 */
const CUSTOMIZATION_TYPES = {
  SAUCE: 'sauce',
  EXTRA: 'extra',
  SIZE: 'size',
  PREPARATION: 'preparation',
  REMOVAL: 'removal'
};

/**
 * Proveedores de WhatsApp
 */
const WHATSAPP_PROVIDERS = {
  TWILIO: 'twilio',
  META: 'meta'
};

/**
 * Modelos de Claude AI disponibles
 */
const CLAUDE_MODELS = {
  SONNET_3_5: 'claude-3-5-sonnet-20241022',
  HAIKU_3: 'claude-3-haiku-20240307',
  OPUS_3: 'claude-3-opus-20240229'
};

/**
 * Niveles de log
 */
const LOG_LEVELS = {
  ERROR: 'error',
  WARN: 'warn',
  INFO: 'info',
  DEBUG: 'debug'
};

/**
 * Tipos de eventos de seguridad
 */
const SECURITY_EVENTS = {
  INVALID_WEBHOOK: 'invalid_webhook',
  RATE_LIMIT_EXCEEDED: 'rate_limit_exceeded',
  UNAUTHORIZED_ACCESS: 'unauthorized_access',
  SUSPICIOUS_ACTIVITY: 'suspicious_activity'
};

/**
 * Configuraci√≥n de tiempo
 */
const TIME_LIMITS = {
  MAX_CONVERSATION_TIME: parseInt(process.env.MAX_CONVERSATION_TIME) || 1800, // 30 minutos
  CONVERSATION_CLEANUP_INTERVAL: parseInt(process.env.CONVERSATION_CLEANUP_INTERVAL) || 3600, // 1 hora
  DEFAULT_DELIVERY_TIME_MIN: parseInt(process.env.DEFAULT_DELIVERY_TIME_MIN) || 25,
  DEFAULT_DELIVERY_TIME_MAX: parseInt(process.env.DEFAULT_DELIVERY_TIME_MAX) || 35,
  MESSAGE_TIMEOUT: 30000, // 30 segundos
  DATABASE_QUERY_TIMEOUT: 30000, // 30 segundos
  CLAUDE_REQUEST_TIMEOUT: 60000 // 60 segundos
};

/**
 * L√≠mites de rate limiting
 */
const RATE_LIMITS = {
  WEBHOOK_PER_MINUTE: 100,
  API_PER_MINUTE: 60,
  CLAUDE_PER_MINUTE: 30,
  WHATSAPP_PER_MINUTE: 50
};

/**
 * Configuraci√≥n de archivos y uploads
 */
const FILE_LIMITS = {
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB
  ALLOWED_IMAGE_TYPES: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  ALLOWED_DOCUMENT_TYPES: ['application/pdf', 'text/plain'],
  MAX_MESSAGE_LENGTH: 4096
};

/**
 * Configuraci√≥n de base de datos
 */
const DATABASE_LIMITS = {
  MAX_POOL_SIZE: parseInt(process.env.DB_POOL_MAX) || 10,
  MIN_POOL_SIZE: parseInt(process.env.DB_POOL_MIN) || 2,
  IDLE_TIMEOUT: parseInt(process.env.DB_IDLE_TIMEOUT) || 10000,
  CONNECTION_TIMEOUT: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 2000
};

/**
 * Mensajes predeterminados del sistema
 */
const DEFAULT_MESSAGES = {
  WELCOME: '¬°Hola! üëã Bienvenido a nuestro restaurante. ¬øEn qu√© puedo ayudarte hoy?',
  ERROR: 'Lo siento, tuve un problema t√©cnico. ¬øPodr√≠as repetir tu mensaje?',
  GOODBYE: '¬°Gracias por tu pedido! üôè Te esperamos pronto.',
  TIMEOUT: 'He notado que no has respondido en un tiempo. ¬øSigues ah√≠? Tu pedido sigue guardado.',
  INVALID_INPUT: 'No entend√≠ tu mensaje. ¬øPodr√≠as ser m√°s espec√≠fico?',
  ORDER_CONFIRMED: '‚úÖ ¬°Pedido confirmado! Llegar√° en {delivery_time} minutos aproximadamente.',
  ORDER_CANCELLED: '‚ùå Pedido cancelado. ¬øHay algo m√°s en lo que pueda ayudarte?',
  RESTAURANT_CLOSED: 'üòî Lo siento, estamos cerrados en este momento. Nuestros horarios son: {hours}',
  OUT_OF_DELIVERY_ZONE: 'üìç Lo siento, no hacemos entregas a esa zona. Nuestras zonas de entrega son: {zones}'
};

/**
 * Regex patterns para validaci√≥n
 */
const VALIDATION_PATTERNS = {
  PHONE_NUMBER: /^\+[1-9]\d{1,14}$/,
  EMAIL: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  MEXICAN_PHONE: /^(\+52|52)?[1-9]\d{9}$/,
  POSTAL_CODE: /^\d{5}$/,
  SLUG: /^[a-z0-9]+(?:-[a-z0-9]+)*$/
};

/**
 * Configuraci√≥n de Claude AI
 */
const CLAUDE_CONFIG = {
  DEFAULT_MODEL: process.env.CLAUDE_MODEL || CLAUDE_MODELS.SONNET_3_5,
  DEFAULT_MAX_TOKENS: parseInt(process.env.CLAUDE_MAX_TOKENS) || 500,
  DEFAULT_TEMPERATURE: parseFloat(process.env.CLAUDE_TEMPERATURE) || 0.7,
  MAX_CONTEXT_LENGTH: 100000, // tokens aproximados
  RETRY_ATTEMPTS: 3,
  RETRY_DELAY: 1000 // 1 segundo
};

/**
 * Configuraci√≥n de negocio
 */
const BUSINESS_CONFIG = {
  MIN_ORDER_AMOUNT: 50, // Monto m√≠nimo de pedido por defecto
  MAX_ORDER_AMOUNT: 5000, // Monto m√°ximo de pedido
  DEFAULT_DELIVERY_FEE: 0,
  MAX_ITEMS_PER_ORDER: 20,
  MAX_CUSTOMIZATIONS_PER_ITEM: 10,
  COMMISSION_RATE: 0.08, // 8% de comisi√≥n por defecto
  TAX_RATE: 0.16 // 16% IVA en M√©xico
};

/**
 * Configuraci√≥n de cache
 */
const CACHE_CONFIG = {
  MENU_TTL: 300, // 5 minutos
  RESTAURANT_TTL: 600, // 10 minutos
  BUSINESS_RULES_TTL: 300, // 5 minutos
  CONVERSATION_TTL: 1800 // 30 minutos
};

/**
 * Configuraci√≥n de notificaciones
 */
const NOTIFICATION_TYPES = {
  NEW_ORDER: 'new_order',
  ORDER_UPDATE: 'order_update',
  CUSTOMER_MESSAGE: 'customer_message',
  SYSTEM_ERROR: 'system_error',
  LOW_INVENTORY: 'low_inventory'
};

/**
 * Estados de disponibilidad
 */
const AVAILABILITY_STATUS = {
  AVAILABLE: 'available',
  OUT_OF_STOCK: 'out_of_stock',
  TEMPORARILY_UNAVAILABLE: 'temporarily_unavailable',
  DISCONTINUED: 'discontinued'
};

/**
 * Tipos de descuento
 */
const DISCOUNT_TYPES = {
  PERCENTAGE: 'percentage',
  FIXED_AMOUNT: 'fixed_amount',
  FREE_ITEM: 'free_item',
  FREE_DELIVERY: 'free_delivery'
};

/**
 * M√©todos de pago (para futuras implementaciones)
 */
const PAYMENT_METHODS = {
  CASH: 'cash',
  CARD: 'card',
  TRANSFER: 'transfer',
  DIGITAL_WALLET: 'digital_wallet'
};

/**
 * D√≠as de la semana
 */
const WEEKDAYS = {
  MONDAY: 1,
  TUESDAY: 2,
  WEDNESDAY: 3,
  THURSDAY: 4,
  FRIDAY: 5,
  SATURDAY: 6,
  SUNDAY: 0
};

/**
 * Formatos de fecha y hora
 */
const DATE_FORMATS = {
  ISO: 'YYYY-MM-DDTHH:mm:ss.SSSZ',
  DATE_ONLY: 'YYYY-MM-DD',
  TIME_ONLY: 'HH:mm:ss',
  DISPLAY: 'DD/MM/YYYY HH:mm',
  SHORT_DATE: 'DD/MM/YYYY'
};

/**
 * Configuraci√≥n de emojis para el chat
 */
const EMOJIS = {
  FOOD: {
    CHICKEN: 'üçó',
    BURGER: 'üçî',
    PIZZA: 'üçï',
    TACO: 'üåÆ',
    HOTDOG: 'üå≠',
    FRIES: 'üçü'
  },
  DRINKS: {
    BEER: 'üç∫',
    SODA: 'ü•§',
    WATER: 'üíß',
    COFFEE: '‚òï',
    JUICE: 'üßÉ'
  },
  STATUS: {
    SUCCESS: '‚úÖ',
    ERROR: '‚ùå',
    WARNING: '‚ö†Ô∏è',
    INFO: '‚ÑπÔ∏è',
    LOADING: '‚è≥',
    MONEY: 'üí∞'
  },
  GENERAL: {
    HELLO: 'üëã',
    THANKS: 'üôè',
    LOCATION: 'üìç',
    TIME: '‚è∞',
    PHONE: 'üìû',
    FIRE: 'üî•'
  }
};

/**
 * Funci√≥n helper para obtener emoji de comida
 * @param {string} category - Categor√≠a del producto
 * @returns {string} Emoji correspondiente
 */
const getFoodEmoji = (category) => {
  const categoryLower = category.toLowerCase();
  
  if (categoryLower.includes('alit') || categoryLower.includes('pollo')) return EMOJIS.FOOD.CHICKEN;
  if (categoryLower.includes('hamburg')) return EMOJIS.FOOD.BURGER;
  if (categoryLower.includes('pizza')) return EMOJIS.FOOD.PIZZA;
  if (categoryLower.includes('taco')) return EMOJIS.FOOD.TACO;
  if (categoryLower.includes('hotdog') || categoryLower.includes('hot dog')) return EMOJIS.FOOD.HOTDOG;
  if (categoryLower.includes('papa') || categoryLower.includes('frita')) return EMOJIS.FOOD.FRIES;
  if (categoryLower.includes('bebida') || categoryLower.includes('refresco')) return EMOJIS.DRINKS.SODA;
  if (categoryLower.includes('cerveza') || categoryLower.includes('michela')) return EMOJIS.DRINKS.BEER;
  
  return 'üçΩÔ∏è'; // Emoji por defecto
};

/**
 * Funci√≥n helper para validar n√∫mero de tel√©fono mexicano
 * @param {string} phone - N√∫mero de tel√©fono
 * @returns {boolean} True si es v√°lido
 */
const isValidMexicanPhone = (phone) => {
  return VALIDATION_PATTERNS.MEXICAN_PHONE.test(phone);
};

/**
 * Funci√≥n helper para formatear moneda mexicana
 * @param {number} amount - Cantidad
 * @returns {string} Cantidad formateada
 */
const formatMXNCurrency = (amount) => {
  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency: 'MXN'
  }).format(amount);
};

// ============================================
// EXPORTS
// ============================================

module.exports = {
  // Estados y tipos
  CONVERSATION_STATUS,
  CONVERSATION_STEPS,
  ORDER_STATUS,
  BUSINESS_RULE_TYPES,
  CUSTOMIZATION_TYPES,
  WHATSAPP_PROVIDERS,
  CLAUDE_MODELS,
  LOG_LEVELS,
  SECURITY_EVENTS,
  NOTIFICATION_TYPES,
  AVAILABILITY_STATUS,
  DISCOUNT_TYPES,
  PAYMENT_METHODS,
  
  // Configuraci√≥n
  TIME_LIMITS,
  RATE_LIMITS,
  FILE_LIMITS,
  DATABASE_LIMITS,
  CLAUDE_CONFIG,
  BUSINESS_CONFIG,
  CACHE_CONFIG,
  
  // Mensajes y validaci√≥n
  DEFAULT_MESSAGES,
  VALIDATION_PATTERNS,
  
  // Utilidades
  WEEKDAYS,
  DATE_FORMATS,
  EMOJIS,
  
  // Funciones helper
  getFoodEmoji,
  isValidMexicanPhone,
  formatMXNCurrency
};


================================================
File: src/utils/helpers.js
================================================



================================================
File: src/utils/logger.js
================================================
const winston = require('winston');
const path = require('path');

// ============================================
// CONFIGURACI√ìN DEL LOGGER
// ============================================

const logLevel = process.env.LOG_LEVEL || 'info';
const logFile = process.env.LOG_FILE || 'logs/app.log';
const errorLogFile = process.env.ERROR_LOG_FILE || 'logs/error.log';

// Crear directorio de logs si no existe
const fs = require('fs');
const logDir = path.dirname(logFile);
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

// ============================================
// FORMATOS PERSONALIZADOS
// ============================================

// Formato para consola (desarrollo)
const consoleFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.colorize(),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let logMessage = `${timestamp} [${level}]: ${message}`;
    
    // Agregar metadata si existe
    if (Object.keys(meta).length > 0) {
      logMessage += ` ${JSON.stringify(meta, null, 2)}`;
    }
    
    return logMessage;
  })
);

// Formato para archivos (producci√≥n)
const fileFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// ============================================
// TRANSPORTES
// ============================================

const transports = [];

// Transporte de consola (siempre activo en desarrollo)
if (process.env.NODE_ENV !== 'production') {
  transports.push(
    new winston.transports.Console({
      level: logLevel,
      format: consoleFormat,
      handleExceptions: true,
      handleRejections: true
    })
  );
}

// Transporte de archivo general
transports.push(
  new winston.transports.File({
    filename: logFile,
    level: logLevel,
    format: fileFormat,
    maxsize: 5242880, // 5MB
    maxFiles: 5,
    handleExceptions: true
  })
);

// Transporte de archivo solo para errores
transports.push(
  new winston.transports.File({
    filename: errorLogFile,
    level: 'error',
    format: fileFormat,
    maxsize: 5242880, // 5MB
    maxFiles: 5,
    handleExceptions: true,
    handleRejections: true
  })
);

// ============================================
// CREAR LOGGER
// ============================================

const logger = winston.createLogger({
  level: logLevel,
  format: fileFormat,
  transports,
  exitOnError: false,
  
  // Manejo de excepciones no capturadas
  exceptionHandlers: [
    new winston.transports.File({ 
      filename: 'logs/exceptions.log',
      format: fileFormat
    })
  ],
  
  // Manejo de promesas rechazadas
  rejectionHandlers: [
    new winston.transports.File({ 
      filename: 'logs/rejections.log',
      format: fileFormat
    })
  ]
});

// ============================================
// FUNCIONES DE UTILIDAD
// ============================================

/**
 * Log espec√≠fico para requests HTTP
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 * @param {number} duration - Duraci√≥n en ms
 */
logger.logRequest = (req, res, duration) => {
  const logData = {
    method: req.method,
    url: req.originalUrl,
    statusCode: res.statusCode,
    duration: `${duration}ms`,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    contentLength: res.get('Content-Length') || 0
  };

  if (res.statusCode >= 400) {
    logger.warn('HTTP Request - Error', logData);
  } else {
    logger.info('HTTP Request', logData);
  }
};

/**
 * Log espec√≠fico para operaciones de base de datos
 * @param {string} operation - Tipo de operaci√≥n
 * @param {string} table - Tabla afectada
 * @param {number} duration - Duraci√≥n en ms
 * @param {number} rowCount - N√∫mero de filas afectadas
 * @param {Object} metadata - Datos adicionales
 */
logger.logDatabase = (operation, table, duration, rowCount = 0, metadata = {}) => {
  logger.debug('Database Operation', {
    operation,
    table,
    duration: `${duration}ms`,
    rowCount,
    ...metadata
  });
};

/**
 * Log espec√≠fico para interacciones con Claude AI
 * @param {string} operation - Tipo de operaci√≥n
 * @param {number} duration - Duraci√≥n en ms
 * @param {Object} usage - Informaci√≥n de tokens
 * @param {Object} metadata - Datos adicionales
 */
logger.logClaude = (operation, duration, usage = {}, metadata = {}) => {
  logger.info('Claude AI Operation', {
    operation,
    duration: `${duration}ms`,
    inputTokens: usage.input_tokens,
    outputTokens: usage.output_tokens,
    totalTokens: (usage.input_tokens || 0) + (usage.output_tokens || 0),
    ...metadata
  });
};

/**
 * Log espec√≠fico para WhatsApp
 * @param {string} operation - Tipo de operaci√≥n (send, receive, etc.)
 * @param {string} phone - N√∫mero de tel√©fono
 * @param {string} provider - Proveedor (twilio, meta)
 * @param {Object} metadata - Datos adicionales
 */
logger.logWhatsApp = (operation, phone, provider, metadata = {}) => {
  logger.info('WhatsApp Operation', {
    operation,
    phone: phone ? phone.substring(0, 8) + '****' : 'unknown', // Enmascarar n√∫mero
    provider,
    ...metadata
  });
};

/**
 * Log espec√≠fico para errores de negocio
 * @param {string} context - Contexto del error
 * @param {Error} error - Error object
 * @param {Object} metadata - Datos adicionales
 */
logger.logBusinessError = (context, error, metadata = {}) => {
  logger.error('Business Logic Error', {
    context,
    error: error.message,
    stack: error.stack,
    ...metadata
  });
};

/**
 * Log espec√≠fico para m√©tricas de rendimiento
 * @param {string} metric - Nombre de la m√©trica
 * @param {number} value - Valor de la m√©trica
 * @param {string} unit - Unidad de medida
 * @param {Object} metadata - Datos adicionales
 */
logger.logMetric = (metric, value, unit = '', metadata = {}) => {
  logger.info('Performance Metric', {
    metric,
    value,
    unit,
    timestamp: new Date().toISOString(),
    ...metadata
  });
};

/**
 * Log espec√≠fico para eventos de seguridad
 * @param {string} event - Tipo de evento
 * @param {string} severity - Severidad (low, medium, high, critical)
 * @param {Object} metadata - Datos adicionales
 */
logger.logSecurity = (event, severity = 'medium', metadata = {}) => {
  const logLevel = {
    low: 'info',
    medium: 'warn',
    high: 'error',
    critical: 'error'
  }[severity] || 'warn';

  logger[logLevel]('Security Event', {
    event,
    severity,
    timestamp: new Date().toISOString(),
    ...metadata
  });
};

// ============================================
// MIDDLEWARE PARA EXPRESS
// ============================================

/**
 * Middleware para logging autom√°tico de requests
 */
logger.requestMiddleware = () => {
  return (req, res, next) => {
    const start = Date.now();
    
    // Interceptar el final de la respuesta
    const originalSend = res.send;
    res.send = function(body) {
      const duration = Date.now() - start;
      logger.logRequest(req, res, duration);
      
      // Llamar al m√©todo original
      originalSend.call(this, body);
    };
    
    next();
  };
};

// ============================================
// FUNCIONES DE UTILIDAD ADICIONALES
// ============================================

/**
 * Crea un logger hijo con contexto espec√≠fico
 * @param {Object} context - Contexto para el logger hijo
 * @returns {Object} Logger hijo
 */
logger.child = (context) => {
  return logger.child(context);
};

/**
 * Obtiene estad√≠sticas de logs
 * @returns {Object} Estad√≠sticas
 */
logger.getStats = () => {
  // Esta funci√≥n podr√≠a expandirse para leer archivos de log
  // y proporcionar estad√≠sticas √∫tiles
  return {
    level: logger.level,
    transports: logger.transports.length,
    logFile,
    errorLogFile
  };
};

/**
 * Cambia el nivel de log din√°micamente
 * @param {string} newLevel - Nuevo nivel de log
 */
logger.setLevel = (newLevel) => {
  logger.level = newLevel;
  logger.transports.forEach(transport => {
    transport.level = newLevel;
  });
  logger.info(`Nivel de log cambiado a: ${newLevel}`);
};

// ============================================
// MANEJO ESPECIAL PARA DESARROLLO
// ============================================

if (process.env.NODE_ENV === 'development') {
  // En desarrollo, tambi√©n logear a consola con colores
  logger.add(new winston.transports.Console({
    level: 'debug',
    format: consoleFormat
  }));
  
  logger.info('üöÄ Logger configurado para desarrollo');
  logger.debug('Debug logging habilitado');
}

// ============================================
// EXPORT
// ============================================

module.exports = logger;


================================================
File: src/utils/validators.js
================================================




